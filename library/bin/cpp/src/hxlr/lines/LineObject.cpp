// Generated by Haxe 4.1.5
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_hxlr_lines_LineObject
#include <hxlr/lines/LineObject.h>
#endif
#ifndef INCLUDED_hxlr_math_geom_Line
#include <hxlr/math/geom/Line.h>
#endif
#ifndef INCLUDED_hxlr_math_geom_Point
#include <hxlr/math/geom/Point.h>
#endif
#ifndef INCLUDED_hxlr_rider_ContactPoint
#include <hxlr/rider/ContactPoint.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_8a811927364aa3d9_12_new,"hxlr.lines.LineObject","new",0x169343cc,"hxlr.lines.LineObject.new","hxlr/lines/LineObject.hx",12,0xcd553122)
HX_LOCAL_STACK_FRAME(_hx_pos_8a811927364aa3d9_60_set_length,"hxlr.lines.LineObject","set_length",0x1d39b537,"hxlr.lines.LineObject.set_length","hxlr/lines/LineObject.hx",60,0xcd553122)
HX_LOCAL_STACK_FRAME(_hx_pos_8a811927364aa3d9_68_calculateConstants,"hxlr.lines.LineObject","calculateConstants",0x4c702a5d,"hxlr.lines.LineObject.calculateConstants","hxlr/lines/LineObject.hx",68,0xcd553122)
HX_LOCAL_STACK_FRAME(_hx_pos_8a811927364aa3d9_82_setLim,"hxlr.lines.LineObject","setLim",0xd57754e2,"hxlr.lines.LineObject.setLim","hxlr/lines/LineObject.hx",82,0xcd553122)
HX_LOCAL_STACK_FRAME(_hx_pos_8a811927364aa3d9_100_collide,"hxlr.lines.LineObject","collide",0xd31f48ea,"hxlr.lines.LineObject.collide","hxlr/lines/LineObject.hx",100,0xcd553122)
HX_LOCAL_STACK_FRAME(_hx_pos_8a811927364aa3d9_104_toSaveObject,"hxlr.lines.LineObject","toSaveObject",0x3cfcfa4b,"hxlr.lines.LineObject.toSaveObject","hxlr/lines/LineObject.hx",104,0xcd553122)
namespace hxlr{
namespace lines{

void LineObject_obj::__construct( ::hxlr::math::geom::Point _start, ::hxlr::math::geom::Point _end,bool _shift, ::Dynamic __o__lim){
            		 ::Dynamic _lim = __o__lim;
            		if (::hx::IsNull(__o__lim)) _lim = 0;
            	HX_GC_STACKFRAME(&_hx_pos_8a811927364aa3d9_12_new)
HXLINE(  38)		this->limValue = ((Float)0);
HXLINE(  37)		this->limEnd = ((Float)0);
HXLINE(  36)		this->limStart = ((Float)0);
HXLINE(  35)		this->limType = 0;
HXLINE(  33)		this->zone = 10;
HXLINE(  17)		this->tangible = false;
HXLINE(  45)		super::__construct(_start,_end);
HXLINE(  47)		this->gfxEnd =  ::hxlr::math::geom::Point_obj::__alloc( HX_CTX ,(this->end->x - this->start->x),(this->end->y - this->start->y));
HXLINE(  49)		this->shifted = _shift;
HXLINE(  51)		this->keyList = ::Array_obj< ::String >::__new();
HXLINE(  53)		this->calculateConstants();
HXLINE(  55)		this->setLim(( (int)(_lim) ));
            	}

Dynamic LineObject_obj::__CreateEmpty() { return new LineObject_obj; }

void *LineObject_obj::_hx_vtable = 0;

Dynamic LineObject_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< LineObject_obj > _hx_result = new LineObject_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2],inArgs[3]);
	return _hx_result;
}

bool LineObject_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x196fd3dc) {
		return inClassId==(int)0x00000001 || inClassId==(int)0x196fd3dc;
	} else {
		return inClassId==(int)0x2a2a2bae;
	}
}

Float LineObject_obj::set_length(Float value){
            	HX_STACKFRAME(&_hx_pos_8a811927364aa3d9_60_set_length)
HXLINE(  61)		this->super::set_length(value);
HXLINE(  63)		this->calculateConstants();
HXLINE(  65)		return value;
            	}


void LineObject_obj::calculateConstants(){
            	HX_STACKFRAME(&_hx_pos_8a811927364aa3d9_68_calculateConstants)
HXLINE(  69)		this->dx = (this->end->x - this->start->x);
HXLINE(  70)		this->dy = (this->end->y - this->start->y);
HXLINE(  71)		this->C = ((this->dy * this->start->x) - (this->dx * this->start->y));
HXLINE(  72)		Float _loc2 = (::Math_obj::pow(this->dx,( (Float)(2) )) + ::Math_obj::pow(this->dy,( (Float)(2) )));
HXLINE(  73)		this->invSqrDistance = (( (Float)(1) ) / _loc2);
HXLINE(  74)		this->distance = ::Math_obj::sqrt(_loc2);
HXLINE(  75)		this->invDistance = (( (Float)(1) ) / this->distance);
HXLINE(  76)		int _hx_tmp;
HXDLIN(  76)		if (this->shifted) {
HXLINE(  76)			_hx_tmp = 1;
            		}
            		else {
HXLINE(  76)			_hx_tmp = -1;
            		}
HXDLIN(  76)		this->nx = ((this->dy * this->invDistance) * ( (Float)(_hx_tmp) ));
HXLINE(  77)		int _hx_tmp1;
HXDLIN(  77)		if (this->shifted) {
HXLINE(  77)			_hx_tmp1 = -1;
            		}
            		else {
HXLINE(  77)			_hx_tmp1 = 1;
            		}
HXDLIN(  77)		this->ny = ((this->dx * this->invDistance) * ( (Float)(_hx_tmp1) ));
HXLINE(  78)		this->limValue = ::Math_obj::min(((Float)0.25),(( (Float)(this->zone) ) / this->distance));
            	}


HX_DEFINE_DYNAMIC_FUNC0(LineObject_obj,calculateConstants,(void))

void LineObject_obj::setLim(int _limMode){
            	HX_STACKFRAME(&_hx_pos_8a811927364aa3d9_82_setLim)
HXLINE(  83)		switch((int)(_limMode)){
            			case (int)0: {
HXLINE(  85)				this->limStart = ( (Float)(0) );
HXLINE(  86)				this->limEnd = ( (Float)(1) );
            			}
            			break;
            			case (int)1: {
HXLINE(  88)				this->limStart = -(this->limValue);
HXLINE(  89)				this->limEnd = ( (Float)(1) );
            			}
            			break;
            			case (int)2: {
HXLINE(  91)				this->limStart = ( (Float)(0) );
HXLINE(  92)				this->limEnd = (1 + this->limValue);
            			}
            			break;
            			case (int)3: {
HXLINE(  94)				this->limStart = -(this->limValue);
HXLINE(  95)				this->limEnd = (1 + this->limValue);
            			}
            			break;
            		}
HXLINE(  97)		this->limType = _limMode;
            	}


HX_DEFINE_DYNAMIC_FUNC1(LineObject_obj,setLim,(void))

void LineObject_obj::collide( ::hxlr::rider::ContactPoint _point){
            	HX_STACKFRAME(&_hx_pos_8a811927364aa3d9_100_collide)
            	}


HX_DEFINE_DYNAMIC_FUNC1(LineObject_obj,collide,(void))

 ::Dynamic LineObject_obj::toSaveObject(){
            	HX_STACKFRAME(&_hx_pos_8a811927364aa3d9_104_toSaveObject)
HXLINE( 113)		bool save;
HXDLIN( 113)		switch((int)(this->limType)){
            			case (int)1: case (int)3: {
HXLINE( 113)				save = true;
            			}
            			break;
            			case (int)0: case (int)2: {
HXLINE( 113)				save = false;
            			}
            			break;
            			default:{
HXLINE( 113)				save = false;
            			}
            		}
HXLINE( 121)		bool save1;
HXDLIN( 121)		switch((int)(this->limType)){
            			case (int)0: case (int)1: {
HXLINE( 121)				save1 = false;
            			}
            			break;
            			case (int)2: case (int)3: {
HXLINE( 121)				save1 = true;
            			}
            			break;
            			default:{
HXLINE( 121)				save1 = false;
            			}
            		}
HXLINE( 105)		 ::Dynamic save2 =  ::Dynamic(::hx::Anon_obj::Create(9)
            			->setFixed(0,HX_("leftExtended",e0,77,1a,82),save)
            			->setFixed(1,HX_("id",db,5b,00,00),this->id)
            			->setFixed(2,HX_("x1",b9,68,00,00),this->start->x)
            			->setFixed(3,HX_("x2",ba,68,00,00),this->end->x)
            			->setFixed(4,HX_("y1",98,69,00,00),this->start->y)
            			->setFixed(5,HX_("y2",99,69,00,00),this->end->y)
            			->setFixed(6,HX_("type",ba,f2,08,4d),this->type)
            			->setFixed(7,HX_("rightExtended",b5,d8,e5,4e),save1)
            			->setFixed(8,HX_("flipped",42,6c,88,7f),this->shifted));
HXLINE( 130)		return save2;
            	}


HX_DEFINE_DYNAMIC_FUNC0(LineObject_obj,toSaveObject,return )


::hx::ObjectPtr< LineObject_obj > LineObject_obj::__new( ::hxlr::math::geom::Point _start, ::hxlr::math::geom::Point _end,bool _shift, ::Dynamic __o__lim) {
	::hx::ObjectPtr< LineObject_obj > __this = new LineObject_obj();
	__this->__construct(_start,_end,_shift,__o__lim);
	return __this;
}

::hx::ObjectPtr< LineObject_obj > LineObject_obj::__alloc(::hx::Ctx *_hx_ctx, ::hxlr::math::geom::Point _start, ::hxlr::math::geom::Point _end,bool _shift, ::Dynamic __o__lim) {
	LineObject_obj *__this = (LineObject_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(LineObject_obj), true, "hxlr.lines.LineObject"));
	*(void **)__this = LineObject_obj::_hx_vtable;
	__this->__construct(_start,_end,_shift,__o__lim);
	return __this;
}

LineObject_obj::LineObject_obj()
{
}

void LineObject_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(LineObject);
	HX_MARK_MEMBER_NAME(id,"id");
	HX_MARK_MEMBER_NAME(type,"type");
	HX_MARK_MEMBER_NAME(tangible,"tangible");
	HX_MARK_MEMBER_NAME(keyList,"keyList");
	HX_MARK_MEMBER_NAME(gfxEnd,"gfxEnd");
	HX_MARK_MEMBER_NAME(shifted,"shifted");
	HX_MARK_MEMBER_NAME(dx,"dx");
	HX_MARK_MEMBER_NAME(dy,"dy");
	HX_MARK_MEMBER_NAME(C,"C");
	HX_MARK_MEMBER_NAME(distance,"distance");
	HX_MARK_MEMBER_NAME(invSqrDistance,"invSqrDistance");
	HX_MARK_MEMBER_NAME(invDistance,"invDistance");
	HX_MARK_MEMBER_NAME(nx,"nx");
	HX_MARK_MEMBER_NAME(ny,"ny");
	HX_MARK_MEMBER_NAME(zone,"zone");
	HX_MARK_MEMBER_NAME(limType,"limType");
	HX_MARK_MEMBER_NAME(limStart,"limStart");
	HX_MARK_MEMBER_NAME(limEnd,"limEnd");
	HX_MARK_MEMBER_NAME(limValue,"limValue");
	HX_MARK_MEMBER_NAME(prevLine,"prevLine");
	HX_MARK_MEMBER_NAME(nextLine,"nextLine");
	 ::hxlr::math::geom::Line_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void LineObject_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(id,"id");
	HX_VISIT_MEMBER_NAME(type,"type");
	HX_VISIT_MEMBER_NAME(tangible,"tangible");
	HX_VISIT_MEMBER_NAME(keyList,"keyList");
	HX_VISIT_MEMBER_NAME(gfxEnd,"gfxEnd");
	HX_VISIT_MEMBER_NAME(shifted,"shifted");
	HX_VISIT_MEMBER_NAME(dx,"dx");
	HX_VISIT_MEMBER_NAME(dy,"dy");
	HX_VISIT_MEMBER_NAME(C,"C");
	HX_VISIT_MEMBER_NAME(distance,"distance");
	HX_VISIT_MEMBER_NAME(invSqrDistance,"invSqrDistance");
	HX_VISIT_MEMBER_NAME(invDistance,"invDistance");
	HX_VISIT_MEMBER_NAME(nx,"nx");
	HX_VISIT_MEMBER_NAME(ny,"ny");
	HX_VISIT_MEMBER_NAME(zone,"zone");
	HX_VISIT_MEMBER_NAME(limType,"limType");
	HX_VISIT_MEMBER_NAME(limStart,"limStart");
	HX_VISIT_MEMBER_NAME(limEnd,"limEnd");
	HX_VISIT_MEMBER_NAME(limValue,"limValue");
	HX_VISIT_MEMBER_NAME(prevLine,"prevLine");
	HX_VISIT_MEMBER_NAME(nextLine,"nextLine");
	 ::hxlr::math::geom::Line_obj::__Visit(HX_VISIT_ARG);
}

::hx::Val LineObject_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 1:
		if (HX_FIELD_EQ(inName,"C") ) { return ::hx::Val( C ); }
		break;
	case 2:
		if (HX_FIELD_EQ(inName,"id") ) { return ::hx::Val( id ); }
		if (HX_FIELD_EQ(inName,"dx") ) { return ::hx::Val( dx ); }
		if (HX_FIELD_EQ(inName,"dy") ) { return ::hx::Val( dy ); }
		if (HX_FIELD_EQ(inName,"nx") ) { return ::hx::Val( nx ); }
		if (HX_FIELD_EQ(inName,"ny") ) { return ::hx::Val( ny ); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"type") ) { return ::hx::Val( type ); }
		if (HX_FIELD_EQ(inName,"zone") ) { return ::hx::Val( zone ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"gfxEnd") ) { return ::hx::Val( gfxEnd ); }
		if (HX_FIELD_EQ(inName,"limEnd") ) { return ::hx::Val( limEnd ); }
		if (HX_FIELD_EQ(inName,"setLim") ) { return ::hx::Val( setLim_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"keyList") ) { return ::hx::Val( keyList ); }
		if (HX_FIELD_EQ(inName,"shifted") ) { return ::hx::Val( shifted ); }
		if (HX_FIELD_EQ(inName,"limType") ) { return ::hx::Val( limType ); }
		if (HX_FIELD_EQ(inName,"collide") ) { return ::hx::Val( collide_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"tangible") ) { return ::hx::Val( tangible ); }
		if (HX_FIELD_EQ(inName,"distance") ) { return ::hx::Val( distance ); }
		if (HX_FIELD_EQ(inName,"limStart") ) { return ::hx::Val( limStart ); }
		if (HX_FIELD_EQ(inName,"limValue") ) { return ::hx::Val( limValue ); }
		if (HX_FIELD_EQ(inName,"prevLine") ) { return ::hx::Val( prevLine ); }
		if (HX_FIELD_EQ(inName,"nextLine") ) { return ::hx::Val( nextLine ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"set_length") ) { return ::hx::Val( set_length_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"invDistance") ) { return ::hx::Val( invDistance ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"toSaveObject") ) { return ::hx::Val( toSaveObject_dyn() ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"invSqrDistance") ) { return ::hx::Val( invSqrDistance ); }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"calculateConstants") ) { return ::hx::Val( calculateConstants_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val LineObject_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 1:
		if (HX_FIELD_EQ(inName,"C") ) { C=inValue.Cast< Float >(); return inValue; }
		break;
	case 2:
		if (HX_FIELD_EQ(inName,"id") ) { id=inValue.Cast<  ::Dynamic >(); return inValue; }
		if (HX_FIELD_EQ(inName,"dx") ) { dx=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"dy") ) { dy=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"nx") ) { nx=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"ny") ) { ny=inValue.Cast< Float >(); return inValue; }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"type") ) { type=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"zone") ) { zone=inValue.Cast< int >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"gfxEnd") ) { gfxEnd=inValue.Cast<  ::hxlr::math::geom::Point >(); return inValue; }
		if (HX_FIELD_EQ(inName,"limEnd") ) { limEnd=inValue.Cast< Float >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"keyList") ) { keyList=inValue.Cast< ::Array< ::String > >(); return inValue; }
		if (HX_FIELD_EQ(inName,"shifted") ) { shifted=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"limType") ) { limType=inValue.Cast< int >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"tangible") ) { tangible=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"distance") ) { distance=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"limStart") ) { limStart=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"limValue") ) { limValue=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"prevLine") ) { prevLine=inValue.Cast<  ::hxlr::lines::LineObject >(); return inValue; }
		if (HX_FIELD_EQ(inName,"nextLine") ) { nextLine=inValue.Cast<  ::hxlr::lines::LineObject >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"invDistance") ) { invDistance=inValue.Cast< Float >(); return inValue; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"invSqrDistance") ) { invSqrDistance=inValue.Cast< Float >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void LineObject_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("id",db,5b,00,00));
	outFields->push(HX_("type",ba,f2,08,4d));
	outFields->push(HX_("tangible",78,48,b7,3b));
	outFields->push(HX_("keyList",9d,8d,8c,a1));
	outFields->push(HX_("gfxEnd",e2,ab,27,39));
	outFields->push(HX_("shifted",61,e9,18,fc));
	outFields->push(HX_("dx",94,57,00,00));
	outFields->push(HX_("dy",95,57,00,00));
	outFields->push(HX_("C",43,00,00,00));
	outFields->push(HX_("distance",35,93,f9,6b));
	outFields->push(HX_("invSqrDistance",f8,67,31,fe));
	outFields->push(HX_("invDistance",46,35,2b,fc));
	outFields->push(HX_("nx",4a,60,00,00));
	outFields->push(HX_("ny",4b,60,00,00));
	outFields->push(HX_("zone",2c,a2,f8,50));
	outFields->push(HX_("limType",2a,56,16,81));
	outFields->push(HX_("limStart",f2,12,b5,db));
	outFields->push(HX_("limEnd",6b,de,de,eb));
	outFields->push(HX_("limValue",01,1e,62,89));
	outFields->push(HX_("prevLine",87,f8,80,10));
	outFields->push(HX_("nextLine",87,be,7f,f3));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo LineObject_obj_sMemberStorageInfo[] = {
	{::hx::fsObject /*  ::Dynamic */ ,(int)offsetof(LineObject_obj,id),HX_("id",db,5b,00,00)},
	{::hx::fsInt,(int)offsetof(LineObject_obj,type),HX_("type",ba,f2,08,4d)},
	{::hx::fsBool,(int)offsetof(LineObject_obj,tangible),HX_("tangible",78,48,b7,3b)},
	{::hx::fsObject /* ::Array< ::String > */ ,(int)offsetof(LineObject_obj,keyList),HX_("keyList",9d,8d,8c,a1)},
	{::hx::fsObject /*  ::hxlr::math::geom::Point */ ,(int)offsetof(LineObject_obj,gfxEnd),HX_("gfxEnd",e2,ab,27,39)},
	{::hx::fsBool,(int)offsetof(LineObject_obj,shifted),HX_("shifted",61,e9,18,fc)},
	{::hx::fsFloat,(int)offsetof(LineObject_obj,dx),HX_("dx",94,57,00,00)},
	{::hx::fsFloat,(int)offsetof(LineObject_obj,dy),HX_("dy",95,57,00,00)},
	{::hx::fsFloat,(int)offsetof(LineObject_obj,C),HX_("C",43,00,00,00)},
	{::hx::fsFloat,(int)offsetof(LineObject_obj,distance),HX_("distance",35,93,f9,6b)},
	{::hx::fsFloat,(int)offsetof(LineObject_obj,invSqrDistance),HX_("invSqrDistance",f8,67,31,fe)},
	{::hx::fsFloat,(int)offsetof(LineObject_obj,invDistance),HX_("invDistance",46,35,2b,fc)},
	{::hx::fsFloat,(int)offsetof(LineObject_obj,nx),HX_("nx",4a,60,00,00)},
	{::hx::fsFloat,(int)offsetof(LineObject_obj,ny),HX_("ny",4b,60,00,00)},
	{::hx::fsInt,(int)offsetof(LineObject_obj,zone),HX_("zone",2c,a2,f8,50)},
	{::hx::fsInt,(int)offsetof(LineObject_obj,limType),HX_("limType",2a,56,16,81)},
	{::hx::fsFloat,(int)offsetof(LineObject_obj,limStart),HX_("limStart",f2,12,b5,db)},
	{::hx::fsFloat,(int)offsetof(LineObject_obj,limEnd),HX_("limEnd",6b,de,de,eb)},
	{::hx::fsFloat,(int)offsetof(LineObject_obj,limValue),HX_("limValue",01,1e,62,89)},
	{::hx::fsObject /*  ::hxlr::lines::LineObject */ ,(int)offsetof(LineObject_obj,prevLine),HX_("prevLine",87,f8,80,10)},
	{::hx::fsObject /*  ::hxlr::lines::LineObject */ ,(int)offsetof(LineObject_obj,nextLine),HX_("nextLine",87,be,7f,f3)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *LineObject_obj_sStaticStorageInfo = 0;
#endif

static ::String LineObject_obj_sMemberFields[] = {
	HX_("id",db,5b,00,00),
	HX_("type",ba,f2,08,4d),
	HX_("tangible",78,48,b7,3b),
	HX_("keyList",9d,8d,8c,a1),
	HX_("gfxEnd",e2,ab,27,39),
	HX_("shifted",61,e9,18,fc),
	HX_("dx",94,57,00,00),
	HX_("dy",95,57,00,00),
	HX_("C",43,00,00,00),
	HX_("distance",35,93,f9,6b),
	HX_("invSqrDistance",f8,67,31,fe),
	HX_("invDistance",46,35,2b,fc),
	HX_("nx",4a,60,00,00),
	HX_("ny",4b,60,00,00),
	HX_("zone",2c,a2,f8,50),
	HX_("limType",2a,56,16,81),
	HX_("limStart",f2,12,b5,db),
	HX_("limEnd",6b,de,de,eb),
	HX_("limValue",01,1e,62,89),
	HX_("prevLine",87,f8,80,10),
	HX_("nextLine",87,be,7f,f3),
	HX_("set_length",23,a3,0c,93),
	HX_("calculateConstants",49,e4,04,d9),
	HX_("setLim",ce,dc,69,6f),
	HX_("collide",7e,af,63,ed),
	HX_("toSaveObject",37,3b,d8,ff),
	::String(null()) };

::hx::Class LineObject_obj::__mClass;

void LineObject_obj::__register()
{
	LineObject_obj _hx_dummy;
	LineObject_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("hxlr.lines.LineObject",da,ad,22,e7);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(LineObject_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< LineObject_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = LineObject_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = LineObject_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace hxlr
} // end namespace lines
