// Generated by Haxe 4.1.5
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_hxlr_lines_LineBase
#include <hxlr/lines/LineBase.h>
#endif
#ifndef INCLUDED_hxlr_math_geom_Point
#include <hxlr/math/geom/Point.h>
#endif
#ifndef INCLUDED_hxlr_rider_ContactPoint
#include <hxlr/rider/ContactPoint.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_31d8ac93e8f3d447_11_new,"hxlr.lines.LineBase","new",0x5c91d15e,"hxlr.lines.LineBase.new","hxlr/lines/LineBase.hx",11,0x56d96050)
HX_LOCAL_STACK_FRAME(_hx_pos_31d8ac93e8f3d447_62_calculateConstants,"hxlr.lines.LineBase","calculateConstants",0x944fb10b,"hxlr.lines.LineBase.calculateConstants","hxlr/lines/LineBase.hx",62,0x56d96050)
HX_LOCAL_STACK_FRAME(_hx_pos_31d8ac93e8f3d447_76_setLim,"hxlr.lines.LineBase","setLim",0x75d00e90,"hxlr.lines.LineBase.setLim","hxlr/lines/LineBase.hx",76,0x56d96050)
HX_LOCAL_STACK_FRAME(_hx_pos_31d8ac93e8f3d447_94_collide,"hxlr.lines.LineBase","collide",0x8069077c,"hxlr.lines.LineBase.collide","hxlr/lines/LineBase.hx",94,0x56d96050)
HX_LOCAL_STACK_FRAME(_hx_pos_31d8ac93e8f3d447_98_toSaveObject,"hxlr.lines.LineBase","toSaveObject",0xf5bd2a79,"hxlr.lines.LineBase.toSaveObject","hxlr/lines/LineBase.hx",98,0x56d96050)
namespace hxlr{
namespace lines{

void LineBase_obj::__construct( ::hxlr::math::geom::Point _start, ::hxlr::math::geom::Point _end,bool _shift, ::Dynamic __o__lim){
            		 ::Dynamic _lim = __o__lim;
            		if (::hx::IsNull(__o__lim)) _lim = 0;
            	HX_GC_STACKFRAME(&_hx_pos_31d8ac93e8f3d447_11_new)
HXLINE(  40)		this->limValue = ((Float)0);
HXLINE(  39)		this->limEnd = ((Float)0);
HXLINE(  38)		this->limStart = ((Float)0);
HXLINE(  37)		this->limType = 0;
HXLINE(  35)		this->zone = 10;
HXLINE(  19)		this->tangible = false;
HXLINE(  47)		this->start = _start;
HXLINE(  48)		this->end = _end;
HXLINE(  50)		this->gfxEnd =  ::hxlr::math::geom::Point_obj::__alloc( HX_CTX ,(this->end->x - this->start->x),(this->end->y - this->start->y));
HXLINE(  52)		this->shifted = _shift;
HXLINE(  54)		this->keyList = ::Array_obj< ::String >::__new();
HXLINE(  56)		this->calculateConstants();
HXLINE(  58)		this->setLim(( (int)(_lim) ));
            	}

Dynamic LineBase_obj::__CreateEmpty() { return new LineBase_obj; }

void *LineBase_obj::_hx_vtable = 0;

Dynamic LineBase_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< LineBase_obj > _hx_result = new LineBase_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2],inArgs[3]);
	return _hx_result;
}

bool LineBase_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x041acbee;
}

void LineBase_obj::calculateConstants(){
            	HX_STACKFRAME(&_hx_pos_31d8ac93e8f3d447_62_calculateConstants)
HXLINE(  63)		this->dx = (this->end->x - this->start->x);
HXLINE(  64)		this->dy = (this->end->y - this->start->y);
HXLINE(  65)		this->C = ((this->dy * this->start->x) - (this->dx * this->start->y));
HXLINE(  66)		Float _loc2 = (::Math_obj::pow(this->dx,( (Float)(2) )) + ::Math_obj::pow(this->dy,( (Float)(2) )));
HXLINE(  67)		this->invSqrDistance = (( (Float)(1) ) / _loc2);
HXLINE(  68)		this->distance = ::Math_obj::sqrt(_loc2);
HXLINE(  69)		this->invDistance = (( (Float)(1) ) / this->distance);
HXLINE(  70)		int _hx_tmp;
HXDLIN(  70)		if (this->shifted) {
HXLINE(  70)			_hx_tmp = 1;
            		}
            		else {
HXLINE(  70)			_hx_tmp = -1;
            		}
HXDLIN(  70)		this->nx = ((this->dy * this->invDistance) * ( (Float)(_hx_tmp) ));
HXLINE(  71)		int _hx_tmp1;
HXDLIN(  71)		if (this->shifted) {
HXLINE(  71)			_hx_tmp1 = -1;
            		}
            		else {
HXLINE(  71)			_hx_tmp1 = 1;
            		}
HXDLIN(  71)		this->ny = ((this->dx * this->invDistance) * ( (Float)(_hx_tmp1) ));
HXLINE(  72)		this->limValue = ::Math_obj::min(((Float)0.25),(( (Float)(this->zone) ) / this->distance));
            	}


HX_DEFINE_DYNAMIC_FUNC0(LineBase_obj,calculateConstants,(void))

void LineBase_obj::setLim(int _limMode){
            	HX_STACKFRAME(&_hx_pos_31d8ac93e8f3d447_76_setLim)
HXLINE(  77)		switch((int)(_limMode)){
            			case (int)0: {
HXLINE(  79)				this->limStart = ( (Float)(0) );
HXLINE(  80)				this->limEnd = ( (Float)(1) );
            			}
            			break;
            			case (int)1: {
HXLINE(  82)				this->limStart = -(this->limValue);
HXLINE(  83)				this->limEnd = ( (Float)(1) );
            			}
            			break;
            			case (int)2: {
HXLINE(  85)				this->limStart = ( (Float)(0) );
HXLINE(  86)				this->limEnd = (1 + this->limValue);
            			}
            			break;
            			case (int)3: {
HXLINE(  88)				this->limStart = -(this->limValue);
HXLINE(  89)				this->limEnd = (1 + this->limValue);
            			}
            			break;
            		}
HXLINE(  91)		this->limType = _limMode;
            	}


HX_DEFINE_DYNAMIC_FUNC1(LineBase_obj,setLim,(void))

void LineBase_obj::collide( ::hxlr::rider::ContactPoint _point){
            	HX_STACKFRAME(&_hx_pos_31d8ac93e8f3d447_94_collide)
            	}


HX_DEFINE_DYNAMIC_FUNC1(LineBase_obj,collide,(void))

 ::Dynamic LineBase_obj::toSaveObject(){
            	HX_STACKFRAME(&_hx_pos_31d8ac93e8f3d447_98_toSaveObject)
HXLINE( 107)		bool save;
HXDLIN( 107)		switch((int)(this->limType)){
            			case (int)1: case (int)3: {
HXLINE( 107)				save = true;
            			}
            			break;
            			case (int)0: case (int)2: {
HXLINE( 107)				save = false;
            			}
            			break;
            			default:{
HXLINE( 107)				save = false;
            			}
            		}
HXLINE( 115)		bool save1;
HXDLIN( 115)		switch((int)(this->limType)){
            			case (int)0: case (int)1: {
HXLINE( 115)				save1 = false;
            			}
            			break;
            			case (int)2: case (int)3: {
HXLINE( 115)				save1 = true;
            			}
            			break;
            			default:{
HXLINE( 115)				save1 = false;
            			}
            		}
HXLINE(  99)		 ::Dynamic save2 =  ::Dynamic(::hx::Anon_obj::Create(9)
            			->setFixed(0,HX_("leftExtended",e0,77,1a,82),save)
            			->setFixed(1,HX_("id",db,5b,00,00),this->id)
            			->setFixed(2,HX_("x1",b9,68,00,00),this->start->x)
            			->setFixed(3,HX_("x2",ba,68,00,00),this->end->x)
            			->setFixed(4,HX_("y1",98,69,00,00),this->start->y)
            			->setFixed(5,HX_("y2",99,69,00,00),this->end->y)
            			->setFixed(6,HX_("type",ba,f2,08,4d),this->type)
            			->setFixed(7,HX_("rightExtended",b5,d8,e5,4e),save1)
            			->setFixed(8,HX_("flipped",42,6c,88,7f),this->shifted));
HXLINE( 124)		return save2;
            	}


HX_DEFINE_DYNAMIC_FUNC0(LineBase_obj,toSaveObject,return )


::hx::ObjectPtr< LineBase_obj > LineBase_obj::__new( ::hxlr::math::geom::Point _start, ::hxlr::math::geom::Point _end,bool _shift, ::Dynamic __o__lim) {
	::hx::ObjectPtr< LineBase_obj > __this = new LineBase_obj();
	__this->__construct(_start,_end,_shift,__o__lim);
	return __this;
}

::hx::ObjectPtr< LineBase_obj > LineBase_obj::__alloc(::hx::Ctx *_hx_ctx, ::hxlr::math::geom::Point _start, ::hxlr::math::geom::Point _end,bool _shift, ::Dynamic __o__lim) {
	LineBase_obj *__this = (LineBase_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(LineBase_obj), true, "hxlr.lines.LineBase"));
	*(void **)__this = LineBase_obj::_hx_vtable;
	__this->__construct(_start,_end,_shift,__o__lim);
	return __this;
}

LineBase_obj::LineBase_obj()
{
}

void LineBase_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(LineBase);
	HX_MARK_MEMBER_NAME(id,"id");
	HX_MARK_MEMBER_NAME(start,"start");
	HX_MARK_MEMBER_NAME(end,"end");
	HX_MARK_MEMBER_NAME(type,"type");
	HX_MARK_MEMBER_NAME(tangible,"tangible");
	HX_MARK_MEMBER_NAME(keyList,"keyList");
	HX_MARK_MEMBER_NAME(gfxEnd,"gfxEnd");
	HX_MARK_MEMBER_NAME(shifted,"shifted");
	HX_MARK_MEMBER_NAME(dx,"dx");
	HX_MARK_MEMBER_NAME(dy,"dy");
	HX_MARK_MEMBER_NAME(C,"C");
	HX_MARK_MEMBER_NAME(distance,"distance");
	HX_MARK_MEMBER_NAME(invSqrDistance,"invSqrDistance");
	HX_MARK_MEMBER_NAME(invDistance,"invDistance");
	HX_MARK_MEMBER_NAME(nx,"nx");
	HX_MARK_MEMBER_NAME(ny,"ny");
	HX_MARK_MEMBER_NAME(zone,"zone");
	HX_MARK_MEMBER_NAME(limType,"limType");
	HX_MARK_MEMBER_NAME(limStart,"limStart");
	HX_MARK_MEMBER_NAME(limEnd,"limEnd");
	HX_MARK_MEMBER_NAME(limValue,"limValue");
	HX_MARK_MEMBER_NAME(prevLine,"prevLine");
	HX_MARK_MEMBER_NAME(nextLine,"nextLine");
	HX_MARK_END_CLASS();
}

void LineBase_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(id,"id");
	HX_VISIT_MEMBER_NAME(start,"start");
	HX_VISIT_MEMBER_NAME(end,"end");
	HX_VISIT_MEMBER_NAME(type,"type");
	HX_VISIT_MEMBER_NAME(tangible,"tangible");
	HX_VISIT_MEMBER_NAME(keyList,"keyList");
	HX_VISIT_MEMBER_NAME(gfxEnd,"gfxEnd");
	HX_VISIT_MEMBER_NAME(shifted,"shifted");
	HX_VISIT_MEMBER_NAME(dx,"dx");
	HX_VISIT_MEMBER_NAME(dy,"dy");
	HX_VISIT_MEMBER_NAME(C,"C");
	HX_VISIT_MEMBER_NAME(distance,"distance");
	HX_VISIT_MEMBER_NAME(invSqrDistance,"invSqrDistance");
	HX_VISIT_MEMBER_NAME(invDistance,"invDistance");
	HX_VISIT_MEMBER_NAME(nx,"nx");
	HX_VISIT_MEMBER_NAME(ny,"ny");
	HX_VISIT_MEMBER_NAME(zone,"zone");
	HX_VISIT_MEMBER_NAME(limType,"limType");
	HX_VISIT_MEMBER_NAME(limStart,"limStart");
	HX_VISIT_MEMBER_NAME(limEnd,"limEnd");
	HX_VISIT_MEMBER_NAME(limValue,"limValue");
	HX_VISIT_MEMBER_NAME(prevLine,"prevLine");
	HX_VISIT_MEMBER_NAME(nextLine,"nextLine");
}

::hx::Val LineBase_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 1:
		if (HX_FIELD_EQ(inName,"C") ) { return ::hx::Val( C ); }
		break;
	case 2:
		if (HX_FIELD_EQ(inName,"id") ) { return ::hx::Val( id ); }
		if (HX_FIELD_EQ(inName,"dx") ) { return ::hx::Val( dx ); }
		if (HX_FIELD_EQ(inName,"dy") ) { return ::hx::Val( dy ); }
		if (HX_FIELD_EQ(inName,"nx") ) { return ::hx::Val( nx ); }
		if (HX_FIELD_EQ(inName,"ny") ) { return ::hx::Val( ny ); }
		break;
	case 3:
		if (HX_FIELD_EQ(inName,"end") ) { return ::hx::Val( end ); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"type") ) { return ::hx::Val( type ); }
		if (HX_FIELD_EQ(inName,"zone") ) { return ::hx::Val( zone ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"start") ) { return ::hx::Val( start ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"gfxEnd") ) { return ::hx::Val( gfxEnd ); }
		if (HX_FIELD_EQ(inName,"limEnd") ) { return ::hx::Val( limEnd ); }
		if (HX_FIELD_EQ(inName,"setLim") ) { return ::hx::Val( setLim_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"keyList") ) { return ::hx::Val( keyList ); }
		if (HX_FIELD_EQ(inName,"shifted") ) { return ::hx::Val( shifted ); }
		if (HX_FIELD_EQ(inName,"limType") ) { return ::hx::Val( limType ); }
		if (HX_FIELD_EQ(inName,"collide") ) { return ::hx::Val( collide_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"tangible") ) { return ::hx::Val( tangible ); }
		if (HX_FIELD_EQ(inName,"distance") ) { return ::hx::Val( distance ); }
		if (HX_FIELD_EQ(inName,"limStart") ) { return ::hx::Val( limStart ); }
		if (HX_FIELD_EQ(inName,"limValue") ) { return ::hx::Val( limValue ); }
		if (HX_FIELD_EQ(inName,"prevLine") ) { return ::hx::Val( prevLine ); }
		if (HX_FIELD_EQ(inName,"nextLine") ) { return ::hx::Val( nextLine ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"invDistance") ) { return ::hx::Val( invDistance ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"toSaveObject") ) { return ::hx::Val( toSaveObject_dyn() ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"invSqrDistance") ) { return ::hx::Val( invSqrDistance ); }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"calculateConstants") ) { return ::hx::Val( calculateConstants_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val LineBase_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 1:
		if (HX_FIELD_EQ(inName,"C") ) { C=inValue.Cast< Float >(); return inValue; }
		break;
	case 2:
		if (HX_FIELD_EQ(inName,"id") ) { id=inValue.Cast<  ::Dynamic >(); return inValue; }
		if (HX_FIELD_EQ(inName,"dx") ) { dx=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"dy") ) { dy=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"nx") ) { nx=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"ny") ) { ny=inValue.Cast< Float >(); return inValue; }
		break;
	case 3:
		if (HX_FIELD_EQ(inName,"end") ) { end=inValue.Cast<  ::hxlr::math::geom::Point >(); return inValue; }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"type") ) { type=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"zone") ) { zone=inValue.Cast< int >(); return inValue; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"start") ) { start=inValue.Cast<  ::hxlr::math::geom::Point >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"gfxEnd") ) { gfxEnd=inValue.Cast<  ::hxlr::math::geom::Point >(); return inValue; }
		if (HX_FIELD_EQ(inName,"limEnd") ) { limEnd=inValue.Cast< Float >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"keyList") ) { keyList=inValue.Cast< ::Array< ::String > >(); return inValue; }
		if (HX_FIELD_EQ(inName,"shifted") ) { shifted=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"limType") ) { limType=inValue.Cast< int >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"tangible") ) { tangible=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"distance") ) { distance=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"limStart") ) { limStart=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"limValue") ) { limValue=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"prevLine") ) { prevLine=inValue.Cast<  ::hxlr::lines::LineBase >(); return inValue; }
		if (HX_FIELD_EQ(inName,"nextLine") ) { nextLine=inValue.Cast<  ::hxlr::lines::LineBase >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"invDistance") ) { invDistance=inValue.Cast< Float >(); return inValue; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"invSqrDistance") ) { invSqrDistance=inValue.Cast< Float >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void LineBase_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("id",db,5b,00,00));
	outFields->push(HX_("start",62,74,0b,84));
	outFields->push(HX_("end",db,03,4d,00));
	outFields->push(HX_("type",ba,f2,08,4d));
	outFields->push(HX_("tangible",78,48,b7,3b));
	outFields->push(HX_("keyList",9d,8d,8c,a1));
	outFields->push(HX_("gfxEnd",e2,ab,27,39));
	outFields->push(HX_("shifted",61,e9,18,fc));
	outFields->push(HX_("dx",94,57,00,00));
	outFields->push(HX_("dy",95,57,00,00));
	outFields->push(HX_("C",43,00,00,00));
	outFields->push(HX_("distance",35,93,f9,6b));
	outFields->push(HX_("invSqrDistance",f8,67,31,fe));
	outFields->push(HX_("invDistance",46,35,2b,fc));
	outFields->push(HX_("nx",4a,60,00,00));
	outFields->push(HX_("ny",4b,60,00,00));
	outFields->push(HX_("zone",2c,a2,f8,50));
	outFields->push(HX_("limType",2a,56,16,81));
	outFields->push(HX_("limStart",f2,12,b5,db));
	outFields->push(HX_("limEnd",6b,de,de,eb));
	outFields->push(HX_("limValue",01,1e,62,89));
	outFields->push(HX_("prevLine",87,f8,80,10));
	outFields->push(HX_("nextLine",87,be,7f,f3));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo LineBase_obj_sMemberStorageInfo[] = {
	{::hx::fsObject /*  ::Dynamic */ ,(int)offsetof(LineBase_obj,id),HX_("id",db,5b,00,00)},
	{::hx::fsObject /*  ::hxlr::math::geom::Point */ ,(int)offsetof(LineBase_obj,start),HX_("start",62,74,0b,84)},
	{::hx::fsObject /*  ::hxlr::math::geom::Point */ ,(int)offsetof(LineBase_obj,end),HX_("end",db,03,4d,00)},
	{::hx::fsInt,(int)offsetof(LineBase_obj,type),HX_("type",ba,f2,08,4d)},
	{::hx::fsBool,(int)offsetof(LineBase_obj,tangible),HX_("tangible",78,48,b7,3b)},
	{::hx::fsObject /* ::Array< ::String > */ ,(int)offsetof(LineBase_obj,keyList),HX_("keyList",9d,8d,8c,a1)},
	{::hx::fsObject /*  ::hxlr::math::geom::Point */ ,(int)offsetof(LineBase_obj,gfxEnd),HX_("gfxEnd",e2,ab,27,39)},
	{::hx::fsBool,(int)offsetof(LineBase_obj,shifted),HX_("shifted",61,e9,18,fc)},
	{::hx::fsFloat,(int)offsetof(LineBase_obj,dx),HX_("dx",94,57,00,00)},
	{::hx::fsFloat,(int)offsetof(LineBase_obj,dy),HX_("dy",95,57,00,00)},
	{::hx::fsFloat,(int)offsetof(LineBase_obj,C),HX_("C",43,00,00,00)},
	{::hx::fsFloat,(int)offsetof(LineBase_obj,distance),HX_("distance",35,93,f9,6b)},
	{::hx::fsFloat,(int)offsetof(LineBase_obj,invSqrDistance),HX_("invSqrDistance",f8,67,31,fe)},
	{::hx::fsFloat,(int)offsetof(LineBase_obj,invDistance),HX_("invDistance",46,35,2b,fc)},
	{::hx::fsFloat,(int)offsetof(LineBase_obj,nx),HX_("nx",4a,60,00,00)},
	{::hx::fsFloat,(int)offsetof(LineBase_obj,ny),HX_("ny",4b,60,00,00)},
	{::hx::fsInt,(int)offsetof(LineBase_obj,zone),HX_("zone",2c,a2,f8,50)},
	{::hx::fsInt,(int)offsetof(LineBase_obj,limType),HX_("limType",2a,56,16,81)},
	{::hx::fsFloat,(int)offsetof(LineBase_obj,limStart),HX_("limStart",f2,12,b5,db)},
	{::hx::fsFloat,(int)offsetof(LineBase_obj,limEnd),HX_("limEnd",6b,de,de,eb)},
	{::hx::fsFloat,(int)offsetof(LineBase_obj,limValue),HX_("limValue",01,1e,62,89)},
	{::hx::fsObject /*  ::hxlr::lines::LineBase */ ,(int)offsetof(LineBase_obj,prevLine),HX_("prevLine",87,f8,80,10)},
	{::hx::fsObject /*  ::hxlr::lines::LineBase */ ,(int)offsetof(LineBase_obj,nextLine),HX_("nextLine",87,be,7f,f3)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *LineBase_obj_sStaticStorageInfo = 0;
#endif

static ::String LineBase_obj_sMemberFields[] = {
	HX_("id",db,5b,00,00),
	HX_("start",62,74,0b,84),
	HX_("end",db,03,4d,00),
	HX_("type",ba,f2,08,4d),
	HX_("tangible",78,48,b7,3b),
	HX_("keyList",9d,8d,8c,a1),
	HX_("gfxEnd",e2,ab,27,39),
	HX_("shifted",61,e9,18,fc),
	HX_("dx",94,57,00,00),
	HX_("dy",95,57,00,00),
	HX_("C",43,00,00,00),
	HX_("distance",35,93,f9,6b),
	HX_("invSqrDistance",f8,67,31,fe),
	HX_("invDistance",46,35,2b,fc),
	HX_("nx",4a,60,00,00),
	HX_("ny",4b,60,00,00),
	HX_("zone",2c,a2,f8,50),
	HX_("limType",2a,56,16,81),
	HX_("limStart",f2,12,b5,db),
	HX_("limEnd",6b,de,de,eb),
	HX_("limValue",01,1e,62,89),
	HX_("prevLine",87,f8,80,10),
	HX_("nextLine",87,be,7f,f3),
	HX_("calculateConstants",49,e4,04,d9),
	HX_("setLim",ce,dc,69,6f),
	HX_("collide",7e,af,63,ed),
	HX_("toSaveObject",37,3b,d8,ff),
	::String(null()) };

::hx::Class LineBase_obj::__mClass;

void LineBase_obj::__register()
{
	LineBase_obj _hx_dummy;
	LineBase_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("hxlr.lines.LineBase",6c,8a,82,d9);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(LineBase_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< LineBase_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = LineBase_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = LineBase_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace hxlr
} // end namespace lines
