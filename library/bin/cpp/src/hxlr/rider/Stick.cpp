// Generated by Haxe 4.1.5
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_hxlr_math_geom_Point
#include <hxlr/math/geom/Point.h>
#endif
#ifndef INCLUDED_hxlr_rider_ContactPoint
#include <hxlr/rider/ContactPoint.h>
#endif
#ifndef INCLUDED_hxlr_rider_RiderBase
#include <hxlr/rider/RiderBase.h>
#endif
#ifndef INCLUDED_hxlr_rider_Stick
#include <hxlr/rider/Stick.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_2e8263ff47c06753_13_new,"hxlr.rider.Stick","new",0xd30fd856,"hxlr.rider.Stick.new","hxlr/rider/Stick.hx",13,0xcde50c9c)
HX_LOCAL_STACK_FRAME(_hx_pos_2e8263ff47c06753_46_satisfy,"hxlr.rider.Stick","satisfy",0xda5ae1d9,"hxlr.rider.Stick.satisfy","hxlr/rider/Stick.hx",46,0xcde50c9c)
HX_LOCAL_STACK_FRAME(_hx_pos_2e8263ff47c06753_62_noConstrain,"hxlr.rider.Stick","noConstrain",0xede30dac,"hxlr.rider.Stick.noConstrain","hxlr/rider/Stick.hx",62,0xcde50c9c)
HX_LOCAL_STACK_FRAME(_hx_pos_2e8263ff47c06753_66_standard,"hxlr.rider.Stick","standard",0x898d9387,"hxlr.rider.Stick.standard","hxlr/rider/Stick.hx",66,0xcde50c9c)
HX_LOCAL_STACK_FRAME(_hx_pos_2e8263ff47c06753_94_repell,"hxlr.rider.Stick","repell",0xd45976b2,"hxlr.rider.Stick.repell","hxlr/rider/Stick.hx",94,0xcde50c9c)
HX_LOCAL_STACK_FRAME(_hx_pos_2e8263ff47c06753_124_attract,"hxlr.rider.Stick","attract",0x8c85a3b7,"hxlr.rider.Stick.attract","hxlr/rider/Stick.hx",124,0xcde50c9c)
HX_LOCAL_STACK_FRAME(_hx_pos_2e8263ff47c06753_156_scarf,"hxlr.rider.Stick","scarf",0x7895453b,"hxlr.rider.Stick.scarf","hxlr/rider/Stick.hx",156,0xcde50c9c)
HX_LOCAL_STACK_FRAME(_hx_pos_2e8263ff47c06753_175_set_type,"hxlr.rider.Stick","set_type",0x1a366401,"hxlr.rider.Stick.set_type","hxlr/rider/Stick.hx",175,0xcde50c9c)
HX_LOCAL_STACK_FRAME(_hx_pos_2e8263ff47c06753_204_setRestLength,"hxlr.rider.Stick","setRestLength",0xd94500d2,"hxlr.rider.Stick.setRestLength","hxlr/rider/Stick.hx",204,0xcde50c9c)
namespace hxlr{
namespace rider{

void Stick_obj::__construct( ::hxlr::rider::ContactPoint _a, ::hxlr::rider::ContactPoint _b,::String _type, ::hxlr::rider::RiderBase _rider){
            	HX_STACKFRAME(&_hx_pos_2e8263ff47c06753_13_new)
HXLINE(  22)		this->crashable = false;
HXLINE(  21)		this->broken = false;
HXLINE(  20)		this->breakable = false;
HXLINE(  19)		this->enabled = true;
HXLINE(  34)		this->a = _a;
HXLINE(  35)		this->b = _b;
HXLINE(  37)		this->set_type(_type);
HXLINE(  39)		this->rider = _rider;
HXLINE(  41)		this->endurance = ((((Float)0.057) * this->restLength) * ((Float)0.5));
            	}

Dynamic Stick_obj::__CreateEmpty() { return new Stick_obj; }

void *Stick_obj::_hx_vtable = 0;

Dynamic Stick_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< Stick_obj > _hx_result = new Stick_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2],inArgs[3]);
	return _hx_result;
}

bool Stick_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x20facccc;
}

void Stick_obj::satisfy( ::Dynamic _crashed){
            	HX_STACKFRAME(&_hx_pos_2e8263ff47c06753_46_satisfy)
HXLINE(  47)		if (!(this->enabled)) {
HXLINE(  47)			return;
            		}
HXLINE(  49)		bool result = ( (bool)(this->constrain(_crashed)) );
HXLINE(  51)		if (this->breakable) {
HXLINE(  52)			this->broken = result;
            		}
HXLINE(  55)		if (this->crashable) {
HXLINE(  56)			this->rider->set_crashed(result);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(Stick_obj,satisfy,(void))

bool Stick_obj::noConstrain( ::Dynamic _crashed){
            	HX_STACKFRAME(&_hx_pos_2e8263ff47c06753_62_noConstrain)
HXDLIN(  62)		return ( (bool)(_crashed) );
            	}


HX_DEFINE_DYNAMIC_FUNC1(Stick_obj,noConstrain,return )

bool Stick_obj::standard( ::Dynamic _crashed){
            	HX_STACKFRAME(&_hx_pos_2e8263ff47c06753_66_standard)
HXLINE(  67)		Float xDist = (this->a->pos->x - this->b->pos->x);
HXLINE(  68)		Float yDist = (this->a->pos->y - this->b->pos->y);
HXLINE(  69)		Float dist = ::Math_obj::sqrt(((xDist * xDist) + (yDist * yDist)));
HXLINE(  71)		Float adjust = ( (Float)(0) );
HXLINE(  72)		if ((dist != 0)) {
HXLINE(  72)			adjust = (((dist - this->restLength) / dist) * ((Float)0.5));
            		}
HXLINE(  74)		bool _hx_tmp;
HXDLIN(  74)		if (!(this->crashable)) {
HXLINE(  74)			_hx_tmp = this->breakable;
            		}
            		else {
HXLINE(  74)			_hx_tmp = true;
            		}
HXDLIN(  74)		if (_hx_tmp) {
HXLINE(  75)			if (!(this->rider->invincible)) {
HXLINE(  76)				bool _hx_tmp;
HXDLIN(  76)				bool _hx_tmp1;
HXDLIN(  76)				if (!((adjust > this->endurance))) {
HXLINE(  76)					_hx_tmp1 = ( (bool)(_crashed) );
            				}
            				else {
HXLINE(  76)					_hx_tmp1 = true;
            				}
HXDLIN(  76)				if (!(_hx_tmp1)) {
HXLINE(  76)					_hx_tmp = this->broken;
            				}
            				else {
HXLINE(  76)					_hx_tmp = true;
            				}
HXDLIN(  76)				if (_hx_tmp) {
HXLINE(  77)					return true;
            				}
            			}
            		}
HXLINE(  82)		Float xAdjust = (xDist * adjust);
HXLINE(  83)		Float yAdjust = (yDist * adjust);
HXLINE(  85)		this->a->pos->x = (this->a->pos->x - xAdjust);
HXLINE(  86)		this->a->pos->y = (this->a->pos->y - yAdjust);
HXLINE(  87)		this->b->pos->x = (this->b->pos->x + xAdjust);
HXLINE(  88)		this->b->pos->y = (this->b->pos->y + yAdjust);
HXLINE(  90)		return ( (bool)(_crashed) );
            	}


HX_DEFINE_DYNAMIC_FUNC1(Stick_obj,standard,return )

bool Stick_obj::repell( ::Dynamic _crashed){
            	HX_STACKFRAME(&_hx_pos_2e8263ff47c06753_94_repell)
HXLINE(  95)		Float xDist = (this->a->pos->x - this->b->pos->x);
HXLINE(  96)		Float yDist = (this->a->pos->y - this->b->pos->y);
HXLINE(  97)		Float dist = ::Math_obj::sqrt(((xDist * xDist) + (yDist * yDist)));
HXLINE(  99)		if ((dist < this->restLength)) {
HXLINE( 101)			Float adjust = ( (Float)(0) );
HXLINE( 102)			if ((dist != 0)) {
HXLINE( 102)				adjust = (((dist - this->restLength) / dist) * ((Float)0.5));
            			}
HXLINE( 104)			bool _hx_tmp;
HXDLIN( 104)			if (!(this->crashable)) {
HXLINE( 104)				_hx_tmp = this->breakable;
            			}
            			else {
HXLINE( 104)				_hx_tmp = true;
            			}
HXDLIN( 104)			if (_hx_tmp) {
HXLINE( 105)				if (!(this->rider->invincible)) {
HXLINE( 106)					bool _hx_tmp;
HXDLIN( 106)					bool _hx_tmp1;
HXDLIN( 106)					if (!((adjust > this->endurance))) {
HXLINE( 106)						_hx_tmp1 = ( (bool)(_crashed) );
            					}
            					else {
HXLINE( 106)						_hx_tmp1 = true;
            					}
HXDLIN( 106)					if (!(_hx_tmp1)) {
HXLINE( 106)						_hx_tmp = this->broken;
            					}
            					else {
HXLINE( 106)						_hx_tmp = true;
            					}
HXDLIN( 106)					if (_hx_tmp) {
HXLINE( 107)						return true;
            					}
            				}
            			}
HXLINE( 112)			Float xAdjust = (xDist * adjust);
HXLINE( 113)			Float yAdjust = (yDist * adjust);
HXLINE( 115)			this->a->pos->x = (this->a->pos->x - xAdjust);
HXLINE( 116)			this->a->pos->y = (this->a->pos->y - yAdjust);
HXLINE( 117)			this->b->pos->x = (this->b->pos->x + xAdjust);
HXLINE( 118)			this->b->pos->y = (this->b->pos->y + yAdjust);
            		}
HXLINE( 121)		return ( (bool)(_crashed) );
            	}


HX_DEFINE_DYNAMIC_FUNC1(Stick_obj,repell,return )

bool Stick_obj::attract( ::Dynamic _crashed){
            	HX_STACKFRAME(&_hx_pos_2e8263ff47c06753_124_attract)
HXLINE( 126)		Float xDist = (this->a->pos->x - this->b->pos->x);
HXLINE( 127)		Float yDist = (this->a->pos->y - this->b->pos->y);
HXLINE( 128)		Float dist = ::Math_obj::sqrt(((xDist * xDist) + (yDist * yDist)));
HXLINE( 130)		if ((dist > this->restLength)) {
HXLINE( 132)			Float adjust = ( (Float)(0) );
HXLINE( 133)			if ((dist != 0)) {
HXLINE( 133)				adjust = (((dist - this->restLength) / dist) * ((Float)0.5));
            			}
HXLINE( 135)			bool _hx_tmp;
HXDLIN( 135)			if (!(this->crashable)) {
HXLINE( 135)				_hx_tmp = this->breakable;
            			}
            			else {
HXLINE( 135)				_hx_tmp = true;
            			}
HXDLIN( 135)			if (_hx_tmp) {
HXLINE( 136)				if (!(this->rider->invincible)) {
HXLINE( 137)					bool _hx_tmp;
HXDLIN( 137)					bool _hx_tmp1;
HXDLIN( 137)					if (!((adjust > this->endurance))) {
HXLINE( 137)						_hx_tmp1 = ( (bool)(_crashed) );
            					}
            					else {
HXLINE( 137)						_hx_tmp1 = true;
            					}
HXDLIN( 137)					if (!(_hx_tmp1)) {
HXLINE( 137)						_hx_tmp = this->broken;
            					}
            					else {
HXLINE( 137)						_hx_tmp = true;
            					}
HXDLIN( 137)					if (_hx_tmp) {
HXLINE( 138)						return true;
            					}
            				}
            			}
HXLINE( 143)			Float xAdjust = (xDist * adjust);
HXLINE( 144)			Float yAdjust = (yDist * adjust);
HXLINE( 146)			this->a->pos->x = (this->a->pos->x - xAdjust);
HXLINE( 147)			this->a->pos->y = (this->a->pos->y - yAdjust);
HXLINE( 148)			this->b->pos->x = (this->b->pos->x + xAdjust);
HXLINE( 149)			this->b->pos->y = (this->b->pos->y + yAdjust);
            		}
HXLINE( 152)		return ( (bool)(_crashed) );
            	}


HX_DEFINE_DYNAMIC_FUNC1(Stick_obj,attract,return )

bool Stick_obj::scarf( ::Dynamic _crashed){
            	HX_STACKFRAME(&_hx_pos_2e8263ff47c06753_156_scarf)
HXLINE( 157)		Float xDist = (this->a->pos->x - this->b->pos->x);
HXLINE( 158)		Float yDist = (this->a->pos->y - this->b->pos->y);
HXLINE( 159)		Float dist = ::Math_obj::sqrt(((xDist * xDist) + (yDist * yDist)));
HXLINE( 161)		 ::Dynamic adjust = null();
HXLINE( 162)		if ((dist == 0)) {
HXLINE( 162)			adjust = 0;
            		}
            		else {
HXLINE( 163)			adjust = (((dist - this->restLength) / dist) * ((Float)0.5));
            		}
HXLINE( 165)		Float xAdjust = (xDist * ( (Float)(adjust) ));
HXLINE( 166)		Float yAdjust = (yDist * ( (Float)(adjust) ));
HXLINE( 168)		this->b->pos->x = (this->b->pos->x + xAdjust);
HXLINE( 169)		this->b->pos->y = (this->b->pos->y + yAdjust);
HXLINE( 171)		return ( (bool)(_crashed) );
            	}


HX_DEFINE_DYNAMIC_FUNC1(Stick_obj,scarf,return )

::String Stick_obj::set_type(::String value){
            	HX_STACKFRAME(&_hx_pos_2e8263ff47c06753_175_set_type)
HXLINE( 177)		this->setRestLength();
HXLINE( 179)		bool _hx_tmp;
HXDLIN( 179)		if ((value != HX_("REPELL",e8,4c,ff,b8))) {
HXLINE( 179)			_hx_tmp = (value == HX_("ATTRACT",a1,3c,fb,b8));
            		}
            		else {
HXLINE( 179)			_hx_tmp = true;
            		}
HXDLIN( 179)		if (_hx_tmp) {
HXLINE( 179)			 ::hxlr::rider::Stick _hx_tmp = ::hx::ObjectPtr<OBJ_>(this);
HXDLIN( 179)			_hx_tmp->restLength = (_hx_tmp->restLength * ((Float)0.5));
            		}
HXLINE( 181)		::String _hx_switch_0 = value;
            		if (  (_hx_switch_0==HX_("REPELL",e8,4c,ff,b8)) ){
HXLINE( 189)			this->constrain = this->repell_dyn();
HXDLIN( 189)			goto _hx_goto_7;
            		}
            		if (  (_hx_switch_0==HX_("SCARF",a5,0b,bd,f6)) ){
HXLINE( 193)			this->constrain = this->scarf_dyn();
HXDLIN( 193)			goto _hx_goto_7;
            		}
            		if (  (_hx_switch_0==HX_("STANDARD",3d,c7,fd,43)) ){
HXLINE( 185)			this->constrain = this->standard_dyn();
HXDLIN( 185)			goto _hx_goto_7;
            		}
            		/* default */{
HXLINE( 197)			this->constrain = this->noConstrain_dyn();
            		}
            		_hx_goto_7:;
HXLINE( 200)		return (this->type = value);
            	}


HX_DEFINE_DYNAMIC_FUNC1(Stick_obj,set_type,return )

void Stick_obj::setRestLength(){
            	HX_STACKFRAME(&_hx_pos_2e8263ff47c06753_204_setRestLength)
HXLINE( 205)		Float x = (this->a->pos->x - this->b->pos->x);
HXLINE( 206)		Float y = (this->a->pos->y - this->b->pos->y);
HXLINE( 207)		this->restLength = ::Math_obj::sqrt(((x * x) + (y * y)));
            	}


HX_DEFINE_DYNAMIC_FUNC0(Stick_obj,setRestLength,(void))


::hx::ObjectPtr< Stick_obj > Stick_obj::__new( ::hxlr::rider::ContactPoint _a, ::hxlr::rider::ContactPoint _b,::String _type, ::hxlr::rider::RiderBase _rider) {
	::hx::ObjectPtr< Stick_obj > __this = new Stick_obj();
	__this->__construct(_a,_b,_type,_rider);
	return __this;
}

::hx::ObjectPtr< Stick_obj > Stick_obj::__alloc(::hx::Ctx *_hx_ctx, ::hxlr::rider::ContactPoint _a, ::hxlr::rider::ContactPoint _b,::String _type, ::hxlr::rider::RiderBase _rider) {
	Stick_obj *__this = (Stick_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(Stick_obj), true, "hxlr.rider.Stick"));
	*(void **)__this = Stick_obj::_hx_vtable;
	__this->__construct(_a,_b,_type,_rider);
	return __this;
}

Stick_obj::Stick_obj()
{
}

void Stick_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Stick);
	HX_MARK_MEMBER_NAME(a,"a");
	HX_MARK_MEMBER_NAME(b,"b");
	HX_MARK_MEMBER_NAME(restLength,"restLength");
	HX_MARK_MEMBER_NAME(enabled,"enabled");
	HX_MARK_MEMBER_NAME(breakable,"breakable");
	HX_MARK_MEMBER_NAME(broken,"broken");
	HX_MARK_MEMBER_NAME(crashable,"crashable");
	HX_MARK_MEMBER_NAME(endurance,"endurance");
	HX_MARK_MEMBER_NAME(constrain,"constrain");
	HX_MARK_MEMBER_NAME(type,"type");
	HX_MARK_MEMBER_NAME(rider,"rider");
	HX_MARK_END_CLASS();
}

void Stick_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(a,"a");
	HX_VISIT_MEMBER_NAME(b,"b");
	HX_VISIT_MEMBER_NAME(restLength,"restLength");
	HX_VISIT_MEMBER_NAME(enabled,"enabled");
	HX_VISIT_MEMBER_NAME(breakable,"breakable");
	HX_VISIT_MEMBER_NAME(broken,"broken");
	HX_VISIT_MEMBER_NAME(crashable,"crashable");
	HX_VISIT_MEMBER_NAME(endurance,"endurance");
	HX_VISIT_MEMBER_NAME(constrain,"constrain");
	HX_VISIT_MEMBER_NAME(type,"type");
	HX_VISIT_MEMBER_NAME(rider,"rider");
}

::hx::Val Stick_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 1:
		if (HX_FIELD_EQ(inName,"a") ) { return ::hx::Val( a ); }
		if (HX_FIELD_EQ(inName,"b") ) { return ::hx::Val( b ); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"type") ) { return ::hx::Val( type ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"rider") ) { return ::hx::Val( rider ); }
		if (HX_FIELD_EQ(inName,"scarf") ) { return ::hx::Val( scarf_dyn() ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"broken") ) { return ::hx::Val( broken ); }
		if (HX_FIELD_EQ(inName,"repell") ) { return ::hx::Val( repell_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"enabled") ) { return ::hx::Val( enabled ); }
		if (HX_FIELD_EQ(inName,"satisfy") ) { return ::hx::Val( satisfy_dyn() ); }
		if (HX_FIELD_EQ(inName,"attract") ) { return ::hx::Val( attract_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"standard") ) { return ::hx::Val( standard_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_type") ) { return ::hx::Val( set_type_dyn() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"breakable") ) { return ::hx::Val( breakable ); }
		if (HX_FIELD_EQ(inName,"crashable") ) { return ::hx::Val( crashable ); }
		if (HX_FIELD_EQ(inName,"endurance") ) { return ::hx::Val( endurance ); }
		if (HX_FIELD_EQ(inName,"constrain") ) { return ::hx::Val( constrain ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"restLength") ) { return ::hx::Val( restLength ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"noConstrain") ) { return ::hx::Val( noConstrain_dyn() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"setRestLength") ) { return ::hx::Val( setRestLength_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val Stick_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 1:
		if (HX_FIELD_EQ(inName,"a") ) { a=inValue.Cast<  ::hxlr::rider::ContactPoint >(); return inValue; }
		if (HX_FIELD_EQ(inName,"b") ) { b=inValue.Cast<  ::hxlr::rider::ContactPoint >(); return inValue; }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"type") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_type(inValue.Cast< ::String >()) );type=inValue.Cast< ::String >(); return inValue; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"rider") ) { rider=inValue.Cast<  ::hxlr::rider::RiderBase >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"broken") ) { broken=inValue.Cast< bool >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"enabled") ) { enabled=inValue.Cast< bool >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"breakable") ) { breakable=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"crashable") ) { crashable=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"endurance") ) { endurance=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"constrain") ) { constrain=inValue.Cast<  ::Dynamic >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"restLength") ) { restLength=inValue.Cast< Float >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void Stick_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("a",61,00,00,00));
	outFields->push(HX_("b",62,00,00,00));
	outFields->push(HX_("restLength",1a,eb,66,37));
	outFields->push(HX_("enabled",81,04,31,7e));
	outFields->push(HX_("breakable",d9,5d,bf,45));
	outFields->push(HX_("broken",55,b6,57,1c));
	outFields->push(HX_("crashable",01,ad,93,ea));
	outFields->push(HX_("endurance",c7,b3,2e,b7));
	outFields->push(HX_("type",ba,f2,08,4d));
	outFields->push(HX_("rider",7a,c2,61,e9));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo Stick_obj_sMemberStorageInfo[] = {
	{::hx::fsObject /*  ::hxlr::rider::ContactPoint */ ,(int)offsetof(Stick_obj,a),HX_("a",61,00,00,00)},
	{::hx::fsObject /*  ::hxlr::rider::ContactPoint */ ,(int)offsetof(Stick_obj,b),HX_("b",62,00,00,00)},
	{::hx::fsFloat,(int)offsetof(Stick_obj,restLength),HX_("restLength",1a,eb,66,37)},
	{::hx::fsBool,(int)offsetof(Stick_obj,enabled),HX_("enabled",81,04,31,7e)},
	{::hx::fsBool,(int)offsetof(Stick_obj,breakable),HX_("breakable",d9,5d,bf,45)},
	{::hx::fsBool,(int)offsetof(Stick_obj,broken),HX_("broken",55,b6,57,1c)},
	{::hx::fsBool,(int)offsetof(Stick_obj,crashable),HX_("crashable",01,ad,93,ea)},
	{::hx::fsFloat,(int)offsetof(Stick_obj,endurance),HX_("endurance",c7,b3,2e,b7)},
	{::hx::fsObject /*  ::Dynamic */ ,(int)offsetof(Stick_obj,constrain),HX_("constrain",37,30,9e,4f)},
	{::hx::fsString,(int)offsetof(Stick_obj,type),HX_("type",ba,f2,08,4d)},
	{::hx::fsObject /*  ::hxlr::rider::RiderBase */ ,(int)offsetof(Stick_obj,rider),HX_("rider",7a,c2,61,e9)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *Stick_obj_sStaticStorageInfo = 0;
#endif

static ::String Stick_obj_sMemberFields[] = {
	HX_("a",61,00,00,00),
	HX_("b",62,00,00,00),
	HX_("restLength",1a,eb,66,37),
	HX_("enabled",81,04,31,7e),
	HX_("breakable",d9,5d,bf,45),
	HX_("broken",55,b6,57,1c),
	HX_("crashable",01,ad,93,ea),
	HX_("endurance",c7,b3,2e,b7),
	HX_("constrain",37,30,9e,4f),
	HX_("type",ba,f2,08,4d),
	HX_("rider",7a,c2,61,e9),
	HX_("satisfy",e3,a6,fc,86),
	HX_("noConstrain",b6,1f,4d,b1),
	HX_("standard",3d,37,78,ea),
	HX_("repell",e8,a0,7c,06),
	HX_("attract",c1,68,27,39),
	HX_("scarf",c5,d3,ce,78),
	HX_("set_type",b7,07,21,7b),
	HX_("setRestLength",5c,29,df,d8),
	::String(null()) };

::hx::Class Stick_obj::__mClass;

void Stick_obj::__register()
{
	Stick_obj _hx_dummy;
	Stick_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("hxlr.rider.Stick",64,b5,c3,fb);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(Stick_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< Stick_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Stick_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Stick_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace hxlr
} // end namespace rider
