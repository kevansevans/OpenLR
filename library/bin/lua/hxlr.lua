-- Generated by Haxe 4.1.5
local _hx_hidden = {__id__=true, hx__closures=true, super=true, prototype=true, __fields__=true, __ifields__=true, __class__=true, __properties__=true, __fields__=true, __name__=true}

_hx_array_mt = {
    __newindex = function(t,k,v)
        local len = t.length
        t.length =  k >= len and (k + 1) or len
        rawset(t,k,v)
    end
}

function _hx_is_array(o)
    return type(o) == "table"
        and o.__enum__ == nil
        and getmetatable(o) == _hx_array_mt
end



function _hx_tab_array(tab, length)
    tab.length = length
    return setmetatable(tab, _hx_array_mt)
end



function _hx_print_class(obj, depth)
    local first = true
    local result = ''
    for k,v in pairs(obj) do
        if _hx_hidden[k] == nil then
            if first then
                first = false
            else
                result = result .. ', '
            end
            if _hx_hidden[k] == nil then
                result = result .. k .. ':' .. _hx_tostring(v, depth+1)
            end
        end
    end
    return '{ ' .. result .. ' }'
end

function _hx_print_enum(o, depth)
    if o.length == 2 then
        return o[0]
    else
        local str = o[0] .. "("
        for i = 2, (o.length-1) do
            if i ~= 2 then
                str = str .. "," .. _hx_tostring(o[i], depth+1)
            else
                str = str .. _hx_tostring(o[i], depth+1)
            end
        end
        return str .. ")"
    end
end

function _hx_tostring(obj, depth)
    if depth == nil then
        depth = 0
    elseif depth > 5 then
        return "<...>"
    end

    local tstr = _G.type(obj)
    if tstr == "string" then return obj
    elseif tstr == "nil" then return "null"
    elseif tstr == "number" then
        if obj == _G.math.POSITIVE_INFINITY then return "Infinity"
        elseif obj == _G.math.NEGATIVE_INFINITY then return "-Infinity"
        elseif obj == 0 then return "0"
        elseif obj ~= obj then return "NaN"
        else return _G.tostring(obj)
        end
    elseif tstr == "boolean" then return _G.tostring(obj)
    elseif tstr == "userdata" then
        local mt = _G.getmetatable(obj)
        if mt ~= nil and mt.__tostring ~= nil then
            return _G.tostring(obj)
        else
            return "<userdata>"
        end
    elseif tstr == "function" then return "<function>"
    elseif tstr == "thread" then return "<thread>"
    elseif tstr == "table" then
        if obj.__enum__ ~= nil then
            return _hx_print_enum(obj, depth)
        elseif obj.toString ~= nil and not _hx_is_array(obj) then return obj:toString()
        elseif _hx_is_array(obj) then
            if obj.length > 5 then
                return "[...]"
            else
                str = ""
                for i=0, (obj.length-1) do
                    if i == 0 then
                        str = str .. _hx_tostring(obj[i], depth+1)
                    else
                        str = str .. "," .. _hx_tostring(obj[i], depth+1)
                    end
                end
                return "[" .. str .. "]"
            end
        elseif obj.__class__ ~= nil then
            return _hx_print_class(obj, depth)
        else
            first = true
            buffer = {}
            for k,v in pairs(obj) do
                if _hx_hidden[k] == nil then
                    _G.table.insert(buffer, _hx_tostring(k, depth+1) .. ' : ' .. _hx_tostring(obj[k], depth+1))
                end
            end
            return "{ " .. table.concat(buffer, ", ") .. " }"
        end
    else
        _G.error("Unknown Lua type", 0)
        return ""
    end
end

function _hx_error(obj)
    print(obj)
    if obj.value then
        _G.print("Runtime Error: " .. _hx_tostring(obj.value));
    else
        _G.print("Runtime Error: " .. tostring(obj));
    end

    if _G.debug and _G.debug.traceback then
        _G.print(debug.traceback());
    end
end


local function _hx_obj_newindex(t,k,v)
    t.__fields__[k] = true
    rawset(t,k,v)
end

local _hx_obj_mt = {__newindex=_hx_obj_newindex, __tostring=_hx_tostring}

local function _hx_a(...)
  local __fields__ = {};
  local ret = {__fields__ = __fields__};
  local max = select('#',...);
  local tab = {...};
  local cur = 1;
  while cur < max do
    local v = tab[cur];
    __fields__[v] = true;
    ret[v] = tab[cur+1];
    cur = cur + 2
  end
  return setmetatable(ret, _hx_obj_mt)
end

local function _hx_e()
  return setmetatable({__fields__ = {}}, _hx_obj_mt)
end

local function _hx_o(obj)
  return setmetatable(obj, _hx_obj_mt)
end

local function _hx_new(prototype)
  return setmetatable({__fields__ = {}}, {__newindex=_hx_obj_newindex, __index=prototype, __tostring=_hx_tostring})
end

function _hx_field_arr(obj)
    res = {}
    idx = 0
    if obj.__fields__ ~= nil then
        obj = obj.__fields__
    end
    for k,v in pairs(obj) do
        if _hx_hidden[k] == nil then
            res[idx] = k
            idx = idx + 1
        end
    end
    return _hx_tab_array(res, idx)
end

local _hxClasses = {}
local Int = _hx_e();
local Dynamic = _hx_e();
local Float = _hx_e();
local Bool = _hx_e();
local Class = _hx_e();
local Enum = _hx_e();

local Array = _hx_e()
local Date = _hx_e()
local Lambda = _hx_e()
local Math = _hx_e()
local Reflect = _hx_e()
local String = _hx_e()
local Std = _hx_e()
local StringBuf = _hx_e()
local StringTools = _hx_e()
local ValueType = _hx_e()
local Type = _hx_e()
__haxe_IMap = _hx_e()
__haxe_Exception = _hx_e()
__haxe_Json = _hx_e()
__haxe_Log = _hx_e()
__haxe_NativeStackTrace = _hx_e()
__haxe_ValueException = _hx_e()
__haxe_ds_StringMap = _hx_e()
__haxe_format_JsonPrinter = _hx_e()
__haxe_io_Bytes = _hx_e()
__haxe_io_Encoding = _hx_e()
__haxe_io_Error = _hx_e()
__haxe_iterators_ArrayIterator = _hx_e()
__haxe_iterators_ArrayKeyValueIterator = _hx_e()
__hxlr_Constants = _hx_e()
__hxlr_engine_Cell = _hx_e()
__hxlr_engine_Grid = _hx_e()
__hxlr_export_JSONFile = _hx_e()
__hxlr_file_AMF0Reader = _hx_e()
__hxlr_lines_LineBase = _hx_e()
__hxlr_lines_Accel = _hx_e()
__hxlr_lines_Floor = _hx_e()
__hxlr_lines_Scenery = _hx_e()
__hxlr_lines_Undefined = _hx_e()
__hxlr_math_geom_Line = _hx_e()
__hxlr_math_geom_Point = _hx_e()
__hxlr_rider_ContactPoint = _hx_e()
__hxlr_rider_AirPoint = _hx_e()
__hxlr_rider_RiderBase = _hx_e()
__hxlr_rider_Stick = _hx_e()
__lua_Boot = _hx_e()
__lua_UserData = _hx_e()
__lua_Thread = _hx_e()

local _hx_bind, _hx_bit, _hx_staticToInstance, _hx_funcToField, _hx_maxn, _hx_print, _hx_apply_self, _hx_box_mr, _hx_bit_clamp, _hx_table, _hx_bit_raw
local _hx_pcall_default = {};
local _hx_pcall_break = {};

Array.new = function() 
  local self = _hx_new(Array.prototype)
  Array.super(self)
  return self
end
Array.super = function(self) 
  _hx_tab_array(self, 0);
end
Array.__name__ = true
Array.prototype = _hx_e();
Array.prototype.length= nil;
Array.prototype.concat = function(self,a) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = self;
  while (_g1 < _g2.length) do 
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    _g:push(i);
  end;
  local ret = _g;
  local _g = 0;
  while (_g < a.length) do 
    local i = a[_g];
    _g = _g + 1;
    ret:push(i);
  end;
  do return ret end
end
Array.prototype.join = function(self,sep) 
  local tbl = ({});
  local _g_current = 0;
  local _g_array = self;
  while (_g_current < _g_array.length) do 
    _g_current = _g_current + 1;
    local i = _g_array[_g_current - 1];
    _G.table.insert(tbl, Std.string(i));
  end;
  do return _G.table.concat(tbl, sep) end
end
Array.prototype.pop = function(self) 
  if (self.length == 0) then 
    do return nil end;
  end;
  local ret = self[self.length - 1];
  self[self.length - 1] = nil;
  self.length = self.length - 1;
  do return ret end
end
Array.prototype.push = function(self,x) 
  self[self.length] = x;
  do return self.length end
end
Array.prototype.reverse = function(self) 
  local tmp;
  local i = 0;
  while (i < Std.int(self.length / 2)) do 
    tmp = self[i];
    self[i] = self[(self.length - i) - 1];
    self[(self.length - i) - 1] = tmp;
    i = i + 1;
  end;
end
Array.prototype.shift = function(self) 
  if (self.length == 0) then 
    do return nil end;
  end;
  local ret = self[0];
  if (self.length == 1) then 
    self[0] = nil;
  else
    if (self.length > 1) then 
      self[0] = self[1];
      _G.table.remove(self, 1);
    end;
  end;
  local tmp = self;
  tmp.length = tmp.length - 1;
  do return ret end
end
Array.prototype.slice = function(self,pos,_end) 
  if ((_end == nil) or (_end > self.length)) then 
    _end = self.length;
  else
    if (_end < 0) then 
      _end = _G.math.fmod((self.length - (_G.math.fmod(-_end, self.length))), self.length);
    end;
  end;
  if (pos < 0) then 
    pos = _G.math.fmod((self.length - (_G.math.fmod(-pos, self.length))), self.length);
  end;
  if ((pos > _end) or (pos > self.length)) then 
    do return _hx_tab_array({}, 0) end;
  end;
  local ret = _hx_tab_array({}, 0);
  local _g = pos;
  local _g1 = _end;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    ret:push(self[i]);
  end;
  do return ret end
end
Array.prototype.sort = function(self,f) 
  local i = 0;
  local l = self.length;
  while (i < l) do 
    local swap = false;
    local j = 0;
    local max = (l - i) - 1;
    while (j < max) do 
      if (f(self[j], self[j + 1]) > 0) then 
        local tmp = self[j + 1];
        self[j + 1] = self[j];
        self[j] = tmp;
        swap = true;
      end;
      j = j + 1;
    end;
    if (not swap) then 
      break;
    end;
    i = i + 1;
  end;
end
Array.prototype.splice = function(self,pos,len) 
  if ((len < 0) or (pos > self.length)) then 
    do return _hx_tab_array({}, 0) end;
  else
    if (pos < 0) then 
      pos = self.length - (_G.math.fmod(-pos, self.length));
    end;
  end;
  len = Math.min(len, self.length - pos);
  local ret = _hx_tab_array({}, 0);
  local _g = pos;
  local _g1 = pos + len;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    ret:push(self[i]);
    self[i] = self[i + len];
  end;
  local _g = pos + len;
  local _g1 = self.length;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    self[i] = self[i + len];
  end;
  local tmp = self;
  tmp.length = tmp.length - len;
  do return ret end
end
Array.prototype.toString = function(self) 
  local tbl = ({});
  _G.table.insert(tbl, "[");
  _G.table.insert(tbl, self:join(","));
  _G.table.insert(tbl, "]");
  do return _G.table.concat(tbl, "") end
end
Array.prototype.unshift = function(self,x) 
  local len = self.length;
  local _g = 0;
  local _g1 = len;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    self[len - i] = self[(len - i) - 1];
  end;
  self[0] = x;
end
Array.prototype.insert = function(self,pos,x) 
  if (pos > self.length) then 
    pos = self.length;
  end;
  if (pos < 0) then 
    pos = self.length + pos;
    if (pos < 0) then 
      pos = 0;
    end;
  end;
  local cur_len = self.length;
  while (cur_len > pos) do 
    self[cur_len] = self[cur_len - 1];
    cur_len = cur_len - 1;
  end;
  self[pos] = x;
end
Array.prototype.remove = function(self,x) 
  local _g = 0;
  local _g1 = self.length;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    if (self[i] == x) then 
      local _g = i;
      local _g1 = self.length - 1;
      while (_g < _g1) do 
        _g = _g + 1;
        local j = _g - 1;
        self[j] = self[j + 1];
      end;
      self[self.length - 1] = nil;
      self.length = self.length - 1;
      do return true end;
    end;
  end;
  do return false end
end
Array.prototype.contains = function(self,x) 
  local _g = 0;
  local _g1 = self.length;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    if (self[i] == x) then 
      do return true end;
    end;
  end;
  do return false end
end
Array.prototype.indexOf = function(self,x,fromIndex) 
  local _end = self.length;
  if (fromIndex == nil) then 
    fromIndex = 0;
  else
    if (fromIndex < 0) then 
      fromIndex = self.length + fromIndex;
      if (fromIndex < 0) then 
        fromIndex = 0;
      end;
    end;
  end;
  local _g = fromIndex;
  local _g1 = _end;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    if (x == self[i]) then 
      do return i end;
    end;
  end;
  do return -1 end
end
Array.prototype.lastIndexOf = function(self,x,fromIndex) 
  if ((fromIndex == nil) or (fromIndex >= self.length)) then 
    fromIndex = self.length - 1;
  else
    if (fromIndex < 0) then 
      fromIndex = self.length + fromIndex;
      if (fromIndex < 0) then 
        do return -1 end;
      end;
    end;
  end;
  local i = fromIndex;
  while (i >= 0) do 
    if (self[i] == x) then 
      do return i end;
    else
      i = i - 1;
    end;
  end;
  do return -1 end
end
Array.prototype.copy = function(self) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = self;
  while (_g1 < _g2.length) do 
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    _g:push(i);
  end;
  do return _g end
end
Array.prototype.map = function(self,f) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = self;
  while (_g1 < _g2.length) do 
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    _g:push(f(i));
  end;
  do return _g end
end
Array.prototype.filter = function(self,f) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = self;
  while (_g1 < _g2.length) do 
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    if (f(i)) then 
      _g:push(i);
    end;
  end;
  do return _g end
end
Array.prototype.iterator = function(self) 
  do return __haxe_iterators_ArrayIterator.new(self) end
end
Array.prototype.keyValueIterator = function(self) 
  do return __haxe_iterators_ArrayKeyValueIterator.new(self) end
end
Array.prototype.resize = function(self,len) 
  if (self.length < len) then 
    self.length = len;
  else
    if (self.length > len) then 
      local _g = len;
      local _g1 = self.length;
      while (_g < _g1) do 
        _g = _g + 1;
        local i = _g - 1;
        self[i] = nil;
      end;
      self.length = len;
    end;
  end;
end

Array.prototype.__class__ =  Array

Date.new = function(year,month,day,hour,min,sec) 
  local self = _hx_new(Date.prototype)
  Date.super(self,year,month,day,hour,min,sec)
  return self
end
Date.super = function(self,year,month,day,hour,min,sec) 
  self.t = _G.os.time(_hx_o({__fields__={year=true,month=true,day=true,hour=true,min=true,sec=true},year=year,month=month + 1,day=day,hour=hour,min=min,sec=sec}));
  self.d = _G.os.date("*t", self.t);
  self.dUTC = _G.os.date("!*t", self.t);
end
Date.__name__ = true
Date.prototype = _hx_e();
Date.prototype.d= nil;
Date.prototype.dUTC= nil;
Date.prototype.t= nil;
Date.prototype.getHours = function(self) 
  do return self.d.hour end
end
Date.prototype.getMinutes = function(self) 
  do return self.d.min end
end
Date.prototype.getSeconds = function(self) 
  do return self.d.sec end
end
Date.prototype.getFullYear = function(self) 
  do return self.d.year end
end
Date.prototype.getMonth = function(self) 
  do return self.d.month - 1 end
end
Date.prototype.getDate = function(self) 
  do return self.d.day end
end

Date.prototype.__class__ =  Date

Lambda.new = {}
Lambda.__name__ = true
Lambda.has = function(it,elt) 
  local x = it:iterator();
  while (x:hasNext()) do 
    local x = x:next();
    if (x == elt) then 
      do return true end;
    end;
  end;
  do return false end;
end

Math.new = {}
Math.__name__ = true
Math.isNaN = function(f) 
  do return f ~= f end;
end
Math.isFinite = function(f) 
  if (f > -_G.math.huge) then 
    do return f < _G.math.huge end;
  else
    do return false end;
  end;
end
Math.min = function(a,b) 
  if (Math.isNaN(a) or Math.isNaN(b)) then 
    do return (0/0) end;
  else
    do return _G.math.min(a, b) end;
  end;
end

Reflect.new = {}
Reflect.__name__ = true
Reflect.field = function(o,field) 
  if (_G.type(o) == "string") then 
    if (field == "length") then 
      do return _hx_wrap_if_string_field(o,'length') end;
    else
      do return String.prototype[field] end;
    end;
  else
    local _hx_status, _hx_result = pcall(function() 
    
        do return o[field] end;
      return _hx_pcall_default
    end)
    if not _hx_status and _hx_result == "_hx_pcall_break" then
    elseif not _hx_status then 
      local _g = _hx_result;
      do return nil end;
    elseif _hx_result ~= _hx_pcall_default then
      return _hx_result
    end;
  end;
end
Reflect.fields = function(o) 
  if (_G.type(o) == "string") then 
    do return Reflect.fields(String.prototype) end;
  else
    do return _hx_field_arr(o) end;
  end;
end
Reflect.isFunction = function(f) 
  if (_G.type(f) == "function") then 
    do return not ((function() 
      local _hx_1
      if (_G.type(f) ~= "table") then 
      _hx_1 = false; else 
      _hx_1 = f.__name__; end
      return _hx_1
    end )() or (function() 
      local _hx_2
      if (_G.type(f) ~= "table") then 
      _hx_2 = false; else 
      _hx_2 = f.__ename__; end
      return _hx_2
    end )()) end;
  else
    do return false end;
  end;
end

String.new = function(string) 
  local self = _hx_new(String.prototype)
  String.super(self,string)
  self = string
  return self
end
String.super = function(self,string) 
end
String.__name__ = true
String.__index = function(s,k) 
  if (k == "length") then 
    do return _G.string.len(s) end;
  else
    local o = String.prototype;
    local field = k;
    if ((function() 
      local _hx_1
      if ((_G.type(o) == "string") and ((String.prototype[field] ~= nil) or (field == "length"))) then 
      _hx_1 = true; elseif (o.__fields__ ~= nil) then 
      _hx_1 = o.__fields__[field] ~= nil; else 
      _hx_1 = o[field] ~= nil; end
      return _hx_1
    end )()) then 
      do return String.prototype[k] end;
    else
      if (String.__oldindex ~= nil) then 
        if (_G.type(String.__oldindex) == "function") then 
          do return String.__oldindex(s, k) end;
        else
          if (_G.type(String.__oldindex) == "table") then 
            do return String.__oldindex[k] end;
          end;
        end;
        do return nil end;
      else
        do return nil end;
      end;
    end;
  end;
end
String.indexOfEmpty = function(s,startIndex) 
  local length = _G.string.len(s);
  if (startIndex < 0) then 
    startIndex = length + startIndex;
    if (startIndex < 0) then 
      startIndex = 0;
    end;
  end;
  if (startIndex > length) then 
    do return length end;
  else
    do return startIndex end;
  end;
end
String.fromCharCode = function(code) 
  do return _G.string.char(code) end;
end
String.prototype = _hx_e();
String.prototype.length= nil;
String.prototype.toUpperCase = function(self) 
  do return _G.string.upper(self) end
end
String.prototype.toLowerCase = function(self) 
  do return _G.string.lower(self) end
end
String.prototype.indexOf = function(self,str,startIndex) 
  if (startIndex == nil) then 
    startIndex = 1;
  else
    startIndex = startIndex + 1;
  end;
  if (str == "") then 
    do return String.indexOfEmpty(self, startIndex - 1) end;
  end;
  local r = _G.string.find(self, str, startIndex, true);
  if ((r ~= nil) and (r > 0)) then 
    do return r - 1 end;
  else
    do return -1 end;
  end;
end
String.prototype.lastIndexOf = function(self,str,startIndex) 
  local ret = -1;
  if (startIndex == nil) then 
    startIndex = #self;
  end;
  while (true) do 
    local startIndex1 = ret + 1;
    if (startIndex1 == nil) then 
      startIndex1 = 1;
    else
      startIndex1 = startIndex1 + 1;
    end;
    local p;
    if (str == "") then 
      p = String.indexOfEmpty(self, startIndex1 - 1);
    else
      local r = _G.string.find(self, str, startIndex1, true);
      p = (function() 
        local _hx_1
        if ((r ~= nil) and (r > 0)) then 
        _hx_1 = r - 1; else 
        _hx_1 = -1; end
        return _hx_1
      end )();
    end;
    if (((p == -1) or (p > startIndex)) or (p == ret)) then 
      break;
    end;
    ret = p;
  end;
  do return ret end
end
String.prototype.split = function(self,delimiter) 
  local idx = 1;
  local ret = _hx_tab_array({}, 0);
  while (idx ~= nil) do 
    local newidx = 0;
    if (#delimiter > 0) then 
      newidx = _G.string.find(self, delimiter, idx, true);
    else
      if (idx >= #self) then 
        newidx = nil;
      else
        newidx = idx + 1;
      end;
    end;
    if (newidx ~= nil) then 
      local match = _G.string.sub(self, idx, newidx - 1);
      ret:push(match);
      idx = newidx + #delimiter;
    else
      ret:push(_G.string.sub(self, idx, #self));
      idx = nil;
    end;
  end;
  do return ret end
end
String.prototype.toString = function(self) 
  do return self end
end
String.prototype.substring = function(self,startIndex,endIndex) 
  if (endIndex == nil) then 
    endIndex = #self;
  end;
  if (endIndex < 0) then 
    endIndex = 0;
  end;
  if (startIndex < 0) then 
    startIndex = 0;
  end;
  if (endIndex < startIndex) then 
    do return _G.string.sub(self, endIndex + 1, startIndex) end;
  else
    do return _G.string.sub(self, startIndex + 1, endIndex) end;
  end;
end
String.prototype.charAt = function(self,index) 
  do return _G.string.sub(self, index + 1, index + 1) end
end
String.prototype.charCodeAt = function(self,index) 
  do return _G.string.byte(self, index + 1) end
end
String.prototype.substr = function(self,pos,len) 
  if ((len == nil) or (len > (pos + #self))) then 
    len = #self;
  else
    if (len < 0) then 
      len = #self + len;
    end;
  end;
  if (pos < 0) then 
    pos = #self + pos;
  end;
  if (pos < 0) then 
    pos = 0;
  end;
  do return _G.string.sub(self, pos + 1, pos + len) end
end

String.prototype.__class__ =  String

Std.new = {}
Std.__name__ = true
Std.string = function(s) 
  do return _hx_tostring(s, 0) end;
end
Std.int = function(x) 
  if (not Math.isFinite(x) or Math.isNaN(x)) then 
    do return 0 end;
  else
    do return _hx_bit_clamp(x) end;
  end;
end

StringBuf.new = function() 
  local self = _hx_new(StringBuf.prototype)
  StringBuf.super(self)
  return self
end
StringBuf.super = function(self) 
  self.b = ({});
  self.length = 0;
end
StringBuf.__name__ = true
StringBuf.prototype = _hx_e();
StringBuf.prototype.b= nil;
StringBuf.prototype.length= nil;

StringBuf.prototype.__class__ =  StringBuf

StringTools.new = {}
StringTools.__name__ = true
StringTools.lpad = function(s,c,l) 
  if (#c <= 0) then 
    do return s end;
  end;
  local buf_b = ({});
  local buf_length = 0;
  l = l - #s;
  while (buf_length < l) do 
    local str = Std.string(c);
    _G.table.insert(buf_b, str);
    buf_length = buf_length + #str;
  end;
  local str = Std.string(s);
  _G.table.insert(buf_b, str);
  buf_length = buf_length + #str;
  do return _G.table.concat(buf_b) end;
end
_hxClasses["ValueType"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="TNull","TInt","TFloat","TBool","TObject","TFunction","TClass","TEnum","TUnknown"},9)}
ValueType = _hxClasses["ValueType"];
ValueType.TNull = _hx_tab_array({[0]="TNull",0,__enum__ = ValueType},2)

ValueType.TInt = _hx_tab_array({[0]="TInt",1,__enum__ = ValueType},2)

ValueType.TFloat = _hx_tab_array({[0]="TFloat",2,__enum__ = ValueType},2)

ValueType.TBool = _hx_tab_array({[0]="TBool",3,__enum__ = ValueType},2)

ValueType.TObject = _hx_tab_array({[0]="TObject",4,__enum__ = ValueType},2)

ValueType.TFunction = _hx_tab_array({[0]="TFunction",5,__enum__ = ValueType},2)

ValueType.TClass = function(c) local _x = _hx_tab_array({[0]="TClass",6,c,__enum__=ValueType}, 3); return _x; end 
ValueType.TEnum = function(e) local _x = _hx_tab_array({[0]="TEnum",7,e,__enum__=ValueType}, 3); return _x; end 
ValueType.TUnknown = _hx_tab_array({[0]="TUnknown",8,__enum__ = ValueType},2)


Type.new = {}
Type.__name__ = true
Type.getClass = function(o) 
  if (o == nil) then 
    do return nil end;
  end;
  local o = o;
  if (__lua_Boot.__instanceof(o, Array)) then 
    do return Array end;
  else
    if (__lua_Boot.__instanceof(o, String)) then 
      do return String end;
    else
      local cl = o.__class__;
      if (cl ~= nil) then 
        do return cl end;
      else
        do return nil end;
      end;
    end;
  end;
end
Type.getInstanceFields = function(c) 
  local p = c.prototype;
  local a = _hx_tab_array({}, 0);
  while (p ~= nil) do 
    local _g = 0;
    local _g1 = Reflect.fields(p);
    while (_g < _g1.length) do 
      local f = _g1[_g];
      _g = _g + 1;
      if (not Lambda.has(a, f)) then 
        a:push(f);
      end;
    end;
    local mt = _G.getmetatable(p);
    if ((mt ~= nil) and (mt.__index ~= nil)) then 
      p = mt.__index;
    else
      p = nil;
    end;
  end;
  do return a end;
end
Type.typeof = function(v) 
  local _g = _G.type(v);
  if (_g) == "boolean" then 
    do return ValueType.TBool end;
  elseif (_g) == "function" then 
    if ((function() 
      local _hx_1
      if (_G.type(v) ~= "table") then 
      _hx_1 = false; else 
      _hx_1 = v.__name__; end
      return _hx_1
    end )() or (function() 
      local _hx_2
      if (_G.type(v) ~= "table") then 
      _hx_2 = false; else 
      _hx_2 = v.__ename__; end
      return _hx_2
    end )()) then 
      do return ValueType.TObject end;
    end;
    do return ValueType.TFunction end;
  elseif (_g) == "nil" then 
    do return ValueType.TNull end;
  elseif (_g) == "number" then 
    if (_G.math.ceil(v) == (_G.math.fmod(v, 2147483648.0))) then 
      do return ValueType.TInt end;
    end;
    do return ValueType.TFloat end;
  elseif (_g) == "string" then 
    do return ValueType.TClass(String) end;
  elseif (_g) == "table" then 
    local e = v.__enum__;
    if (e ~= nil) then 
      do return ValueType.TEnum(e) end;
    end;
    local c;
    if (__lua_Boot.__instanceof(v, Array)) then 
      c = Array;
    else
      if (__lua_Boot.__instanceof(v, String)) then 
        c = String;
      else
        local cl = v.__class__;
        c = (function() 
          local _hx_3
          if (cl ~= nil) then 
          _hx_3 = cl; else 
          _hx_3 = nil; end
          return _hx_3
        end )();
      end;
    end;
    if (c ~= nil) then 
      do return ValueType.TClass(c) end;
    end;
    do return ValueType.TObject end;else
  do return ValueType.TUnknown end; end;
end

__haxe_IMap.new = {}
__haxe_IMap.__name__ = true

__haxe_Exception.new = function(message,previous,native) 
  local self = _hx_new(__haxe_Exception.prototype)
  __haxe_Exception.super(self,message,previous,native)
  return self
end
__haxe_Exception.super = function(self,message,previous,native) 
  self.__skipStack = 0;
  self.__exceptionMessage = message;
  self.__previousException = previous;
  if (native ~= nil) then 
    self.__nativeException = native;
    self.__nativeStack = __haxe_NativeStackTrace.exceptionStack();
  else
    self.__nativeException = self;
    self.__nativeStack = __haxe_NativeStackTrace.callStack();
    self.__skipStack = 1;
  end;
end
__haxe_Exception.__name__ = true
__haxe_Exception.thrown = function(value) 
  if (__lua_Boot.__instanceof(value, __haxe_Exception)) then 
    do return value:get_native() end;
  else
    local e = __haxe_ValueException.new(value);
    e.__skipStack = e.__skipStack + 1;
    do return e end;
  end;
end
__haxe_Exception.prototype = _hx_e();
__haxe_Exception.prototype.__exceptionMessage= nil;
__haxe_Exception.prototype.__nativeStack= nil;
__haxe_Exception.prototype.__skipStack= nil;
__haxe_Exception.prototype.__nativeException= nil;
__haxe_Exception.prototype.__previousException= nil;
__haxe_Exception.prototype.get_native = function(self) 
  do return self.__nativeException end
end

__haxe_Exception.prototype.__class__ =  __haxe_Exception

__haxe_Json.new = {}
__haxe_Json.__name__ = true
__haxe_Json.stringify = function(value,replacer,space) 
  do return __haxe_format_JsonPrinter.print(value, replacer, space) end;
end

__haxe_Log.new = {}
__haxe_Log.__name__ = true
__haxe_Log.formatOutput = function(v,infos) 
  local str = Std.string(v);
  if (infos == nil) then 
    do return str end;
  end;
  local pstr = Std.string(Std.string(infos.fileName) .. Std.string(":")) .. Std.string(infos.lineNumber);
  if (infos.customParams ~= nil) then 
    local _g = 0;
    local _g1 = infos.customParams;
    while (_g < _g1.length) do 
      local v = _g1[_g];
      _g = _g + 1;
      str = Std.string(str) .. Std.string((Std.string(", ") .. Std.string(Std.string(v))));
    end;
  end;
  do return Std.string(Std.string(pstr) .. Std.string(": ")) .. Std.string(str) end;
end
__haxe_Log.trace = function(v,infos) 
  local str = __haxe_Log.formatOutput(v, infos);
  _hx_print(str);
end

__haxe_NativeStackTrace.new = {}
__haxe_NativeStackTrace.__name__ = true
__haxe_NativeStackTrace.saveStack = function(exception) 
end
__haxe_NativeStackTrace.callStack = function() 
  local _g = debug.traceback();
  if (_g == nil) then 
    do return _hx_tab_array({}, 0) end;
  else
    local s = _g;
    local idx = 1;
    local ret = _hx_tab_array({}, 0);
    while (idx ~= nil) do 
      local newidx = 0;
      if (#"\n" > 0) then 
        newidx = _G.string.find(s, "\n", idx, true);
      else
        if (idx >= #s) then 
          newidx = nil;
        else
          newidx = idx + 1;
        end;
      end;
      if (newidx ~= nil) then 
        local match = _G.string.sub(s, idx, newidx - 1);
        ret:push(match);
        idx = newidx + #"\n";
      else
        ret:push(_G.string.sub(s, idx, #s));
        idx = nil;
      end;
    end;
    do return ret:slice(3) end;
  end;
end
__haxe_NativeStackTrace.exceptionStack = function() 
  do return _hx_tab_array({}, 0) end;
end

__haxe_ValueException.new = function(value,previous,native) 
  local self = _hx_new(__haxe_ValueException.prototype)
  __haxe_ValueException.super(self,value,previous,native)
  return self
end
__haxe_ValueException.super = function(self,value,previous,native) 
  __haxe_Exception.super(self,Std.string(value),previous,native);
  self.value = value;
end
__haxe_ValueException.__name__ = true
__haxe_ValueException.prototype = _hx_e();
__haxe_ValueException.prototype.value= nil;

__haxe_ValueException.prototype.__class__ =  __haxe_ValueException
__haxe_ValueException.__super__ = __haxe_Exception
setmetatable(__haxe_ValueException.prototype,{__index=__haxe_Exception.prototype})

__haxe_ds_StringMap.new = function() 
  local self = _hx_new(__haxe_ds_StringMap.prototype)
  __haxe_ds_StringMap.super(self)
  return self
end
__haxe_ds_StringMap.super = function(self) 
  self.h = ({});
end
__haxe_ds_StringMap.__name__ = true
__haxe_ds_StringMap.__interfaces__ = {__haxe_IMap}
__haxe_ds_StringMap.prototype = _hx_e();
__haxe_ds_StringMap.prototype.h= nil;
__haxe_ds_StringMap.prototype.keys = function(self) 
  local _gthis = self;
  local next = _G.next;
  local cur = next(self.h, nil);
  do return _hx_o({__fields__={next=true,hasNext=true},next=function(self) 
    local ret = cur;
    cur = next(_gthis.h, cur);
    do return ret end;
  end,hasNext=function(self) 
    do return cur ~= nil end;
  end}) end
end

__haxe_ds_StringMap.prototype.__class__ =  __haxe_ds_StringMap

__haxe_format_JsonPrinter.new = function(replacer,space) 
  local self = _hx_new(__haxe_format_JsonPrinter.prototype)
  __haxe_format_JsonPrinter.super(self,replacer,space)
  return self
end
__haxe_format_JsonPrinter.super = function(self,replacer,space) 
  self.replacer = _hx_funcToField(replacer);
  self.indent = space;
  self.pretty = space ~= nil;
  self.nind = 0;
  self.buf = StringBuf.new();
end
__haxe_format_JsonPrinter.__name__ = true
__haxe_format_JsonPrinter.print = function(o,replacer,space) 
  local printer = __haxe_format_JsonPrinter.new(replacer, space);
  printer:write("", o);
  do return _G.table.concat(printer.buf.b) end;
end
__haxe_format_JsonPrinter.prototype = _hx_e();
__haxe_format_JsonPrinter.prototype.buf= nil;
__haxe_format_JsonPrinter.prototype.replacer= nil;
__haxe_format_JsonPrinter.prototype.indent= nil;
__haxe_format_JsonPrinter.prototype.pretty= nil;
__haxe_format_JsonPrinter.prototype.nind= nil;
__haxe_format_JsonPrinter.prototype.write = function(self,k,v) 
  if (self.replacer ~= nil) then 
    v = self:replacer(k, v);
  end;
  local _g = Type.typeof(v);
  local tmp = _g[1];
  if (tmp) == 0 then 
    local _this = self.buf;
    local str = "null";
    _G.table.insert(_this.b, str);
    local _this = _this;
    _this.length = _this.length + #str;
  elseif (tmp) == 1 then 
    local _this = self.buf;
    local str = Std.string(v);
    _G.table.insert(_this.b, str);
    local _this = _this;
    _this.length = _this.length + #str;
  elseif (tmp) == 2 then 
    local v = (function() 
      local _hx_1
      if (Math.isFinite(v)) then 
      _hx_1 = Std.string(v); else 
      _hx_1 = "null"; end
      return _hx_1
    end )();
    local _this = self.buf;
    local str = Std.string(v);
    _G.table.insert(_this.b, str);
    local _this = _this;
    _this.length = _this.length + #str;
  elseif (tmp) == 3 then 
    local _this = self.buf;
    local str = Std.string(v);
    _G.table.insert(_this.b, str);
    local _this = _this;
    _this.length = _this.length + #str;
  elseif (tmp) == 4 then 
    self:fieldsString(v, Reflect.fields(v));
  elseif (tmp) == 5 then 
    local _this = self.buf;
    local str = "\"<fun>\"";
    _G.table.insert(_this.b, str);
    local _this = _this;
    _this.length = _this.length + #str;
  elseif (tmp) == 6 then 
    local c = _g[2];
    if (c == String) then 
      self:quote(v);
    else
      if (c == Array) then 
        local v = v;
        local _this = self.buf;
        _G.table.insert(_this.b, _G.string.char(91));
        local _this = _this;
        _this.length = _this.length + 1;
        local len = v.length;
        local last = len - 1;
        local _g = 0;
        local _g1 = len;
        while (_g < _g1) do 
          _g = _g + 1;
          local i = _g - 1;
          if (i > 0) then 
            local _this = self.buf;
            _G.table.insert(_this.b, _G.string.char(44));
            local _this = _this;
            _this.length = _this.length + 1;
          else
            self.nind = self.nind + 1;
          end;
          if (self.pretty) then 
            local _this = self.buf;
            _G.table.insert(_this.b, _G.string.char(10));
            local _this = _this;
            _this.length = _this.length + 1;
          end;
          if (self.pretty) then 
            local v = StringTools.lpad("", self.indent, self.nind * #self.indent);
            local _this = self.buf;
            local str = Std.string(v);
            _G.table.insert(_this.b, str);
            local _this = _this;
            _this.length = _this.length + #str;
          end;
          self:write(i, v[i]);
          if (i == last) then 
            self.nind = self.nind - 1;
            if (self.pretty) then 
              local _this = self.buf;
              _G.table.insert(_this.b, _G.string.char(10));
              local _this = _this;
              _this.length = _this.length + 1;
            end;
            if (self.pretty) then 
              local v = StringTools.lpad("", self.indent, self.nind * #self.indent);
              local _this = self.buf;
              local str = Std.string(v);
              _G.table.insert(_this.b, str);
              local _this = _this;
              _this.length = _this.length + #str;
            end;
          end;
        end;
        local _this = self.buf;
        _G.table.insert(_this.b, _G.string.char(93));
        local _this = _this;
        _this.length = _this.length + 1;
      else
        if (c == __haxe_ds_StringMap) then 
          local v = v;
          local o = _hx_e();
          local k = v:keys();
          while (k:hasNext()) do 
            local k = k:next();
            local ret = v.h[k];
            if (ret == __haxe_ds_StringMap.tnull) then 
              ret = nil;
            end;
            o[k] = ret;
          end;
          local v = o;
          self:fieldsString(v, Reflect.fields(v));
        else
          if (c == Date) then 
            local v = v;
            self:quote(__lua_Boot.dateStr(v));
          else
            self:classString(v);
          end;
        end;
      end;
    end;
  elseif (tmp) == 7 then 
    local _g = _g[2];
    local i = v[1];
    local _this = self.buf;
    local str = Std.string(i);
    _G.table.insert(_this.b, str);
    local _this = _this;
    _this.length = _this.length + #str;
  elseif (tmp) == 8 then 
    local _this = self.buf;
    local str = "\"???\"";
    _G.table.insert(_this.b, str);
    local _this = _this;
    _this.length = _this.length + #str; end;
end
__haxe_format_JsonPrinter.prototype.classString = function(self,v) 
  self:fieldsString(v, Type.getInstanceFields(Type.getClass(v)));
end
__haxe_format_JsonPrinter.prototype.fieldsString = function(self,v,fields) 
  local _this = self.buf;
  _G.table.insert(_this.b, _G.string.char(123));
  local _this = _this;
  _this.length = _this.length + 1;
  local len = fields.length;
  local last = len - 1;
  local first = true;
  local _g = 0;
  local _g1 = len;
  local _hx_continue_1 = false;
  while (_g < _g1) do repeat 
    _g = _g + 1;
    local i = _g - 1;
    local f = fields[i];
    local value = Reflect.field(v, f);
    if (Reflect.isFunction(value)) then 
      break;
    end;
    if (first) then 
      self.nind = self.nind + 1;
      first = false;
    else
      local _this = self.buf;
      _G.table.insert(_this.b, _G.string.char(44));
      local _this = _this;
      _this.length = _this.length + 1;
    end;
    if (self.pretty) then 
      local _this = self.buf;
      _G.table.insert(_this.b, _G.string.char(10));
      local _this = _this;
      _this.length = _this.length + 1;
    end;
    if (self.pretty) then 
      local v = StringTools.lpad("", self.indent, self.nind * #self.indent);
      local _this = self.buf;
      local str = Std.string(v);
      _G.table.insert(_this.b, str);
      local _this = _this;
      _this.length = _this.length + #str;
    end;
    self:quote(f);
    local _this = self.buf;
    _G.table.insert(_this.b, _G.string.char(58));
    local _this = _this;
    _this.length = _this.length + 1;
    if (self.pretty) then 
      local _this = self.buf;
      _G.table.insert(_this.b, _G.string.char(32));
      local _this = _this;
      _this.length = _this.length + 1;
    end;
    self:write(f, value);
    if (i == last) then 
      self.nind = self.nind - 1;
      if (self.pretty) then 
        local _this = self.buf;
        _G.table.insert(_this.b, _G.string.char(10));
        local _this = _this;
        _this.length = _this.length + 1;
      end;
      if (self.pretty) then 
        local v = StringTools.lpad("", self.indent, self.nind * #self.indent);
        local _this = self.buf;
        local str = Std.string(v);
        _G.table.insert(_this.b, str);
        local _this = _this;
        _this.length = _this.length + #str;
      end;
    end;until true
    if _hx_continue_1 then 
    _hx_continue_1 = false;
    break;
    end;
    
  end;
  local _this = self.buf;
  _G.table.insert(_this.b, _G.string.char(125));
  local _this = _this;
  _this.length = _this.length + 1;
end
__haxe_format_JsonPrinter.prototype.quote = function(self,s) 
  local _this = self.buf;
  _G.table.insert(_this.b, _G.string.char(34));
  local _this = _this;
  _this.length = _this.length + 1;
  local i = 0;
  while (true) do 
    i = i + 1;
    local c = _G.string.byte(s, (i - 1) + 1);
    if (c == nil) then 
      break;
    end;
    local c1 = c;
    if (c1) == 8 then 
      local _this = self.buf;
      local str = "\\b";
      _G.table.insert(_this.b, str);
      local _this = _this;
      _this.length = _this.length + #str;
    elseif (c1) == 9 then 
      local _this = self.buf;
      local str = "\\t";
      _G.table.insert(_this.b, str);
      local _this = _this;
      _this.length = _this.length + #str;
    elseif (c1) == 10 then 
      local _this = self.buf;
      local str = "\\n";
      _G.table.insert(_this.b, str);
      local _this = _this;
      _this.length = _this.length + #str;
    elseif (c1) == 12 then 
      local _this = self.buf;
      local str = "\\f";
      _G.table.insert(_this.b, str);
      local _this = _this;
      _this.length = _this.length + #str;
    elseif (c1) == 13 then 
      local _this = self.buf;
      local str = "\\r";
      _G.table.insert(_this.b, str);
      local _this = _this;
      _this.length = _this.length + #str;
    elseif (c1) == 34 then 
      local _this = self.buf;
      local str = "\\\"";
      _G.table.insert(_this.b, str);
      local _this = _this;
      _this.length = _this.length + #str;
    elseif (c1) == 92 then 
      local _this = self.buf;
      local str = "\\\\";
      _G.table.insert(_this.b, str);
      local _this = _this;
      _this.length = _this.length + #str;else
    local _this = self.buf;
    _G.table.insert(_this.b, _G.string.char(c));
    local _this = _this;
    _this.length = _this.length + 1; end;
  end;
  local _this = self.buf;
  _G.table.insert(_this.b, _G.string.char(34));
  local _this = _this;
  _this.length = _this.length + 1;
end

__haxe_format_JsonPrinter.prototype.__class__ =  __haxe_format_JsonPrinter

__haxe_io_Bytes.new = function(length,b) 
  local self = _hx_new(__haxe_io_Bytes.prototype)
  __haxe_io_Bytes.super(self,length,b)
  return self
end
__haxe_io_Bytes.super = function(self,length,b) 
  self.length = length;
  self.b = b;
end
__haxe_io_Bytes.__name__ = true
__haxe_io_Bytes.prototype = _hx_e();
__haxe_io_Bytes.prototype.length= nil;
__haxe_io_Bytes.prototype.b= nil;
__haxe_io_Bytes.prototype.getString = function(self,pos,len,encoding) 
  local tmp = encoding == nil;
  if (((pos < 0) or (len < 0)) or ((pos + len) > self.length)) then 
    _G.error(__haxe_Exception.thrown(__haxe_io_Error.OutsideBounds),0);
  end;
  if ((self.b.length - pos) <= __lua_Boot.MAXSTACKSIZE) then 
    local _end = Math.min(self.b.length, pos + len) - 1;
    do return _G.string.char(_hx_table.unpack(self.b, pos, _end)) end;
  else
    local tbl = ({});
    local _g = pos;
    local _g1 = pos + len;
    while (_g < _g1) do 
      _g = _g + 1;
      local idx = _g - 1;
      _G.table.insert(tbl, _G.string.char(self.b[idx]));
    end;
    do return _G.table.concat(tbl, "") end;
  end;
end

__haxe_io_Bytes.prototype.__class__ =  __haxe_io_Bytes
_hxClasses["haxe.io.Encoding"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="UTF8","RawNative"},2)}
__haxe_io_Encoding = _hxClasses["haxe.io.Encoding"];
__haxe_io_Encoding.UTF8 = _hx_tab_array({[0]="UTF8",0,__enum__ = __haxe_io_Encoding},2)

__haxe_io_Encoding.RawNative = _hx_tab_array({[0]="RawNative",1,__enum__ = __haxe_io_Encoding},2)

_hxClasses["haxe.io.Error"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="Blocked","Overflow","OutsideBounds","Custom"},4)}
__haxe_io_Error = _hxClasses["haxe.io.Error"];
__haxe_io_Error.Blocked = _hx_tab_array({[0]="Blocked",0,__enum__ = __haxe_io_Error},2)

__haxe_io_Error.Overflow = _hx_tab_array({[0]="Overflow",1,__enum__ = __haxe_io_Error},2)

__haxe_io_Error.OutsideBounds = _hx_tab_array({[0]="OutsideBounds",2,__enum__ = __haxe_io_Error},2)

__haxe_io_Error.Custom = function(e) local _x = _hx_tab_array({[0]="Custom",3,e,__enum__=__haxe_io_Error}, 3); return _x; end 

__haxe_iterators_ArrayIterator.new = function(array) 
  local self = _hx_new(__haxe_iterators_ArrayIterator.prototype)
  __haxe_iterators_ArrayIterator.super(self,array)
  return self
end
__haxe_iterators_ArrayIterator.super = function(self,array) 
  self.current = 0;
  self.array = array;
end
__haxe_iterators_ArrayIterator.__name__ = true
__haxe_iterators_ArrayIterator.prototype = _hx_e();
__haxe_iterators_ArrayIterator.prototype.array= nil;
__haxe_iterators_ArrayIterator.prototype.current= nil;
__haxe_iterators_ArrayIterator.prototype.hasNext = function(self) 
  do return self.current < self.array.length end
end
__haxe_iterators_ArrayIterator.prototype.next = function(self) 
  do return self.array[(function() 
  local _hx_obj = self;
  local _hx_fld = 'current';
  local _ = _hx_obj[_hx_fld];
  _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
   return _;
   end)()] end
end

__haxe_iterators_ArrayIterator.prototype.__class__ =  __haxe_iterators_ArrayIterator

__haxe_iterators_ArrayKeyValueIterator.new = function(array) 
  local self = _hx_new(__haxe_iterators_ArrayKeyValueIterator.prototype)
  __haxe_iterators_ArrayKeyValueIterator.super(self,array)
  return self
end
__haxe_iterators_ArrayKeyValueIterator.super = function(self,array) 
  self.array = array;
end
__haxe_iterators_ArrayKeyValueIterator.__name__ = true
__haxe_iterators_ArrayKeyValueIterator.prototype = _hx_e();
__haxe_iterators_ArrayKeyValueIterator.prototype.array= nil;

__haxe_iterators_ArrayKeyValueIterator.prototype.__class__ =  __haxe_iterators_ArrayKeyValueIterator

__hxlr_Constants.new = function() 
  local self = _hx_new(__hxlr_Constants.prototype)
  __hxlr_Constants.super(self)
  return self
end
__hxlr_Constants.super = function(self) 
end
__hxlr_Constants.__name__ = true
__hxlr_Constants.defaultRider = function() 
  local rider = _hx_o({__fields__={scale=true,x_grav=true,y_grav=true,x_vel=true,y_vel=true,camera=true,contactPoints=true,scarfPoints=true,bones=true,limits=true,scarfAnchor=true,colors=true},scale=0.5,x_grav=__hxlr_Constants.x_gravity,y_grav=__hxlr_Constants.y_gravity,x_vel=__hxlr_Constants.x_velocity,y_vel=__hxlr_Constants.y_velocity,camera=4,contactPoints=_hx_tab_array({[0]=_hx_o({__fields__={x=true,y=true,fr=true},x=0,y=0,fr=0.8}), _hx_o({__fields__={x=true,y=true,fr=true},x=0,y=10,fr=0}), _hx_o({__fields__={x=true,y=true,fr=true},x=30,y=10,fr=0}), _hx_o({__fields__={x=true,y=true,fr=true},x=35,y=0,fr=0}), _hx_o({__fields__={x=true,y=true,fr=true},x=10,y=0,fr=0.8}), _hx_o({__fields__={x=true,y=true,fr=true},x=10,y=-11,fr=0.8}), _hx_o({__fields__={x=true,y=true,fr=true},x=23,y=-10,fr=0.1}), _hx_o({__fields__={x=true,y=true,fr=true},x=23,y=-10,fr=0.1}), _hx_o({__fields__={x=true,y=true,fr=true},x=20,y=10,fr=0}), _hx_o({__fields__={x=true,y=true,fr=true},x=20,y=10,fr=0})}, 10),scarfPoints=_hx_tab_array({[0]=_hx_o({__fields__={x=true,y=true,fr=true},x=7,y=-10,fr=0.9}), _hx_o({__fields__={x=true,y=true,fr=true},x=3,y=-10,fr=0.9}), _hx_o({__fields__={x=true,y=true,fr=true},x=0,y=-10,fr=0.9}), _hx_o({__fields__={x=true,y=true,fr=true},x=-4,y=-10,fr=0.9}), _hx_o({__fields__={x=true,y=true,fr=true},x=-7,y=-10,fr=0.9}), _hx_o({__fields__={x=true,y=true,fr=true},x=-11,y=-10,fr=0.9})}, 6),bones=_hx_tab_array({[0]=_hx_o({__fields__={a=true,b=true,type=true,crashable=true},a=0,b=1,type="STANDARD",crashable=false}), _hx_o({__fields__={a=true,b=true,type=true,crashable=true},a=1,b=2,type="STANDARD",crashable=false}), _hx_o({__fields__={a=true,b=true,type=true,crashable=true},a=2,b=3,type="STANDARD",crashable=false}), _hx_o({__fields__={a=true,b=true,type=true,crashable=true},a=3,b=0,type="STANDARD",crashable=false}), _hx_o({__fields__={a=true,b=true,type=true,crashable=true},a=0,b=2,type="STANDARD",crashable=false}), _hx_o({__fields__={a=true,b=true,type=true,crashable=true},a=3,b=1,type="STANDARD",crashable=false}), _hx_o({__fields__={a=true,b=true,type=true,crashable=true},a=0,b=4,type="STANDARD",crashable=true}), _hx_o({__fields__={a=true,b=true,type=true,crashable=true},a=1,b=4,type="STANDARD",crashable=true}), _hx_o({__fields__={a=true,b=true,type=true,crashable=true},a=2,b=4,type="STANDARD",crashable=true}), _hx_o({__fields__={a=true,b=true,type=true,crashable=true},a=5,b=4,type="STANDARD",crashable=false}), _hx_o({__fields__={a=true,b=true,type=true,crashable=true},a=5,b=6,type="STANDARD",crashable=false}), _hx_o({__fields__={a=true,b=true,type=true,crashable=true},a=5,b=7,type="STANDARD",crashable=false}), _hx_o({__fields__={a=true,b=true,type=true,crashable=true},a=4,b=8,type="STANDARD",crashable=false}), _hx_o({__fields__={a=true,b=true,type=true,crashable=true},a=4,b=9,type="STANDARD",crashable=false}), _hx_o({__fields__={a=true,b=true,type=true,crashable=true},a=5,b=7,type="STANDARD",crashable=false}), _hx_o({__fields__={a=true,b=true,type=true,crashable=true},a=5,b=0,type="STANDARD",crashable=true}), _hx_o({__fields__={a=true,b=true,type=true,crashable=true},a=3,b=6,type="STANDARD",crashable=true}), _hx_o({__fields__={a=true,b=true,type=true,crashable=true},a=3,b=7,type="STANDARD",crashable=true}), _hx_o({__fields__={a=true,b=true,type=true,crashable=true},a=8,b=2,type="STANDARD",crashable=true}), _hx_o({__fields__={a=true,b=true,type=true,crashable=true},a=9,b=2,type="STANDARD",crashable=true}), _hx_o({__fields__={a=true,b=true,type=true,crashable=true},a=5,b=8,type="REPELL",crashable=false}), _hx_o({__fields__={a=true,b=true,type=true,crashable=true},a=5,b=9,type="REPELL",crashable=false})}, 22),limits=_hx_tab_array({[0]=_hx_o({__fields__={point_a=true,point_b=true,point_c=true,point_d=true,threshold=true,lessThan=true},point_a=3,point_b=0,point_c=1,point_d=0,threshold=0,lessThan=true})}, 1),scarfAnchor=5,colors=_hx_tab_array({[0]=13763074, 16777215, 13763074, 16777215, 13763074, 16777215, 13763074, 16777215, 13763074, 16777215, 13763074}, 11)});
  do return rider end;
end
__hxlr_Constants.prototype = _hx_e();

__hxlr_Constants.prototype.__class__ =  __hxlr_Constants

__hxlr_engine_Cell.new = function(_info) 
  local self = _hx_new(__hxlr_engine_Cell.prototype)
  __hxlr_engine_Cell.super(self,_info)
  return self
end
__hxlr_engine_Cell.super = function(self,_info) 
  self.info = _info;
  self.allLines = Array.new();
  self.collidable = Array.new();
  self.intangible = Array.new();
end
__hxlr_engine_Cell.__name__ = true
__hxlr_engine_Cell.getInfo = function(_x,_y) 
  local info = _hx_o({__fields__={x=true,y=true,gx=true,gy=true},x=Std.int(_G.math.floor(_x / 14)),y=Std.int(_G.math.floor(_y / 14)),gx=_x - (14 * _G.math.floor(_x / 14)),gy=_y - (14 * _G.math.floor(_y / 14))});
  info.key = Std.string(Std.string(Std.string("x") .. Std.string(info.x)) .. Std.string("y")) .. Std.string(info.y);
  do return info end;
end
__hxlr_engine_Cell.prototype = _hx_e();
__hxlr_engine_Cell.prototype.info= nil;
__hxlr_engine_Cell.prototype.allLines= nil;
__hxlr_engine_Cell.prototype.collidable= nil;
__hxlr_engine_Cell.prototype.intangible= nil;
__hxlr_engine_Cell.prototype.addLine = function(self,_line) 
  if (self.allLines:contains(_line)) then 
    do return end;
  end;
  self.allLines:push(_line);
  if (_line.tangible) then 
    self.collidable[_line.id] = _line;
  else
    self.intangible[_line.id] = _line;
  end;
  if (not __hxlr_engine_Cell.cellList:contains(self)) then 
    __hxlr_engine_Cell.cellList:push(self);
  end;
end
__hxlr_engine_Cell.prototype.removeLine = function(self,_line) 
  if (not self.allLines:contains(_line)) then 
    do return end;
  end;
  self.allLines:remove(_line);
  if (_line.tangible) then 
    self.collidable:remove(_line);
  else
    self.intangible:remove(_line);
  end;
  if (self.allLines.length == 0) then 
    __hxlr_engine_Cell.cellList:remove(self);
  end;
end

__hxlr_engine_Cell.prototype.__class__ =  __hxlr_engine_Cell

__hxlr_engine_Grid.new = function() 
  local self = _hx_new(__hxlr_engine_Grid.prototype)
  __hxlr_engine_Grid.super(self)
  return self
end
__hxlr_engine_Grid.super = function(self) 
  self.subTypeCount = Array.new();
  self.lineIDCount = 0;
  self.lineCount = 0;
  __hxlr_engine_Grid.registry = __haxe_ds_StringMap.new();
  __hxlr_engine_Grid.lines = Array.new();
end
__hxlr_engine_Grid.__name__ = true
__hxlr_engine_Grid.prototype = _hx_e();
__hxlr_engine_Grid.prototype.lineCount= nil;
__hxlr_engine_Grid.prototype.lineIDCount= nil;
__hxlr_engine_Grid.prototype.subTypeCount= nil;
__hxlr_engine_Grid.prototype.register = function(self,_line) 
  self:addLine(_line);
  local start = __hxlr_engine_Cell.getInfo(_line.start.x, _line.start.y);
  local _end = __hxlr_engine_Cell.getInfo(_line["end"].x, _line["end"].y);
  local right = (function() 
    local _hx_1
    if (_line.dx > 0) then 
    _hx_1 = _end.x; else 
    _hx_1 = start.x; end
    return _hx_1
  end )();
  local left = (function() 
    local _hx_2
    if (_line.dx > 0) then 
    _hx_2 = start.x; else 
    _hx_2 = _end.x; end
    return _hx_2
  end )();
  local bottom = (function() 
    local _hx_3
    if (_line.dy > 0) then 
    _hx_3 = _end.y; else 
    _hx_3 = start.y; end
    return _hx_3
  end )();
  local top = (function() 
    local _hx_4
    if (_line.dy > 0) then 
    _hx_4 = start.y; else 
    _hx_4 = _end.y; end
    return _hx_4
  end )();
  self:storeLine(_line, start);
  if (((_line.dx == 0) and (_line.dy == 0)) or ((left == right) and (top == bottom))) then 
    do return end;
  end;
  local x = _line.start.x;
  local y = _line.start.y;
  local invDx = 1 / _line.dx;
  local invDy = 1 / _line.dy;
  local difX;
  local difY;
  local _hx_continue_1 = false;
  while (true) do repeat 
    if (start.x < 0) then 
      difX = (function() 
        local _hx_5
        if (_line.dx > 0) then 
        _hx_5 = 14 + start.gx; else 
        _hx_5 = -14 - start.gx; end
        return _hx_5
      end )();
    else
      difX = (function() 
        local _hx_6
        if (_line.dx > 0) then 
        _hx_6 = 14 - start.gx; else 
        _hx_6 = -(start.gx + 1); end
        return _hx_6
      end )();
    end;
    if (start.y < 0) then 
      difY = (function() 
        local _hx_7
        if (_line.dy > 0) then 
        _hx_7 = 14 + start.gy; else 
        _hx_7 = -14 - start.gy; end
        return _hx_7
      end )();
    else
      difY = (function() 
        local _hx_8
        if (_line.dy > 0) then 
        _hx_8 = 14 - start.gy; else 
        _hx_8 = -(start.gy + 1); end
        return _hx_8
      end )();
    end;
    if (_line.dx == 0) then 
      y = y + difY;
    else
      if (_line.dy == 0) then 
        x = x + difX;
      else
        local step = y + ((_line.dy * difX) * invDx);
        if (_G.math.abs(step - y) < _G.math.abs(difY)) then 
          x = x + difX;
          y = step;
        else
          if (_G.math.abs(step - y) == _G.math.abs(difY)) then 
            x = x + difX;
            y = y + difY;
          else
            x = x + ((_line.dx * difY) * invDy);
            y = y + difY;
          end;
        end;
      end;
    end;
    start = __hxlr_engine_Cell.getInfo(x, y);
    if ((((start.x >= left) and (start.x <= right)) and (start.y >= top)) and (start.y <= bottom)) then 
      self:storeLine(_line, start);
      break;
    end;
    do return end;until true
    if _hx_continue_1 then 
    _hx_continue_1 = false;
    break;
    end;
    
  end;
end
__hxlr_engine_Grid.prototype.addLine = function(self,_line) 
  if (_line.id == nil) then 
    _line.id = self.lineIDCount;
  end;
  __hxlr_engine_Grid.lines[_line.id] = _line;
  self.lineCount = self.lineCount + 1;
  self.lineIDCount = self.lineIDCount + 1;
  self.subTypeCount[_line.type] = self.subTypeCount[_line.type] + 1;
end
__hxlr_engine_Grid.prototype.storeLine = function(self,_line,_info) 
  local ret = __hxlr_engine_Grid.registry.h[_info.key];
  if (ret == __haxe_ds_StringMap.tnull) then 
    ret = nil;
  end;
  if (ret == nil) then 
    local this1 = __hxlr_engine_Grid.registry;
    local k = _info.key;
    local v = __hxlr_engine_Cell.new(_info);
    local _this = this1;
    if (v == nil) then 
      _this.h[k] = __haxe_ds_StringMap.tnull;
    else
      _this.h[k] = v;
    end;
  end;
  local ret = __hxlr_engine_Grid.registry.h[_info.key];
  if (ret == __haxe_ds_StringMap.tnull) then 
    ret = nil;
  end;
  ret:addLine(_line);
  _line.keyList:push(_info.key);
end
__hxlr_engine_Grid.prototype.deleteTrack = function(self) 
  local _g = 0;
  local _g1 = __hxlr_engine_Grid.lines;
  while (_g < _g1.length) do 
    local line = _g1[_g];
    _g = _g + 1;
    self:unregister(line);
  end;
end
__hxlr_engine_Grid.prototype.unregister = function(self,_line) 
  if (_line == nil) then 
    do return end;
  end;
  local _g = 0;
  local _g1 = _line.keyList;
  while (_g < _g1.length) do 
    local key = _g1[_g];
    _g = _g + 1;
    local ret = __hxlr_engine_Grid.registry.h[key];
    if (ret == __haxe_ds_StringMap.tnull) then 
      ret = nil;
    end;
    ret:removeLine(_line);
  end;
  self.lineCount = self.lineCount - 1;
  self.subTypeCount[_line.type] = self.subTypeCount[_line.type] - 1;
  __hxlr_engine_Grid.lines[_line.id] = nil;
end

__hxlr_engine_Grid.prototype.__class__ =  __hxlr_engine_Grid

__hxlr_export_JSONFile.new = {}
__hxlr_export_JSONFile.__name__ = true
__hxlr_export_JSONFile.save = function() 
  local lines = Array.new();
  local save = _hx_o({__fields__={lines=true},lines=lines});
  local json = __haxe_Json.stringify(save);
  do return json end;
end

__hxlr_file_AMF0Reader.new = function(_sol) 
  local self = _hx_new(__hxlr_file_AMF0Reader.prototype)
  __hxlr_file_AMF0Reader.super(self,_sol)
  return self
end
__hxlr_file_AMF0Reader.super = function(self,_sol) 
  self.object = _hx_e();
  self.pos = 0;
  self.data = _sol;
  local tmp = _hx_bit.lshift(self.data.b[self.pos],8);
  local pos = self;
  pos.pos = pos.pos + 1;
  self.header = _hx_bit.bor(tmp,self.data.b[pos.pos]);
  local pos = self;
  pos.pos = pos.pos + 1;
  local tmp = _hx_bit.lshift(self.data.b[pos.pos],24);
  local pos = self;
  pos.pos = pos.pos + 1;
  local tmp = _hx_bit.bor(tmp,_hx_bit.lshift(self.data.b[pos.pos],16));
  local pos = self;
  pos.pos = pos.pos + 1;
  local tmp = _hx_bit.bor(tmp,_hx_bit.lshift(self.data.b[pos.pos],8));
  local pos = self;
  pos.pos = pos.pos + 1;
  self.size = _hx_bit.bor(tmp,self.data.b[pos.pos]);
  if (self.size > self.data.length) then 
    __haxe_Log.trace("Internal size value greater than file size!", _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="src/hxlr/file/AMF0Reader.hx",lineNumber=33,className="hxlr.file.AMF0Reader",methodName="new"}));
    do return end;
  end;
  local tcso = self;
  tcso.pos = tcso.pos + 1;
  local tcso = self.data:getString(tcso.pos, 4);
  if (_G.string.upper(tcso) ~= "TCSO") then 
    __haxe_Log.trace("Not a valid .sol/AMF0 file!", _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true,customParams=true},fileName="src/hxlr/file/AMF0Reader.hx",lineNumber=39,className="hxlr.file.AMF0Reader",methodName="new",customParams=_hx_tab_array({[0]=tcso}, 1)}));
    do return end;
  end;
  local tmp = self;
  tmp.pos = tmp.pos + 11;
  local saveNameSize = self.data.b[self.pos];
  local saveNameField = self;
  saveNameField.pos = saveNameField.pos + 1;
  local saveNameField = self.data:getString(saveNameField.pos, saveNameSize);
  if (saveNameField ~= "savedLines") then 
    __haxe_Log.trace(saveNameSize, _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true,customParams=true},fileName="src/hxlr/file/AMF0Reader.hx",lineNumber=47,className="hxlr.file.AMF0Reader",methodName="new",customParams=_hx_tab_array({[0]=saveNameField}, 1)}));
    __haxe_Log.trace("Unable to locate savedLines!", _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="src/hxlr/file/AMF0Reader.hx",lineNumber=48,className="hxlr.file.AMF0Reader",methodName="new"}));
    do return end;
  end;
  local tmp = self;
  tmp.pos = tmp.pos + (saveNameSize + 4);
  local trackListNameSize = _hx_bit.lshift(self.data.b[self.pos],8);
  local pos = self;
  pos.pos = pos.pos + 1;
  local trackListNameSize = _hx_bit.bor(trackListNameSize,self.data.b[pos.pos]);
  local trackListField = self;
  trackListField.pos = trackListField.pos + 1;
  local trackListField = self.data:getString(trackListField.pos, trackListNameSize);
  if (trackListField ~= "trackList") then 
    __haxe_Log.trace(trackListNameSize, _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true,customParams=true},fileName="src/hxlr/file/AMF0Reader.hx",lineNumber=57,className="hxlr.file.AMF0Reader",methodName="new",customParams=_hx_tab_array({[0]=trackListField}, 1)}));
    __haxe_Log.trace("Unable to locate trackList!", _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="src/hxlr/file/AMF0Reader.hx",lineNumber=58,className="hxlr.file.AMF0Reader",methodName="new"}));
    do return end;
  end;
  self.loadedSOL = _hx_o({__fields__={trackList=true},trackList=_hx_tab_array({}, 0)});
  local pos = self;
  pos.pos = pos.pos + trackListNameSize;
  self:recursiveRead(self.data.b[pos.pos]);
end
__hxlr_file_AMF0Reader.__name__ = true
__hxlr_file_AMF0Reader.prototype = _hx_e();
__hxlr_file_AMF0Reader.prototype.data= nil;
__hxlr_file_AMF0Reader.prototype.pos= nil;
__hxlr_file_AMF0Reader.prototype.size= nil;
__hxlr_file_AMF0Reader.prototype.header= nil;
__hxlr_file_AMF0Reader.prototype.object= nil;
__hxlr_file_AMF0Reader.prototype.loadedSOL= nil;
__hxlr_file_AMF0Reader.prototype.recursiveRead = function(self,_code) 
  local tmp = _code == 8;
end
__hxlr_file_AMF0Reader.prototype.loadSOLTrack = function(self,_index) 
  do return _hx_e() end
end

__hxlr_file_AMF0Reader.prototype.__class__ =  __hxlr_file_AMF0Reader

__hxlr_lines_LineBase.new = function(_start,_end,_shift,_lim) 
  local self = _hx_new(__hxlr_lines_LineBase.prototype)
  __hxlr_lines_LineBase.super(self,_start,_end,_shift,_lim)
  return self
end
__hxlr_lines_LineBase.super = function(self,_start,_end,_shift,_lim) 
  if (_lim == nil) then 
    _lim = 0;
  end;
  self.limValue = 0;
  self.limEnd = 0;
  self.limStart = 0;
  self.limType = 0;
  self.zone = 10;
  self.tangible = false;
  self.start = _start;
  self["end"] = _end;
  self.gfxEnd = __hxlr_math_geom_Point.new(self["end"].x - self.start.x, self["end"].y - self.start.y);
  self.shifted = _shift;
  self.keyList = Array.new();
  self:calculateConstants();
  self:setLim(_lim);
end
__hxlr_lines_LineBase.__name__ = true
__hxlr_lines_LineBase.prototype = _hx_e();
__hxlr_lines_LineBase.prototype.id= nil;
__hxlr_lines_LineBase.prototype.start= nil;
__hxlr_lines_LineBase.prototype["end"]= nil;
__hxlr_lines_LineBase.prototype.type= nil;
__hxlr_lines_LineBase.prototype.tangible= nil;
__hxlr_lines_LineBase.prototype.keyList= nil;
__hxlr_lines_LineBase.prototype.gfxEnd= nil;
__hxlr_lines_LineBase.prototype.shifted= nil;
__hxlr_lines_LineBase.prototype.dx= nil;
__hxlr_lines_LineBase.prototype.dy= nil;
__hxlr_lines_LineBase.prototype.C= nil;
__hxlr_lines_LineBase.prototype.distance= nil;
__hxlr_lines_LineBase.prototype.invSqrDistance= nil;
__hxlr_lines_LineBase.prototype.invDistance= nil;
__hxlr_lines_LineBase.prototype.nx= nil;
__hxlr_lines_LineBase.prototype.ny= nil;
__hxlr_lines_LineBase.prototype.zone= nil;
__hxlr_lines_LineBase.prototype.limType= nil;
__hxlr_lines_LineBase.prototype.limStart= nil;
__hxlr_lines_LineBase.prototype.limEnd= nil;
__hxlr_lines_LineBase.prototype.limValue= nil;
__hxlr_lines_LineBase.prototype.prevLine= nil;
__hxlr_lines_LineBase.prototype.nextLine= nil;
__hxlr_lines_LineBase.prototype.calculateConstants = function(self) 
  self.dx = self["end"].x - self.start.x;
  self.dy = self["end"].y - self.start.y;
  self.C = (self.dy * self.start.x) - (self.dx * self.start.y);
  local _loc2 = _G.math.pow(self.dx, 2) + _G.math.pow(self.dy, 2);
  self.invSqrDistance = 1 / _loc2;
  self.distance = _G.math.sqrt(_loc2);
  self.invDistance = 1 / self.distance;
  self.nx = (self.dy * self.invDistance) * (function() 
    local _hx_1
    if (self.shifted) then 
    _hx_1 = 1; else 
    _hx_1 = -1; end
    return _hx_1
  end )();
  self.ny = (self.dx * self.invDistance) * (function() 
    local _hx_2
    if (self.shifted) then 
    _hx_2 = -1; else 
    _hx_2 = 1; end
    return _hx_2
  end )();
  self.limValue = Math.min(0.25, self.zone / self.distance);
end
__hxlr_lines_LineBase.prototype.setLim = function(self,_limMode) 
  local _limMode1 = _limMode;
  if (_limMode1) == 0 then 
    self.limStart = 0;
    self.limEnd = 1;
  elseif (_limMode1) == 1 then 
    self.limStart = -self.limValue;
    self.limEnd = 1;
  elseif (_limMode1) == 2 then 
    self.limStart = 0;
    self.limEnd = 1 + self.limValue;
  elseif (_limMode1) == 3 then 
    self.limStart = -self.limValue;
    self.limEnd = 1 + self.limValue; end;
  self.limType = _limMode;
end
__hxlr_lines_LineBase.prototype.collide = function(self,_point) 
end
__hxlr_lines_LineBase.prototype.toSaveObject = function(self) 
  local save;
  local _g = self.limType;
  if (_g) == 1 or (_g) == 3 then 
    save = true;
  elseif (_g) == 0 or (_g) == 2 then 
    save = false;else
  save = false; end;
  local save1;
  local _g = self.limType;
  if (_g) == 0 or (_g) == 1 then 
    save1 = false;
  elseif (_g) == 2 or (_g) == 3 then 
    save1 = true;else
  save1 = false; end;
  local save = _hx_o({__fields__={id=true,type=true,x1=true,y1=true,x2=true,y2=true,flipped=true,leftExtended=true,rightExtended=true},id=self.id,type=self.type,x1=self.start.x,y1=self.start.y,x2=self["end"].x,y2=self["end"].y,flipped=self.shifted,leftExtended=save,rightExtended=save1});
  do return save end
end

__hxlr_lines_LineBase.prototype.__class__ =  __hxlr_lines_LineBase

__hxlr_lines_Accel.new = function(_start,_end,_shift) 
  local self = _hx_new(__hxlr_lines_Accel.prototype)
  __hxlr_lines_Accel.super(self,_start,_end,_shift)
  return self
end
__hxlr_lines_Accel.super = function(self,_start,_end,_shift) 
  self.accConst = 0.1;
  __hxlr_lines_LineBase.super(self,_start,_end,_shift);
  self.type = 1;
  self.tangible = true;
end
__hxlr_lines_Accel.__name__ = true
__hxlr_lines_Accel.prototype = _hx_e();
__hxlr_lines_Accel.prototype.accConst= nil;
__hxlr_lines_Accel.prototype.accx= nil;
__hxlr_lines_Accel.prototype.accy= nil;
__hxlr_lines_Accel.prototype.calculateConstants = function(self) 
  __hxlr_lines_LineBase.prototype.calculateConstants(self);
  self.accx = (self.ny * self.accConst) * (function() 
    local _hx_1
    if (self.shifted) then 
    _hx_1 = 1; else 
    _hx_1 = -1; end
    return _hx_1
  end )();
  self.accy = (self.nx * self.accConst) * (function() 
    local _hx_2
    if (self.shifted) then 
    _hx_2 = -1; else 
    _hx_2 = 1; end
    return _hx_2
  end )();
end
__hxlr_lines_Accel.prototype.collide = function(self,_point) 
  local _loc5 = _point.pos.x - self.start.x;
  local _loc6 = _point.pos.y - self.start.y;
  local _loc4 = (self.nx * _loc5) + (self.ny * _loc6);
  local _loc7 = ((_loc5 * self.dx) + (_loc6 * self.dy)) * self.invSqrDistance;
  if (((_point.dir.x * self.nx) + (_point.dir.y * self.ny)) > 0) then 
    if ((((_loc4 > 0) and (_loc4 < self.zone)) and (_loc7 >= self.limStart)) and (_loc7 <= self.limEnd)) then 
      _point.pos.x = _point.pos.x - (_loc4 * self.nx);
      _point.pos.y = _point.pos.y - (_loc4 * self.ny);
      _point.vel.x = (_point.vel.x + (((self.ny * _point.friction) * _loc4) * (function() 
        local _hx_1
        if (_point.vel.x < _point.pos.x) then 
        _hx_1 = 1; else 
        _hx_1 = -1; end
        return _hx_1
      end )())) + self.accx;
      _point.vel.y = (_point.vel.y - (((self.nx * _point.friction) * _loc4) * (function() 
        local _hx_2
        if (_point.vel.y < _point.pos.y) then 
        _hx_2 = -1; else 
        _hx_2 = 1; end
        return _hx_2
      end )())) + self.accy;
    end;
  end;
end

__hxlr_lines_Accel.prototype.__class__ =  __hxlr_lines_Accel
__hxlr_lines_Accel.__super__ = __hxlr_lines_LineBase
setmetatable(__hxlr_lines_Accel.prototype,{__index=__hxlr_lines_LineBase.prototype})

__hxlr_lines_Floor.new = function(_start,_end,_shift) 
  local self = _hx_new(__hxlr_lines_Floor.prototype)
  __hxlr_lines_Floor.super(self,_start,_end,_shift)
  return self
end
__hxlr_lines_Floor.super = function(self,_start,_end,_shift) 
  __hxlr_lines_LineBase.super(self,_start,_end,_shift);
  self.type = 0;
  self.tangible = true;
end
__hxlr_lines_Floor.__name__ = true
__hxlr_lines_Floor.prototype = _hx_e();
__hxlr_lines_Floor.prototype.collide = function(self,_point) 
  local _loc5 = _point.pos.x - self.start.x;
  local _loc6 = _point.pos.y - self.start.y;
  local _loc4 = (self.nx * _loc5) + (self.ny * _loc6);
  local _loc7 = ((_loc5 * self.dx) + (_loc6 * self.dy)) * self.invSqrDistance;
  if (((_point.dir.x * self.nx) + (_point.dir.y * self.ny)) > 0) then 
    if ((((_loc4 > 0) and (_loc4 < self.zone)) and (_loc7 >= self.limStart)) and (_loc7 <= self.limEnd)) then 
      _point.pos.x = _point.pos.x - (_loc4 * self.nx);
      _point.pos.y = _point.pos.y - (_loc4 * self.ny);
      _point.vel.x = _point.vel.x + (((self.ny * _point.friction) * _loc4) * (function() 
        local _hx_1
        if (_point.vel.x < _point.pos.x) then 
        _hx_1 = 1; else 
        _hx_1 = -1; end
        return _hx_1
      end )());
      _point.vel.y = _point.vel.y - (((self.nx * _point.friction) * _loc4) * (function() 
        local _hx_2
        if (_point.vel.y < _point.pos.y) then 
        _hx_2 = -1; else 
        _hx_2 = 1; end
        return _hx_2
      end )());
    end;
  end;
end

__hxlr_lines_Floor.prototype.__class__ =  __hxlr_lines_Floor
__hxlr_lines_Floor.__super__ = __hxlr_lines_LineBase
setmetatable(__hxlr_lines_Floor.prototype,{__index=__hxlr_lines_LineBase.prototype})

__hxlr_lines_Scenery.new = function(_start,_end,_shift) 
  local self = _hx_new(__hxlr_lines_Scenery.prototype)
  __hxlr_lines_Scenery.super(self,_start,_end,_shift)
  return self
end
__hxlr_lines_Scenery.super = function(self,_start,_end,_shift) 
  __hxlr_lines_LineBase.super(self,_start,_end,_shift);
  self.type = 2;
end
__hxlr_lines_Scenery.__name__ = true
__hxlr_lines_Scenery.prototype = _hx_e();

__hxlr_lines_Scenery.prototype.__class__ =  __hxlr_lines_Scenery
__hxlr_lines_Scenery.__super__ = __hxlr_lines_LineBase
setmetatable(__hxlr_lines_Scenery.prototype,{__index=__hxlr_lines_LineBase.prototype})

__hxlr_lines_Undefined.new = function(_start,_end,_shift,_lim) 
  local self = _hx_new(__hxlr_lines_Undefined.prototype)
  __hxlr_lines_Undefined.super(self,_start,_end,_shift,_lim)
  return self
end
__hxlr_lines_Undefined.super = function(self,_start,_end,_shift,_lim) 
  if (_lim == nil) then 
    _lim = 0;
  end;
  __hxlr_lines_LineBase.super(self,_start,_end,_shift,_lim);
end
__hxlr_lines_Undefined.__name__ = true
__hxlr_lines_Undefined.prototype = _hx_e();

__hxlr_lines_Undefined.prototype.__class__ =  __hxlr_lines_Undefined
__hxlr_lines_Undefined.__super__ = __hxlr_lines_LineBase
setmetatable(__hxlr_lines_Undefined.prototype,{__index=__hxlr_lines_LineBase.prototype})

__hxlr_math_geom_Line.new = function(_start,_end) 
  local self = _hx_new(__hxlr_math_geom_Line.prototype)
  __hxlr_math_geom_Line.super(self,_start,_end)
  return self
end
__hxlr_math_geom_Line.super = function(self,_start,_end) 
end
__hxlr_math_geom_Line.__name__ = true
__hxlr_math_geom_Line.prototype = _hx_e();
__hxlr_math_geom_Line.prototype.start= nil;

__hxlr_math_geom_Line.prototype.__class__ =  __hxlr_math_geom_Line

__hxlr_math_geom_Point.new = function(_x,_y) 
  local self = _hx_new(__hxlr_math_geom_Point.prototype)
  __hxlr_math_geom_Point.super(self,_x,_y)
  return self
end
__hxlr_math_geom_Point.super = function(self,_x,_y) 
  if (_y == nil) then 
    _y = 0.0;
  end;
  if (_x == nil) then 
    _x = 0.0;
  end;
  self.x = _x;
  self.y = _y;
end
__hxlr_math_geom_Point.__name__ = true
__hxlr_math_geom_Point.prototype = _hx_e();
__hxlr_math_geom_Point.prototype.x= nil;
__hxlr_math_geom_Point.prototype.y= nil;
__hxlr_math_geom_Point.prototype.clone = function(self) 
  do return __hxlr_math_geom_Point.new(self.x, self.y) end
end
__hxlr_math_geom_Point.prototype.add = function(self,_point) 
  local tmp = self;
  tmp.x = tmp.x + _point.x;
  local tmp = self;
  tmp.y = tmp.y + _point.y;
  do return self end
end
__hxlr_math_geom_Point.prototype.sub = function(self,_point) 
  local tmp = self;
  tmp.x = tmp.x - _point.x;
  local tmp = self;
  tmp.y = tmp.y - _point.y;
  do return self end
end

__hxlr_math_geom_Point.prototype.__class__ =  __hxlr_math_geom_Point

__hxlr_rider_ContactPoint.new = function(_x,_y,_friction) 
  local self = _hx_new(__hxlr_rider_ContactPoint.prototype)
  __hxlr_rider_ContactPoint.super(self,_x,_y,_friction)
  return self
end
__hxlr_rider_ContactPoint.super = function(self,_x,_y,_friction) 
  if (_friction == nil) then 
    _friction = 0.0;
  end;
  if (_y == nil) then 
    _y = 0.0;
  end;
  if (_x == nil) then 
    _x = 0.0;
  end;
  self.pos = __hxlr_math_geom_Point.new(_x, _y);
  self.dir = __hxlr_math_geom_Point.new();
  self.vel = __hxlr_math_geom_Point.new();
  self.friction = _friction;
end
__hxlr_rider_ContactPoint.__name__ = true
__hxlr_rider_ContactPoint.prototype = _hx_e();
__hxlr_rider_ContactPoint.prototype.pos= nil;
__hxlr_rider_ContactPoint.prototype.vel= nil;
__hxlr_rider_ContactPoint.prototype.dir= nil;
__hxlr_rider_ContactPoint.prototype.gravity= nil;
__hxlr_rider_ContactPoint.prototype.friction= nil;
__hxlr_rider_ContactPoint.prototype.iterate = function(self,_gravity) 
  local g = (function() 
    local _hx_1
    if (_gravity == nil) then 
    _hx_1 = self.gravity; else 
    _hx_1 = _gravity; end
    return _hx_1
  end )();
  self.dir.x = (self.pos.x - self.vel.x) + g.x;
  self.dir.y = (self.pos.y - self.vel.y) + g.y;
  self.vel = self.pos:clone();
  self.pos = self.pos:add(self.dir);
end
__hxlr_rider_ContactPoint.prototype.serialize = function(self) 
  local object = _hx_o({__fields__={position=true,velocity=true,friction=true},position=self.pos,velocity=self.vel,friction=self.friction});
  do return object end
end
__hxlr_rider_ContactPoint.prototype.deserialize = function(self,_object) 
  self.pos = _hx_funcToField(_object.position);
  self.vel = _hx_funcToField(_object.velocity);
  self.friction = _hx_funcToField(_object.friction);
end

__hxlr_rider_ContactPoint.prototype.__class__ =  __hxlr_rider_ContactPoint

__hxlr_rider_AirPoint.new = function(_x,_y,_af) 
  local self = _hx_new(__hxlr_rider_AirPoint.prototype)
  __hxlr_rider_AirPoint.super(self,_x,_y,_af)
  return self
end
__hxlr_rider_AirPoint.super = function(self,_x,_y,_af) 
  __hxlr_rider_ContactPoint.super(self,_x,_y);
  self.friction = _af;
end
__hxlr_rider_AirPoint.__name__ = true
__hxlr_rider_AirPoint.prototype = _hx_e();
__hxlr_rider_AirPoint.prototype.iterate = function(self,_gravity) 
  local g = (function() 
    local _hx_1
    if (_gravity == nil) then 
    _hx_1 = self.gravity; else 
    _hx_1 = _gravity; end
    return _hx_1
  end )();
  self.dir.x = ((self.pos.x - self.vel.x) * self.friction) + g.x;
  self.dir.y = ((self.pos.y - self.vel.y) * self.friction) + g.y;
  self.vel = self.pos:clone();
  self.pos = self.pos:add(self.dir);
end

__hxlr_rider_AirPoint.prototype.__class__ =  __hxlr_rider_AirPoint
__hxlr_rider_AirPoint.__super__ = __hxlr_rider_ContactPoint
setmetatable(__hxlr_rider_AirPoint.prototype,{__index=__hxlr_rider_ContactPoint.prototype})

__hxlr_rider_RiderBase.new = function(_struct,_start,_name) 
  local self = _hx_new(__hxlr_rider_RiderBase.prototype)
  __hxlr_rider_RiderBase.super(self,_struct,_start,_name)
  return self
end
__hxlr_rider_RiderBase.super = function(self,_struct,_start,_name) 
  self.enabled = true;
  self.invincible = false;
  self.crashed = false;
  self.struct = _struct;
  self.startPos = _start;
  self.startVel = __hxlr_math_geom_Point.new(self.struct.x_vel, self.struct.y_vel);
  self.gravity = __hxlr_math_geom_Point.new(self.struct.x_grav, self.struct.y_grav);
  self.name = _name;
  self:init();
end
__hxlr_rider_RiderBase.__name__ = true
__hxlr_rider_RiderBase.prototype = _hx_e();
__hxlr_rider_RiderBase.prototype.struct= nil;
__hxlr_rider_RiderBase.prototype.startPos= nil;
__hxlr_rider_RiderBase.prototype.startVel= nil;
__hxlr_rider_RiderBase.prototype.gravity= nil;
__hxlr_rider_RiderBase.prototype.contactPoints= nil;
__hxlr_rider_RiderBase.prototype.airPoints= nil;
__hxlr_rider_RiderBase.prototype.constraints= nil;
__hxlr_rider_RiderBase.prototype.scarves= nil;
__hxlr_rider_RiderBase.prototype.limits= nil;
__hxlr_rider_RiderBase.prototype.crashed= nil;
__hxlr_rider_RiderBase.prototype.invincible= nil;
__hxlr_rider_RiderBase.prototype.enabledFrame= nil;
__hxlr_rider_RiderBase.prototype.disableFrame= nil;
__hxlr_rider_RiderBase.prototype.enabled= nil;
__hxlr_rider_RiderBase.prototype.focusPoint= nil;
__hxlr_rider_RiderBase.prototype.name= nil;
__hxlr_rider_RiderBase.prototype.init = function(self) 
  self.contactPoints = Array.new();
  local _g = 0;
  local _g1 = self.struct.contactPoints;
  while (_g < _g1.length) do 
    local dot = _g1[_g];
    _g = _g + 1;
    self.contactPoints:push(__hxlr_rider_ContactPoint.new(dot.x, dot.y, dot.fr));
  end;
  self.airPoints = Array.new();
  local _g = 0;
  local _g1 = self.struct.scarfPoints;
  while (_g < _g1.length) do 
    local dot = _g1[_g];
    _g = _g + 1;
    self.airPoints:push(__hxlr_rider_AirPoint.new(dot.x, dot.y, dot.fr));
  end;
  local _g = 0;
  local _g1 = self.contactPoints;
  while (_g < _g1.length) do 
    local point = _g1[_g];
    _g = _g + 1;
    local point1 = point.pos;
    point1.x = point1.x * self.struct.scale;
    local point1 = point.pos;
    point1.y = point1.y * self.struct.scale;
    local point1 = point.pos;
    point1.x = point1.x + self.startPos.x;
    local point1 = point.pos;
    point1.y = point1.y + self.startPos.y;
    point.vel.x = point.pos.x - self.startVel.x;
    point.vel.y = point.pos.y;
  end;
  local _g = 0;
  local _g1 = self.airPoints;
  while (_g < _g1.length) do 
    local point = _g1[_g];
    _g = _g + 1;
    local point1 = point.pos;
    point1.x = point1.x * self.struct.scale;
    local point1 = point.pos;
    point1.y = point1.y * self.struct.scale;
    local point1 = point.pos;
    point1.x = point1.x + self.startPos.x;
    local point1 = point.pos;
    point1.y = point1.y + self.startPos.y;
    point.vel.x = point.pos.x - self.startVel.x;
    point.vel.y = point.pos.y;
  end;
  self.constraints = Array.new();
  local _g = 0;
  local _g1 = self.struct.bones;
  while (_g < _g1.length) do 
    local edge = _g1[_g];
    _g = _g + 1;
    local stick = __hxlr_rider_Stick.new(self.contactPoints[edge.a], self.contactPoints[edge.b], edge.type, self);
    stick.crashable = _hx_funcToField(edge.crashable);
    self.constraints:push(stick);
  end;
  self.scarves = Array.new();
  local _g = 0;
  local _g1 = self.airPoints.length;
  while (_g < _g1) do 
    _g = _g + 1;
    local point = _g - 1;
    if (self.airPoints[point + 1] == nil) then 
      break;
    end;
    self.scarves:push(__hxlr_rider_Stick.new(self.airPoints[point], self.airPoints[point + 1], "SCARF", self));
  end;
  self.scarves:unshift(__hxlr_rider_Stick.new(self.contactPoints[self.struct.scarfAnchor], self.airPoints[0], "SCARF", self));
  self.limits = _hx_funcToField(self.struct.limits);
  self.focusPoint = self.contactPoints[self.struct.camera];
  self:set_crashed(false);
end
__hxlr_rider_RiderBase.prototype.reset = function(self) 
end
__hxlr_rider_RiderBase.prototype.step = function(self) 
end
__hxlr_rider_RiderBase.prototype.iterate = function(self) 
end
__hxlr_rider_RiderBase.prototype.checkLimits = function(self) 
end
__hxlr_rider_RiderBase.prototype.constrain = function(self) 
end
__hxlr_rider_RiderBase.prototype.constrainScarf = function(self) 
end
__hxlr_rider_RiderBase.prototype.collide = function(self) 
  local _g = 0;
  local _g1 = self.contactPoints;
  while (_g < _g1.length) do 
    local point = _g1[_g];
    _g = _g + 1;
    local gridPos = __hxlr_engine_Cell.getInfo(point.pos.x, point.pos.y);
    local _g = -1;
    while (_g < 2) do 
      _g = _g + 1;
      local _x = _g - 1;
      local _g = -1;
      local _hx_continue_3 = false;
      while (_g < 2) do repeat 
        _g = _g + 1;
        local _y = _g - 1;
        local key = Std.string(Std.string(Std.string("x") .. Std.string((gridPos.x + _x))) .. Std.string("y")) .. Std.string((gridPos.y + _y));
        local ret = __hxlr_engine_Grid.registry.h[key];
        if (ret == __haxe_ds_StringMap.tnull) then 
          ret = nil;
        end;
        if (ret == nil) then 
          break;
        else
          local ret = __hxlr_engine_Grid.registry.h[key];
          if (ret == __haxe_ds_StringMap.tnull) then 
            ret = nil;
          end;
          local register = ret;
          local _g = 0;
          local _g1 = register.collidable;
          local _hx_continue_4 = false;
          while (_g < _g1.length) do repeat 
            local line = _g1[_g];
            _g = _g + 1;
            if (line == nil) then 
              break;
            end;
            line:collide(point);until true
            if _hx_continue_4 then 
            _hx_continue_4 = false;
            break;
            end;
            
          end;
        end;until true
        if _hx_continue_3 then 
        _hx_continue_3 = false;
        break;
        end;
        
      end;
    end;
  end;
end
__hxlr_rider_RiderBase.prototype.renderRider = function(self) 
end
__hxlr_rider_RiderBase.prototype.set_crashed = function(self,_value) 
  if (self.invincible) then 
    self.crashed = nil do return self.crashed end;
  end;
  self.crashed = _value do return self.crashed end
end

__hxlr_rider_RiderBase.prototype.__class__ =  __hxlr_rider_RiderBase

__hxlr_rider_Stick.new = function(_a,_b,_type,_rider) 
  local self = _hx_new(__hxlr_rider_Stick.prototype)
  __hxlr_rider_Stick.super(self,_a,_b,_type,_rider)
  return self
end
__hxlr_rider_Stick.super = function(self,_a,_b,_type,_rider) 
  self.crashable = false;
  self.broken = false;
  self.breakable = false;
  self.enabled = true;
  self.a = _a;
  self.b = _b;
  self:set_type(_type);
  self.rider = _rider;
  self.endurance = (0.057 * self.restLength) * 0.5;
end
__hxlr_rider_Stick.__name__ = true
__hxlr_rider_Stick.prototype = _hx_e();
__hxlr_rider_Stick.prototype.a= nil;
__hxlr_rider_Stick.prototype.b= nil;
__hxlr_rider_Stick.prototype.restLength= nil;
__hxlr_rider_Stick.prototype.enabled= nil;
__hxlr_rider_Stick.prototype.breakable= nil;
__hxlr_rider_Stick.prototype.broken= nil;
__hxlr_rider_Stick.prototype.crashable= nil;
__hxlr_rider_Stick.prototype.endurance= nil;
__hxlr_rider_Stick.prototype.constrain= nil;
__hxlr_rider_Stick.prototype.type= nil;
__hxlr_rider_Stick.prototype.rider= nil;
__hxlr_rider_Stick.prototype.satisfy = function(self,_crashed) 
  if (not self.enabled) then 
    do return end;
  end;
  local result = self:constrain(_crashed);
  if (self.breakable) then 
    self.broken = result;
  end;
  if (self.crashable) then 
    self.rider:set_crashed(result);
  end;
end
__hxlr_rider_Stick.prototype.noConstrain = function(self,_crashed) 
  do return _crashed end
end
__hxlr_rider_Stick.prototype.standard = function(self,_crashed) 
  local xDist = self.a.pos.x - self.b.pos.x;
  local yDist = self.a.pos.y - self.b.pos.y;
  local dist = _G.math.sqrt((xDist * xDist) + (yDist * yDist));
  local adjust = 0;
  if (dist ~= 0) then 
    adjust = ((dist - self.restLength) / dist) * 0.5;
  end;
  if (self.crashable or self.breakable) then 
    if (not self.rider.invincible) then 
      if (((adjust > self.endurance) or _crashed) or self.broken) then 
        do return true end;
      end;
    end;
  end;
  local xAdjust = xDist * adjust;
  local yAdjust = yDist * adjust;
  self.a.pos.x = self.a.pos.x - xAdjust;
  self.a.pos.y = self.a.pos.y - yAdjust;
  self.b.pos.x = self.b.pos.x + xAdjust;
  self.b.pos.y = self.b.pos.y + yAdjust;
  do return _crashed end
end
__hxlr_rider_Stick.prototype.repell = function(self,_crashed) 
  local xDist = self.a.pos.x - self.b.pos.x;
  local yDist = self.a.pos.y - self.b.pos.y;
  local dist = _G.math.sqrt((xDist * xDist) + (yDist * yDist));
  if (dist < self.restLength) then 
    local adjust = 0;
    if (dist ~= 0) then 
      adjust = ((dist - self.restLength) / dist) * 0.5;
    end;
    if (self.crashable or self.breakable) then 
      if (not self.rider.invincible) then 
        if (((adjust > self.endurance) or _crashed) or self.broken) then 
          do return true end;
        end;
      end;
    end;
    local xAdjust = xDist * adjust;
    local yAdjust = yDist * adjust;
    self.a.pos.x = self.a.pos.x - xAdjust;
    self.a.pos.y = self.a.pos.y - yAdjust;
    self.b.pos.x = self.b.pos.x + xAdjust;
    self.b.pos.y = self.b.pos.y + yAdjust;
  end;
  do return _crashed end
end
__hxlr_rider_Stick.prototype.attract = function(self,_crashed) 
  local xDist = self.a.pos.x - self.b.pos.x;
  local yDist = self.a.pos.y - self.b.pos.y;
  local dist = _G.math.sqrt((xDist * xDist) + (yDist * yDist));
  if (dist > self.restLength) then 
    local adjust = 0;
    if (dist ~= 0) then 
      adjust = ((dist - self.restLength) / dist) * 0.5;
    end;
    if (self.crashable or self.breakable) then 
      if (not self.rider.invincible) then 
        if (((adjust > self.endurance) or _crashed) or self.broken) then 
          do return true end;
        end;
      end;
    end;
    local xAdjust = xDist * adjust;
    local yAdjust = yDist * adjust;
    self.a.pos.x = self.a.pos.x - xAdjust;
    self.a.pos.y = self.a.pos.y - yAdjust;
    self.b.pos.x = self.b.pos.x + xAdjust;
    self.b.pos.y = self.b.pos.y + yAdjust;
  end;
  do return _crashed end
end
__hxlr_rider_Stick.prototype.scarf = function(self,_crashed) 
  local xDist = self.a.pos.x - self.b.pos.x;
  local yDist = self.a.pos.y - self.b.pos.y;
  local dist = _G.math.sqrt((xDist * xDist) + (yDist * yDist));
  local adjust = nil;
  if (dist == 0) then 
    adjust = 0;
  else
    adjust = ((dist - self.restLength) / dist) * 0.5;
  end;
  local xAdjust = xDist * adjust;
  local yAdjust = yDist * adjust;
  self.b.pos.x = self.b.pos.x + xAdjust;
  self.b.pos.y = self.b.pos.y + yAdjust;
  do return _crashed end
end
__hxlr_rider_Stick.prototype.set_type = function(self,value) 
  self:setRestLength();
  if ((value == "REPELL") or (value == "ATTRACT")) then 
    local tmp = self;
    tmp.restLength = tmp.restLength * 0.5;
  end;
  local value1 = value;
  if (value1) == "REPELL" then 
    self.constrain = _hx_funcToField(_hx_bind(self,self.repell));
  elseif (value1) == "SCARF" then 
    self.constrain = _hx_funcToField(_hx_bind(self,self.scarf));
  elseif (value1) == "STANDARD" then 
    self.constrain = _hx_funcToField(_hx_bind(self,self.standard));else
  self.constrain = _hx_funcToField(_hx_bind(self,self.noConstrain)); end;
  self.type = value do return self.type end
end
__hxlr_rider_Stick.prototype.setRestLength = function(self) 
  local x = self.a.pos.x - self.b.pos.x;
  local y = self.a.pos.y - self.b.pos.y;
  self.restLength = _G.math.sqrt((x * x) + (y * y));
end

__hxlr_rider_Stick.prototype.__class__ =  __hxlr_rider_Stick

__lua_Boot.new = {}
__lua_Boot.__name__ = true
__lua_Boot.__instanceof = function(o,cl) 
  if (cl == nil) then 
    do return false end;
  end;
  local cl1 = cl;
  if (cl1) == Array then 
    do return __lua_Boot.isArray(o) end;
  elseif (cl1) == Bool then 
    do return _G.type(o) == "boolean" end;
  elseif (cl1) == Dynamic then 
    do return o ~= nil end;
  elseif (cl1) == Float then 
    do return _G.type(o) == "number" end;
  elseif (cl1) == Int then 
    if (_G.type(o) == "number") then 
      do return _hx_bit_clamp(o) == o end;
    else
      do return false end;
    end;
  elseif (cl1) == String then 
    do return _G.type(o) == "string" end;
  elseif (cl1) == _G.table then 
    do return _G.type(o) == "table" end;
  elseif (cl1) == __lua_Thread then 
    do return _G.type(o) == "thread" end;
  elseif (cl1) == __lua_UserData then 
    do return _G.type(o) == "userdata" end;else
  if (((o ~= nil) and (_G.type(o) == "table")) and (_G.type(cl) == "table")) then 
    local tmp;
    if (__lua_Boot.__instanceof(o, Array)) then 
      tmp = Array;
    else
      if (__lua_Boot.__instanceof(o, String)) then 
        tmp = String;
      else
        local cl = o.__class__;
        tmp = (function() 
          local _hx_1
          if (cl ~= nil) then 
          _hx_1 = cl; else 
          _hx_1 = nil; end
          return _hx_1
        end )();
      end;
    end;
    if (__lua_Boot.extendsOrImplements(tmp, cl)) then 
      do return true end;
    end;
    if ((function() 
      local _hx_2
      if (cl == Class) then 
      _hx_2 = o.__name__ ~= nil; else 
      _hx_2 = false; end
      return _hx_2
    end )()) then 
      do return true end;
    end;
    if ((function() 
      local _hx_3
      if (cl == Enum) then 
      _hx_3 = o.__ename__ ~= nil; else 
      _hx_3 = false; end
      return _hx_3
    end )()) then 
      do return true end;
    end;
    do return o.__enum__ == cl end;
  else
    do return false end;
  end; end;
end
__lua_Boot.isArray = function(o) 
  if (_G.type(o) == "table") then 
    if ((o.__enum__ == nil) and (_G.getmetatable(o) ~= nil)) then 
      do return _G.getmetatable(o).__index == Array.prototype end;
    else
      do return false end;
    end;
  else
    do return false end;
  end;
end
__lua_Boot.dateStr = function(date) 
  local m = date:getMonth() + 1;
  local d = date:getDate();
  local h = date:getHours();
  local mi = date:getMinutes();
  local s = date:getSeconds();
  do return Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(date:getFullYear()) .. Std.string("-")) .. Std.string(((function() 
    local _hx_1
    if (m < 10) then 
    _hx_1 = Std.string("0") .. Std.string(m); else 
    _hx_1 = Std.string("") .. Std.string(m); end
    return _hx_1
  end )()))) .. Std.string("-")) .. Std.string(((function() 
    local _hx_2
    if (d < 10) then 
    _hx_2 = Std.string("0") .. Std.string(d); else 
    _hx_2 = Std.string("") .. Std.string(d); end
    return _hx_2
  end )()))) .. Std.string(" ")) .. Std.string(((function() 
    local _hx_3
    if (h < 10) then 
    _hx_3 = Std.string("0") .. Std.string(h); else 
    _hx_3 = Std.string("") .. Std.string(h); end
    return _hx_3
  end )()))) .. Std.string(":")) .. Std.string(((function() 
    local _hx_4
    if (mi < 10) then 
    _hx_4 = Std.string("0") .. Std.string(mi); else 
    _hx_4 = Std.string("") .. Std.string(mi); end
    return _hx_4
  end )()))) .. Std.string(":")) .. Std.string(((function() 
    local _hx_5
    if (s < 10) then 
    _hx_5 = Std.string("0") .. Std.string(s); else 
    _hx_5 = Std.string("") .. Std.string(s); end
    return _hx_5
  end )())) end;
end
__lua_Boot.extendsOrImplements = function(cl1,cl2) 
  if ((cl1 == nil) or (cl2 == nil)) then 
    do return false end;
  else
    if (cl1 == cl2) then 
      do return true end;
    else
      if (cl1.__interfaces__ ~= nil) then 
        local intf = cl1.__interfaces__;
        local _g = 1;
        local _g1 = _hx_table.maxn(intf) + 1;
        while (_g < _g1) do 
          _g = _g + 1;
          local i = _g - 1;
          if (__lua_Boot.extendsOrImplements(intf[i], cl2)) then 
            do return true end;
          end;
        end;
      end;
    end;
  end;
  do return __lua_Boot.extendsOrImplements(cl1.__super__, cl2) end;
end

__lua_UserData.new = {}
__lua_UserData.__name__ = true

__lua_Thread.new = {}
__lua_Thread.__name__ = true
-- require this for lua 5.1
pcall(require, 'bit')
if bit then
  _hx_bit_raw = bit
  _hx_bit = setmetatable({}, { __index = _hx_bit_raw });
else
  _hx_bit_raw = _G.require('bit32')
  _hx_bit = setmetatable({}, { __index = _hx_bit_raw });
  -- lua 5.2 weirdness
  _hx_bit.bnot = function(...) return _hx_bit_clamp(_hx_bit_raw.bnot(...)) end;
  _hx_bit.bxor = function(...) return _hx_bit_clamp(_hx_bit_raw.bxor(...)) end;
end
-- see https://github.com/HaxeFoundation/haxe/issues/8849
_hx_bit.bor = function(...) return _hx_bit_clamp(_hx_bit_raw.bor(...)) end;
_hx_bit.band = function(...) return _hx_bit_clamp(_hx_bit_raw.band(...)) end;
_hx_bit.arshift = function(...) return _hx_bit_clamp(_hx_bit_raw.arshift(...)) end;

if _hx_bit_raw then
    _hx_bit_clamp = function(v)
    if v <= 2147483647 and v >= -2147483648 then
        if v > 0 then return _G.math.floor(v)
        else return _G.math.ceil(v)
        end
    end
    if v > 2251798999999999 then v = v*2 end;
    if (v ~= v or math.abs(v) == _G.math.huge) then return nil end
    return _hx_bit_raw.band(v, 2147483647 ) - math.abs(_hx_bit_raw.band(v, 2147483648))
    end
else
    _hx_bit_clamp = function(v)
        if v < -2147483648 then
            return -2147483648
        elseif v > 2147483647 then
            return 2147483647
        elseif v > 0 then
            return _G.math.floor(v)
        else
            return _G.math.ceil(v)
        end
    end
end;



_hx_array_mt.__index = Array.prototype

local _hx_static_init = function()
  
  String.__name__ = true;
  Array.__name__ = true;__haxe_ds_StringMap.tnull = ({});
  
  __hxlr_Constants.minLineSize = 10;
  
  __hxlr_Constants.minSnapDistance = 10;
  
  __hxlr_Constants.x_gravity = 0;
  
  __hxlr_Constants.y_gravity = 0.175;
  
  __hxlr_Constants.x_velocity = 0.4;
  
  __hxlr_Constants.y_velocity = 0;
  
  __hxlr_engine_Cell.size = 14;
  
  __hxlr_engine_Cell.cellList = Array.new();
  
  __lua_Boot.MAXSTACKSIZE = 1000;
  
  
end

_hx_bind = function(o,m)
  if m == nil then return nil end;
  local f;
  if o._hx__closures == nil then
    _G.rawset(o, '_hx__closures', {});
  else
    f = o._hx__closures[m];
  end
  if (f == nil) then
    f = function(...) return m(o, ...) end;
    o._hx__closures[m] = f;
  end
  return f;
end

_hx_funcToField = function(f)
  if type(f) == 'function' then
    return function(self,...)
      return f(...)
    end
  else
    return f
  end
end

_hx_print = print or (function() end)

_hx_table = {}
_hx_table.pack = _G.table.pack or function(...)
    return {...}
end
_hx_table.unpack = _G.table.unpack or _G.unpack
_hx_table.maxn = _G.table.maxn or function(t)
  local maxn=0;
  for i in pairs(t) do
    maxn=type(i)=='number'and i>maxn and i or maxn
  end
  return maxn
end;

_hx_wrap_if_string_field = function(o, fld)
  if _G.type(o) == 'string' then
    if fld == 'length' then
      return _G.string.len(o)
    else
      return String.prototype[fld]
    end
  else
    return o[fld]
  end
end

_hx_static_init();
