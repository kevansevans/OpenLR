# Generated by Haxe 4.1.5
# coding: utf-8
import sys

import math as python_lib_Math
import math as Math
import inspect as python_lib_Inspect
import sys as python_lib_Sys
import functools as python_lib_Functools
import traceback as python_lib_Traceback
from datetime import datetime as python_lib_datetime_Datetime
from datetime import timezone as python_lib_datetime_Timezone
from io import StringIO as python_lib_io_StringIO


class _hx_AnonObject:
    _hx_disable_getattr = False
    def __init__(self, fields):
        self.__dict__ = fields
    def __repr__(self):
        return repr(self.__dict__)
    def __contains__(self, item):
        return item in self.__dict__
    def __getitem__(self, item):
        return self.__dict__[item]
    def __getattr__(self, name):
        if (self._hx_disable_getattr):
            raise AttributeError('field does not exist')
        else:
            return None
    def _hx_hasattr(self,field):
        self._hx_disable_getattr = True
        try:
            getattr(self, field)
            self._hx_disable_getattr = False
            return True
        except AttributeError:
            self._hx_disable_getattr = False
            return False



class Enum:
    _hx_class_name = "Enum"
    __slots__ = ("tag", "index", "params")
    _hx_fields = ["tag", "index", "params"]
    _hx_methods = ["__str__"]

    def __init__(self,tag,index,params):
        self.tag = tag
        self.index = index
        self.params = params

    def __str__(self):
        if (self.params is None):
            return self.tag
        else:
            return self.tag + '(' + (', '.join(str(v) for v in self.params)) + ')'

Enum._hx_class = Enum


class Class: pass


class Date:
    _hx_class_name = "Date"
    __slots__ = ("date", "dateUTC")
    _hx_fields = ["date", "dateUTC"]
    _hx_methods = ["toString"]
    _hx_statics = ["makeLocal"]

    def __init__(self,year,month,day,hour,_hx_min,sec):
        self.dateUTC = None
        if (year < python_lib_datetime_Datetime.min.year):
            year = python_lib_datetime_Datetime.min.year
        if (day == 0):
            day = 1
        self.date = Date.makeLocal(python_lib_datetime_Datetime(year,(month + 1),day,hour,_hx_min,sec,0))
        self.dateUTC = self.date.astimezone(python_lib_datetime_Timezone.utc)

    def toString(self):
        return self.date.strftime("%Y-%m-%d %H:%M:%S")

    @staticmethod
    def makeLocal(date):
        try:
            return date.astimezone()
        except BaseException as _g:
            None
            tzinfo = python_lib_datetime_Datetime.now(python_lib_datetime_Timezone.utc).astimezone().tzinfo
            return date.replace(**python__KwArgs_KwArgs_Impl_.fromT(_hx_AnonObject({'tzinfo': tzinfo})))

Date._hx_class = Date


class Reflect:
    _hx_class_name = "Reflect"
    __slots__ = ()
    _hx_statics = ["field", "setField", "isFunction"]

    @staticmethod
    def field(o,field):
        return python_Boot.field(o,field)

    @staticmethod
    def setField(o,field,value):
        setattr(o,(("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field)),value)

    @staticmethod
    def isFunction(f):
        if (not ((python_lib_Inspect.isfunction(f) or python_lib_Inspect.ismethod(f)))):
            return python_Boot.hasField(f,"func_code")
        else:
            return True
Reflect._hx_class = Reflect


class Std:
    _hx_class_name = "Std"
    __slots__ = ()
    _hx_statics = ["isOfType", "string"]

    @staticmethod
    def isOfType(v,t):
        if ((v is None) and ((t is None))):
            return False
        if (t is None):
            return False
        if (t == Dynamic):
            return (v is not None)
        isBool = isinstance(v,bool)
        if ((t == Bool) and isBool):
            return True
        if ((((not isBool) and (not (t == Bool))) and (t == Int)) and isinstance(v,int)):
            return True
        vIsFloat = isinstance(v,float)
        tmp = None
        tmp1 = None
        if (((not isBool) and vIsFloat) and (t == Int)):
            f = v
            tmp1 = (((f != Math.POSITIVE_INFINITY) and ((f != Math.NEGATIVE_INFINITY))) and (not python_lib_Math.isnan(f)))
        else:
            tmp1 = False
        if tmp1:
            tmp1 = None
            try:
                tmp1 = int(v)
            except BaseException as _g:
                None
                tmp1 = None
            tmp = (v == tmp1)
        else:
            tmp = False
        if ((tmp and ((v <= 2147483647))) and ((v >= -2147483648))):
            return True
        if (((not isBool) and (t == Float)) and isinstance(v,(float, int))):
            return True
        if (t == str):
            return isinstance(v,str)
        isEnumType = (t == Enum)
        if ((isEnumType and python_lib_Inspect.isclass(v)) and hasattr(v,"_hx_constructs")):
            return True
        if isEnumType:
            return False
        isClassType = (t == Class)
        if ((((isClassType and (not isinstance(v,Enum))) and python_lib_Inspect.isclass(v)) and hasattr(v,"_hx_class_name")) and (not hasattr(v,"_hx_constructs"))):
            return True
        if isClassType:
            return False
        tmp = None
        try:
            tmp = isinstance(v,t)
        except BaseException as _g:
            None
            tmp = False
        if tmp:
            return True
        if python_lib_Inspect.isclass(t):
            cls = t
            loop = None
            def _hx_local_1(intf):
                f = (intf._hx_interfaces if (hasattr(intf,"_hx_interfaces")) else [])
                if (f is not None):
                    _g = 0
                    while (_g < len(f)):
                        i = (f[_g] if _g >= 0 and _g < len(f) else None)
                        _g = (_g + 1)
                        if (i == cls):
                            return True
                        else:
                            l = loop(i)
                            if l:
                                return True
                    return False
                else:
                    return False
            loop = _hx_local_1
            currentClass = v.__class__
            result = False
            while (currentClass is not None):
                if loop(currentClass):
                    result = True
                    break
                currentClass = python_Boot.getSuperClass(currentClass)
            return result
        else:
            return False

    @staticmethod
    def string(s):
        return python_Boot.toString1(s,"")
Std._hx_class = Std


class Float: pass


class Int: pass


class Bool: pass


class Dynamic: pass


class StringBuf:
    _hx_class_name = "StringBuf"
    __slots__ = ("b",)
    _hx_fields = ["b"]
    _hx_methods = ["get_length"]

    def __init__(self):
        self.b = python_lib_io_StringIO()

    def get_length(self):
        pos = self.b.tell()
        self.b.seek(0,2)
        _hx_len = self.b.tell()
        self.b.seek(pos,0)
        return _hx_len

StringBuf._hx_class = StringBuf


class StringTools:
    _hx_class_name = "StringTools"
    __slots__ = ()
    _hx_statics = ["lpad"]

    @staticmethod
    def lpad(s,c,l):
        if (len(c) <= 0):
            return s
        buf = StringBuf()
        l = (l - len(s))
        while (buf.get_length() < l):
            s1 = Std.string(c)
            buf.b.write(s1)
        s1 = Std.string(s)
        buf.b.write(s1)
        return buf.b.getvalue()
StringTools._hx_class = StringTools


class haxe_IMap:
    _hx_class_name = "haxe.IMap"
    __slots__ = ()
haxe_IMap._hx_class = haxe_IMap


class haxe_ds_StringMap:
    _hx_class_name = "haxe.ds.StringMap"
    __slots__ = ("h",)
    _hx_fields = ["h"]
    _hx_methods = ["keys"]
    _hx_interfaces = [haxe_IMap]

    def __init__(self):
        self.h = dict()

    def keys(self):
        return python_HaxeIterator(iter(self.h.keys()))

haxe_ds_StringMap._hx_class = haxe_ds_StringMap


class python_HaxeIterator:
    _hx_class_name = "python.HaxeIterator"
    __slots__ = ("it", "x", "has", "checked")
    _hx_fields = ["it", "x", "has", "checked"]
    _hx_methods = ["next", "hasNext"]

    def __init__(self,it):
        self.checked = False
        self.has = False
        self.x = None
        self.it = it

    def next(self):
        if (not self.checked):
            self.hasNext()
        self.checked = False
        return self.x

    def hasNext(self):
        if (not self.checked):
            try:
                self.x = self.it.__next__()
                self.has = True
            except BaseException as _g:
                None
                if Std.isOfType(haxe_Exception.caught(_g).unwrap(),StopIteration):
                    self.has = False
                    self.x = None
                else:
                    raise _g
            self.checked = True
        return self.has

python_HaxeIterator._hx_class = python_HaxeIterator


class Sys:
    _hx_class_name = "Sys"
    __slots__ = ()
    _hx_statics = ["systemName"]

    @staticmethod
    def systemName():
        _g = python_lib_Sys.platform
        x = _g
        if x.startswith("linux"):
            return "Linux"
        else:
            _g1 = _g
            _hx_local_0 = len(_g1)
            if (_hx_local_0 == 5):
                if (_g1 == "win32"):
                    return "Windows"
                else:
                    raise haxe_Exception.thrown("not supported platform")
            elif (_hx_local_0 == 6):
                if (_g1 == "cygwin"):
                    return "Windows"
                elif (_g1 == "darwin"):
                    return "Mac"
                else:
                    raise haxe_Exception.thrown("not supported platform")
            else:
                raise haxe_Exception.thrown("not supported platform")
Sys._hx_class = Sys

class ValueType(Enum):
    __slots__ = ()
    _hx_class_name = "ValueType"
    _hx_constructs = ["TNull", "TInt", "TFloat", "TBool", "TObject", "TFunction", "TClass", "TEnum", "TUnknown"]

    @staticmethod
    def TClass(c):
        return ValueType("TClass", 6, (c,))

    @staticmethod
    def TEnum(e):
        return ValueType("TEnum", 7, (e,))
ValueType.TNull = ValueType("TNull", 0, ())
ValueType.TInt = ValueType("TInt", 1, ())
ValueType.TFloat = ValueType("TFloat", 2, ())
ValueType.TBool = ValueType("TBool", 3, ())
ValueType.TObject = ValueType("TObject", 4, ())
ValueType.TFunction = ValueType("TFunction", 5, ())
ValueType.TUnknown = ValueType("TUnknown", 8, ())
ValueType._hx_class = ValueType


class Type:
    _hx_class_name = "Type"
    __slots__ = ()
    _hx_statics = ["getClass", "typeof"]

    @staticmethod
    def getClass(o):
        if (o is None):
            return None
        o1 = o
        if ((o1 is not None) and ((HxOverrides.eq(o1,str) or python_lib_Inspect.isclass(o1)))):
            return None
        if isinstance(o,_hx_AnonObject):
            return None
        if hasattr(o,"_hx_class"):
            return o._hx_class
        if hasattr(o,"__class__"):
            return o.__class__
        else:
            return None

    @staticmethod
    def typeof(v):
        if (v is None):
            return ValueType.TNull
        elif isinstance(v,bool):
            return ValueType.TBool
        elif isinstance(v,int):
            return ValueType.TInt
        elif isinstance(v,float):
            return ValueType.TFloat
        elif isinstance(v,str):
            return ValueType.TClass(str)
        elif isinstance(v,list):
            return ValueType.TClass(list)
        elif (isinstance(v,_hx_AnonObject) or python_lib_Inspect.isclass(v)):
            return ValueType.TObject
        elif isinstance(v,Enum):
            return ValueType.TEnum(v.__class__)
        elif (isinstance(v,type) or hasattr(v,"_hx_class")):
            return ValueType.TClass(v.__class__)
        elif callable(v):
            return ValueType.TFunction
        else:
            return ValueType.TUnknown
Type._hx_class = Type


class haxe_Exception(Exception):
    _hx_class_name = "haxe.Exception"
    __slots__ = ("_hx___nativeStack", "_hx___skipStack", "_hx___nativeException", "_hx___previousException")
    _hx_fields = ["__nativeStack", "__skipStack", "__nativeException", "__previousException"]
    _hx_methods = ["unwrap", "get_native"]
    _hx_statics = ["caught", "thrown"]
    _hx_interfaces = []
    _hx_super = Exception


    def __init__(self,message,previous = None,native = None):
        self._hx___previousException = None
        self._hx___nativeException = None
        self._hx___nativeStack = None
        self._hx___skipStack = 0
        super().__init__(message)
        self._hx___previousException = previous
        if ((native is not None) and Std.isOfType(native,BaseException)):
            self._hx___nativeException = native
            self._hx___nativeStack = haxe_NativeStackTrace.exceptionStack()
        else:
            self._hx___nativeException = self
            infos = python_lib_Traceback.extract_stack()
            if (len(infos) != 0):
                infos.pop()
            infos.reverse()
            self._hx___nativeStack = infos

    def unwrap(self):
        return self._hx___nativeException

    def get_native(self):
        return self._hx___nativeException

    @staticmethod
    def caught(value):
        if Std.isOfType(value,haxe_Exception):
            return value
        elif Std.isOfType(value,BaseException):
            return haxe_Exception(str(value),None,value)
        else:
            return haxe_ValueException(value,None,value)

    @staticmethod
    def thrown(value):
        if Std.isOfType(value,haxe_Exception):
            return value.get_native()
        elif Std.isOfType(value,BaseException):
            return value
        else:
            e = haxe_ValueException(value)
            e._hx___skipStack = (e._hx___skipStack + 1)
            return e

haxe_Exception._hx_class = haxe_Exception


class haxe_Log:
    _hx_class_name = "haxe.Log"
    __slots__ = ()
    _hx_statics = ["formatOutput", "trace"]

    @staticmethod
    def formatOutput(v,infos):
        _hx_str = Std.string(v)
        if (infos is None):
            return _hx_str
        pstr = ((HxOverrides.stringOrNull(infos.fileName) + ":") + Std.string(infos.lineNumber))
        if (Reflect.field(infos,"customParams") is not None):
            _g = 0
            _g1 = Reflect.field(infos,"customParams")
            while (_g < len(_g1)):
                v = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                _hx_str = (("null" if _hx_str is None else _hx_str) + ((", " + Std.string(v))))
        return ((("null" if pstr is None else pstr) + ": ") + ("null" if _hx_str is None else _hx_str))

    @staticmethod
    def trace(v,infos = None):
        _hx_str = haxe_Log.formatOutput(v,infos)
        str1 = Std.string(_hx_str)
        python_Lib.printString((("" + ("null" if str1 is None else str1)) + HxOverrides.stringOrNull(python_Lib.lineEnd)))
haxe_Log._hx_class = haxe_Log


class haxe_NativeStackTrace:
    _hx_class_name = "haxe.NativeStackTrace"
    __slots__ = ()
    _hx_statics = ["saveStack", "exceptionStack"]

    @staticmethod
    def saveStack(exception):
        pass

    @staticmethod
    def exceptionStack():
        exc = python_lib_Sys.exc_info()
        if (exc[2] is not None):
            infos = python_lib_Traceback.extract_tb(exc[2])
            infos.reverse()
            return infos
        else:
            return []
haxe_NativeStackTrace._hx_class = haxe_NativeStackTrace


class haxe_ValueException(haxe_Exception):
    _hx_class_name = "haxe.ValueException"
    __slots__ = ("value",)
    _hx_fields = ["value"]
    _hx_methods = ["unwrap"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_Exception


    def __init__(self,value,previous = None,native = None):
        self.value = None
        super().__init__(Std.string(value),previous,native)
        self.value = value

    def unwrap(self):
        return self.value

haxe_ValueException._hx_class = haxe_ValueException


class haxe_format_JsonPrinter:
    _hx_class_name = "haxe.format.JsonPrinter"
    __slots__ = ("buf", "replacer", "indent", "pretty", "nind")
    _hx_fields = ["buf", "replacer", "indent", "pretty", "nind"]
    _hx_methods = ["write", "classString", "fieldsString", "quote"]
    _hx_statics = ["print"]

    def __init__(self,replacer,space):
        self.replacer = replacer
        self.indent = space
        self.pretty = (space is not None)
        self.nind = 0
        self.buf = StringBuf()

    def write(self,k,v):
        if (self.replacer is not None):
            v = self.replacer(k,v)
        _g = Type.typeof(v)
        tmp = _g.index
        if (tmp == 0):
            self.buf.b.write("null")
        elif (tmp == 1):
            _this = self.buf
            s = Std.string(v)
            _this.b.write(s)
        elif (tmp == 2):
            f = v
            v1 = (Std.string(v) if ((((f != Math.POSITIVE_INFINITY) and ((f != Math.NEGATIVE_INFINITY))) and (not python_lib_Math.isnan(f)))) else "null")
            _this = self.buf
            s = Std.string(v1)
            _this.b.write(s)
        elif (tmp == 3):
            _this = self.buf
            s = Std.string(v)
            _this.b.write(s)
        elif (tmp == 4):
            self.fieldsString(v,python_Boot.fields(v))
        elif (tmp == 5):
            self.buf.b.write("\"<fun>\"")
        elif (tmp == 6):
            c = _g.params[0]
            if (c == str):
                self.quote(v)
            elif (c == list):
                v1 = v
                _this = self.buf
                s = "".join(map(chr,[91]))
                _this.b.write(s)
                _hx_len = len(v1)
                last = (_hx_len - 1)
                _g1 = 0
                _g2 = _hx_len
                while (_g1 < _g2):
                    i = _g1
                    _g1 = (_g1 + 1)
                    if (i > 0):
                        _this = self.buf
                        s = "".join(map(chr,[44]))
                        _this.b.write(s)
                    else:
                        _hx_local_0 = self
                        _hx_local_1 = _hx_local_0.nind
                        _hx_local_0.nind = (_hx_local_1 + 1)
                        _hx_local_1
                    if self.pretty:
                        _this1 = self.buf
                        s1 = "".join(map(chr,[10]))
                        _this1.b.write(s1)
                    if self.pretty:
                        v2 = StringTools.lpad("",self.indent,(self.nind * len(self.indent)))
                        _this2 = self.buf
                        s2 = Std.string(v2)
                        _this2.b.write(s2)
                    self.write(i,(v1[i] if i >= 0 and i < len(v1) else None))
                    if (i == last):
                        _hx_local_2 = self
                        _hx_local_3 = _hx_local_2.nind
                        _hx_local_2.nind = (_hx_local_3 - 1)
                        _hx_local_3
                        if self.pretty:
                            _this3 = self.buf
                            s3 = "".join(map(chr,[10]))
                            _this3.b.write(s3)
                        if self.pretty:
                            v3 = StringTools.lpad("",self.indent,(self.nind * len(self.indent)))
                            _this4 = self.buf
                            s4 = Std.string(v3)
                            _this4.b.write(s4)
                _this = self.buf
                s = "".join(map(chr,[93]))
                _this.b.write(s)
            elif (c == haxe_ds_StringMap):
                v1 = v
                o = _hx_AnonObject({})
                k = v1.keys()
                while k.hasNext():
                    k1 = k.next()
                    value = v1.h.get(k1,None)
                    setattr(o,(("_hx_" + k1) if ((k1 in python_Boot.keywords)) else (("_hx_" + k1) if (((((len(k1) > 2) and ((ord(k1[0]) == 95))) and ((ord(k1[1]) == 95))) and ((ord(k1[(len(k1) - 1)]) != 95)))) else k1)),value)
                v1 = o
                self.fieldsString(v1,python_Boot.fields(v1))
            elif (c == Date):
                v1 = v
                self.quote(v1.toString())
            else:
                self.classString(v)
        elif (tmp == 7):
            _g1 = _g.params[0]
            i = v.index
            _this = self.buf
            s = Std.string(i)
            _this.b.write(s)
        elif (tmp == 8):
            self.buf.b.write("\"???\"")
        else:
            pass

    def classString(self,v):
        self.fieldsString(v,python_Boot.getInstanceFields(Type.getClass(v)))

    def fieldsString(self,v,fields):
        _this = self.buf
        s = "".join(map(chr,[123]))
        _this.b.write(s)
        _hx_len = len(fields)
        last = (_hx_len - 1)
        first = True
        _g = 0
        _g1 = _hx_len
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            f = (fields[i] if i >= 0 and i < len(fields) else None)
            value = Reflect.field(v,f)
            if Reflect.isFunction(value):
                continue
            if first:
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.nind
                _hx_local_0.nind = (_hx_local_1 + 1)
                _hx_local_1
                first = False
            else:
                _this = self.buf
                s = "".join(map(chr,[44]))
                _this.b.write(s)
            if self.pretty:
                _this1 = self.buf
                s1 = "".join(map(chr,[10]))
                _this1.b.write(s1)
            if self.pretty:
                v1 = StringTools.lpad("",self.indent,(self.nind * len(self.indent)))
                _this2 = self.buf
                s2 = Std.string(v1)
                _this2.b.write(s2)
            self.quote(f)
            _this3 = self.buf
            s3 = "".join(map(chr,[58]))
            _this3.b.write(s3)
            if self.pretty:
                _this4 = self.buf
                s4 = "".join(map(chr,[32]))
                _this4.b.write(s4)
            self.write(f,value)
            if (i == last):
                _hx_local_2 = self
                _hx_local_3 = _hx_local_2.nind
                _hx_local_2.nind = (_hx_local_3 - 1)
                _hx_local_3
                if self.pretty:
                    _this5 = self.buf
                    s5 = "".join(map(chr,[10]))
                    _this5.b.write(s5)
                if self.pretty:
                    v2 = StringTools.lpad("",self.indent,(self.nind * len(self.indent)))
                    _this6 = self.buf
                    s6 = Std.string(v2)
                    _this6.b.write(s6)
        _this = self.buf
        s = "".join(map(chr,[125]))
        _this.b.write(s)

    def quote(self,s):
        _this = self.buf
        s1 = "".join(map(chr,[34]))
        _this.b.write(s1)
        i = 0
        while True:
            index = i
            i = (i + 1)
            c = (-1 if ((index >= len(s))) else ord(s[index]))
            if (c == -1):
                break
            c1 = c
            if (c1 == 8):
                self.buf.b.write("\\b")
            elif (c1 == 9):
                self.buf.b.write("\\t")
            elif (c1 == 10):
                self.buf.b.write("\\n")
            elif (c1 == 12):
                self.buf.b.write("\\f")
            elif (c1 == 13):
                self.buf.b.write("\\r")
            elif (c1 == 34):
                self.buf.b.write("\\\"")
            elif (c1 == 92):
                self.buf.b.write("\\\\")
            else:
                _this = self.buf
                s1 = "".join(map(chr,[c]))
                _this.b.write(s1)
        _this = self.buf
        s = "".join(map(chr,[34]))
        _this.b.write(s)

    @staticmethod
    def print(o,replacer = None,space = None):
        printer = haxe_format_JsonPrinter(replacer,space)
        printer.write("",o)
        return printer.buf.b.getvalue()

haxe_format_JsonPrinter._hx_class = haxe_format_JsonPrinter


class haxe_io_Bytes:
    _hx_class_name = "haxe.io.Bytes"
    __slots__ = ("length", "b")
    _hx_fields = ["length", "b"]
    _hx_methods = ["getString"]

    def __init__(self,length,b):
        self.length = length
        self.b = b

    def getString(self,pos,_hx_len,encoding = None):
        tmp = (encoding is None)
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > self.length))):
            raise haxe_Exception.thrown(haxe_io_Error.OutsideBounds)
        return self.b[pos:pos+_hx_len].decode('UTF-8','replace')

haxe_io_Bytes._hx_class = haxe_io_Bytes

class haxe_io_Encoding(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.io.Encoding"
    _hx_constructs = ["UTF8", "RawNative"]
haxe_io_Encoding.UTF8 = haxe_io_Encoding("UTF8", 0, ())
haxe_io_Encoding.RawNative = haxe_io_Encoding("RawNative", 1, ())
haxe_io_Encoding._hx_class = haxe_io_Encoding

class haxe_io_Error(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.io.Error"
    _hx_constructs = ["Blocked", "Overflow", "OutsideBounds", "Custom"]

    @staticmethod
    def Custom(e):
        return haxe_io_Error("Custom", 3, (e,))
haxe_io_Error.Blocked = haxe_io_Error("Blocked", 0, ())
haxe_io_Error.Overflow = haxe_io_Error("Overflow", 1, ())
haxe_io_Error.OutsideBounds = haxe_io_Error("OutsideBounds", 2, ())
haxe_io_Error._hx_class = haxe_io_Error


class haxe_iterators_ArrayIterator:
    _hx_class_name = "haxe.iterators.ArrayIterator"
    __slots__ = ("array", "current")
    _hx_fields = ["array", "current"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,array):
        self.current = 0
        self.array = array

    def hasNext(self):
        return (self.current < len(self.array))

    def next(self):
        def _hx_local_3():
            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.current
                _hx_local_0.current = (_hx_local_1 + 1)
                return _hx_local_1
            return python_internal_ArrayImpl._get(self.array, _hx_local_2())
        return _hx_local_3()

haxe_iterators_ArrayIterator._hx_class = haxe_iterators_ArrayIterator


class haxe_iterators_ArrayKeyValueIterator:
    _hx_class_name = "haxe.iterators.ArrayKeyValueIterator"
    __slots__ = ("current", "array")
    _hx_fields = ["current", "array"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,array):
        self.current = 0
        self.array = array

    def hasNext(self):
        return (self.current < len(self.array))

    def next(self):
        def _hx_local_3():
            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.current
                _hx_local_0.current = (_hx_local_1 + 1)
                return _hx_local_1
            return _hx_AnonObject({'value': python_internal_ArrayImpl._get(self.array, self.current), 'key': _hx_local_2()})
        return _hx_local_3()

haxe_iterators_ArrayKeyValueIterator._hx_class = haxe_iterators_ArrayKeyValueIterator


class hxlr_Constants:
    _hx_class_name = "hxlr.Constants"
    __slots__ = ()
    _hx_statics = ["minLineSize", "minSnapDistance", "x_gravity", "y_gravity", "x_velocity", "y_velocity", "defaultRider"]

    def __init__(self):
        pass

    @staticmethod
    def defaultRider():
        rider = _hx_AnonObject({'scale': 0.5, 'x_grav': hxlr_Constants.x_gravity, 'y_grav': hxlr_Constants.y_gravity, 'x_vel': hxlr_Constants.x_velocity, 'y_vel': hxlr_Constants.y_velocity, 'camera': 4, 'contactPoints': [_hx_AnonObject({'x': 0, 'y': 0, 'fr': 0.8}), _hx_AnonObject({'x': 0, 'y': 10, 'fr': 0}), _hx_AnonObject({'x': 30, 'y': 10, 'fr': 0}), _hx_AnonObject({'x': 35, 'y': 0, 'fr': 0}), _hx_AnonObject({'x': 10, 'y': 0, 'fr': 0.8}), _hx_AnonObject({'x': 10, 'y': -11, 'fr': 0.8}), _hx_AnonObject({'x': 23, 'y': -10, 'fr': 0.1}), _hx_AnonObject({'x': 23, 'y': -10, 'fr': 0.1}), _hx_AnonObject({'x': 20, 'y': 10, 'fr': 0}), _hx_AnonObject({'x': 20, 'y': 10, 'fr': 0})], 'scarfPoints': [_hx_AnonObject({'x': 7, 'y': -10, 'fr': 0.9}), _hx_AnonObject({'x': 3, 'y': -10, 'fr': 0.9}), _hx_AnonObject({'x': 0, 'y': -10, 'fr': 0.9}), _hx_AnonObject({'x': -4, 'y': -10, 'fr': 0.9}), _hx_AnonObject({'x': -7, 'y': -10, 'fr': 0.9}), _hx_AnonObject({'x': -11, 'y': -10, 'fr': 0.9})], 'bones': [_hx_AnonObject({'a': 0, 'b': 1, 'type': "STANDARD", 'crashable': False}), _hx_AnonObject({'a': 1, 'b': 2, 'type': "STANDARD", 'crashable': False}), _hx_AnonObject({'a': 2, 'b': 3, 'type': "STANDARD", 'crashable': False}), _hx_AnonObject({'a': 3, 'b': 0, 'type': "STANDARD", 'crashable': False}), _hx_AnonObject({'a': 0, 'b': 2, 'type': "STANDARD", 'crashable': False}), _hx_AnonObject({'a': 3, 'b': 1, 'type': "STANDARD", 'crashable': False}), _hx_AnonObject({'a': 0, 'b': 4, 'type': "STANDARD", 'crashable': True}), _hx_AnonObject({'a': 1, 'b': 4, 'type': "STANDARD", 'crashable': True}), _hx_AnonObject({'a': 2, 'b': 4, 'type': "STANDARD", 'crashable': True}), _hx_AnonObject({'a': 5, 'b': 4, 'type': "STANDARD", 'crashable': False}), _hx_AnonObject({'a': 5, 'b': 6, 'type': "STANDARD", 'crashable': False}), _hx_AnonObject({'a': 5, 'b': 7, 'type': "STANDARD", 'crashable': False}), _hx_AnonObject({'a': 4, 'b': 8, 'type': "STANDARD", 'crashable': False}), _hx_AnonObject({'a': 4, 'b': 9, 'type': "STANDARD", 'crashable': False}), _hx_AnonObject({'a': 5, 'b': 7, 'type': "STANDARD", 'crashable': False}), _hx_AnonObject({'a': 5, 'b': 0, 'type': "STANDARD", 'crashable': True}), _hx_AnonObject({'a': 3, 'b': 6, 'type': "STANDARD", 'crashable': True}), _hx_AnonObject({'a': 3, 'b': 7, 'type': "STANDARD", 'crashable': True}), _hx_AnonObject({'a': 8, 'b': 2, 'type': "STANDARD", 'crashable': True}), _hx_AnonObject({'a': 9, 'b': 2, 'type': "STANDARD", 'crashable': True}), _hx_AnonObject({'a': 5, 'b': 8, 'type': "REPELL", 'crashable': False}), _hx_AnonObject({'a': 5, 'b': 9, 'type': "REPELL", 'crashable': False})], 'limits': [_hx_AnonObject({'point_a': 3, 'point_b': 0, 'point_c': 1, 'point_d': 0, 'threshold': 0, 'lessThan': True})], 'scarfAnchor': 5, 'colors': [13763074, 16777215, 13763074, 16777215, 13763074, 16777215, 13763074, 16777215, 13763074, 16777215, 13763074]})
        return rider
hxlr_Constants._hx_class = hxlr_Constants


class hxlr_engine_Cell:
    _hx_class_name = "hxlr.engine.Cell"
    __slots__ = ("info", "allLines", "collidable", "intangible")
    _hx_fields = ["info", "allLines", "collidable", "intangible"]
    _hx_methods = ["addLine", "removeLine"]
    _hx_statics = ["size", "cellList", "getInfo"]

    def __init__(self,_info):
        self.info = _info
        self.allLines = list()
        self.collidable = list()
        self.intangible = list()

    def addLine(self,_line):
        if (_line in self.allLines):
            return
        _this = self.allLines
        _this.append(_line)
        if _line.tangible:
            python_internal_ArrayImpl._set(self.collidable, _line.id, _line)
        else:
            python_internal_ArrayImpl._set(self.intangible, _line.id, _line)
        if (not (self in hxlr_engine_Cell.cellList)):
            _this = hxlr_engine_Cell.cellList
            _this.append(self)

    def removeLine(self,_line):
        if (not (_line in self.allLines)):
            return
        python_internal_ArrayImpl.remove(self.allLines,_line)
        if _line.tangible:
            python_internal_ArrayImpl.remove(self.collidable,_line)
        else:
            python_internal_ArrayImpl.remove(self.intangible,_line)
        if (len(self.allLines) == 0):
            python_internal_ArrayImpl.remove(hxlr_engine_Cell.cellList,self)

    @staticmethod
    def getInfo(_x,_y):
        x = Math.floor((_x / 14))
        info = None
        try:
            info = int(x)
        except BaseException as _g:
            None
            info = None
        x = Math.floor((_y / 14))
        info1 = None
        try:
            info1 = int(x)
        except BaseException as _g:
            None
            info1 = None
        info2 = _hx_AnonObject({'x': info, 'y': info1, 'gx': (_x - ((14 * Math.floor((_x / 14))))), 'gy': (_y - ((14 * Math.floor((_y / 14)))))})
        Reflect.setField(info2,"key",((("x" + Std.string(info2.x)) + "y") + Std.string(info2.y)))
        return info2

hxlr_engine_Cell._hx_class = hxlr_engine_Cell


class hxlr_engine_Grid:
    _hx_class_name = "hxlr.engine.Grid"
    __slots__ = ("lineCount", "lineIDCount", "subTypeCount")
    _hx_fields = ["lineCount", "lineIDCount", "subTypeCount"]
    _hx_methods = ["register", "addLine", "storeLine", "deleteTrack", "unregister"]
    _hx_statics = ["registry", "lines"]

    def __init__(self):
        self.subTypeCount = list()
        self.lineIDCount = 0
        self.lineCount = 0
        hxlr_engine_Grid.registry = haxe_ds_StringMap()
        hxlr_engine_Grid.lines = list()

    def register(self,_line):
        self.addLine(_line)
        start = hxlr_engine_Cell.getInfo(_line.start.x,_line.start.y)
        end = hxlr_engine_Cell.getInfo(_line.end.x,_line.end.y)
        right = (end.x if ((_line.dx > 0)) else start.x)
        left = (start.x if ((_line.dx > 0)) else end.x)
        bottom = (end.y if ((_line.dy > 0)) else start.y)
        top = (start.y if ((_line.dy > 0)) else end.y)
        self.storeLine(_line,start)
        if (((_line.dx == 0) and ((_line.dy == 0))) or (((left == right) and ((top == bottom))))):
            return
        x = _line.start.x
        y = _line.start.y
        invDx = (1 / _line.dx)
        invDy = (1 / _line.dy)
        difX = None
        difY = None
        while True:
            if (start.x < 0):
                difX = ((14 + start.gx) if ((_line.dx > 0)) else (-14 - start.gx))
            else:
                difX = ((14 - start.gx) if ((_line.dx > 0)) else -((start.gx + 1)))
            if (start.y < 0):
                difY = ((14 + start.gy) if ((_line.dy > 0)) else (-14 - start.gy))
            else:
                difY = ((14 - start.gy) if ((_line.dy > 0)) else -((start.gy + 1)))
            if (_line.dx == 0):
                y = (y + difY)
            elif (_line.dy == 0):
                x = (x + difX)
            else:
                step = (y + (((_line.dy * difX) * invDx)))
                if (Reflect.field(Math,"fabs")((step - y)) < Reflect.field(Math,"fabs")(difY)):
                    x = (x + difX)
                    y = step
                elif (Reflect.field(Math,"fabs")((step - y)) == Reflect.field(Math,"fabs")(difY)):
                    x = (x + difX)
                    y = (y + difY)
                else:
                    x = (x + (((_line.dx * difY) * invDy)))
                    y = (y + difY)
            start = hxlr_engine_Cell.getInfo(x,y)
            if ((((start.x >= left) and ((start.x <= right))) and ((start.y >= top))) and ((start.y <= bottom))):
                self.storeLine(_line,start)
                continue
            return

    def addLine(self,_line):
        if (_line.id is None):
            _line.id = self.lineIDCount
        python_internal_ArrayImpl._set(hxlr_engine_Grid.lines, _line.id, _line)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.lineCount
        _hx_local_0.lineCount = (_hx_local_1 + 1)
        _hx_local_0.lineCount
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.lineIDCount
        _hx_local_2.lineIDCount = (_hx_local_3 + 1)
        _hx_local_2.lineIDCount
        _hx_local_4 = self.subTypeCount
        _hx_local_5 = _line.type
        _hx_local_6 = (_hx_local_4[_hx_local_5] if _hx_local_5 >= 0 and _hx_local_5 < len(_hx_local_4) else None)
        python_internal_ArrayImpl._set(_hx_local_4, _hx_local_5, (_hx_local_6 + 1))
        (_hx_local_4[_hx_local_5] if _hx_local_5 >= 0 and _hx_local_5 < len(_hx_local_4) else None)

    def storeLine(self,_line,_info):
        if (hxlr_engine_Grid.registry.h.get(Reflect.field(_info,"key"),None) is None):
            this1 = hxlr_engine_Grid.registry
            k = Reflect.field(_info,"key")
            v = hxlr_engine_Cell(_info)
            this1.h[k] = v
        hxlr_engine_Grid.registry.h.get(Reflect.field(_info,"key"),None).addLine(_line)
        _this = _line.keyList
        x = Reflect.field(_info,"key")
        _this.append(x)

    def deleteTrack(self):
        _g = 0
        _g1 = hxlr_engine_Grid.lines
        while (_g < len(_g1)):
            line = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            self.unregister(line)

    def unregister(self,_line):
        if (_line is None):
            return
        _g = 0
        _g1 = _line.keyList
        while (_g < len(_g1)):
            key = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            hxlr_engine_Grid.registry.h.get(key,None).removeLine(_line)
        _hx_local_1 = self
        _hx_local_2 = _hx_local_1.lineCount
        _hx_local_1.lineCount = (_hx_local_2 - 1)
        _hx_local_1.lineCount
        _hx_local_3 = self.subTypeCount
        _hx_local_4 = _line.type
        _hx_local_5 = (_hx_local_3[_hx_local_4] if _hx_local_4 >= 0 and _hx_local_4 < len(_hx_local_3) else None)
        python_internal_ArrayImpl._set(_hx_local_3, _hx_local_4, (_hx_local_5 - 1))
        (_hx_local_3[_hx_local_4] if _hx_local_4 >= 0 and _hx_local_4 < len(_hx_local_3) else None)
        python_internal_ArrayImpl._set(hxlr_engine_Grid.lines, _line.id, None)
    registry = None
    lines = None

hxlr_engine_Grid._hx_class = hxlr_engine_Grid


class hxlr_export_JSONFile:
    _hx_class_name = "hxlr.export.JSONFile"
    __slots__ = ()
    _hx_statics = ["save"]

    @staticmethod
    def save():
        lines = list()
        save = _hx_AnonObject({'lines': lines})
        json = haxe_format_JsonPrinter.print(save,None,None)
        return json
hxlr_export_JSONFile._hx_class = hxlr_export_JSONFile


class hxlr_file_AMF0Reader:
    _hx_class_name = "hxlr.file.AMF0Reader"
    __slots__ = ("data", "pos", "size", "header", "object", "loadedSOL")
    _hx_fields = ["data", "pos", "size", "header", "object", "loadedSOL"]
    _hx_methods = ["recursiveRead", "loadSOLTrack"]

    def __init__(self,_sol):
        self.loadedSOL = None
        self.header = None
        self.size = None
        self.object = _hx_AnonObject({})
        self.pos = 0
        self.data = _sol
        pos = self
        def _hx_local_1():
            pos.pos = (pos.pos + 1)
            return pos.pos
        self.header = ((self.data.b[self.pos] << 8) | self.data.b[_hx_local_1()])
        pos = self
        pos1 = self
        pos2 = self
        pos3 = self
        def _hx_local_3():
            pos.pos = (pos.pos + 1)
            return pos.pos
        def _hx_local_5():
            pos1.pos = (pos1.pos + 1)
            return pos1.pos
        def _hx_local_7():
            pos2.pos = (pos2.pos + 1)
            return pos2.pos
        def _hx_local_9():
            pos3.pos = (pos3.pos + 1)
            return pos3.pos
        self.size = ((((self.data.b[_hx_local_3()] << 24) | ((self.data.b[_hx_local_5()] << 16))) | ((self.data.b[_hx_local_7()] << 8))) | self.data.b[_hx_local_9()])
        if (self.size > self.data.length):
            haxe_Log.trace("Internal size value greater than file size!",_hx_AnonObject({'fileName': "src/hxlr/file/AMF0Reader.hx", 'lineNumber': 33, 'className': "hxlr.file.AMF0Reader", 'methodName': "new"}))
            return
        tcso = self
        def _hx_local_11():
            tcso.pos = (tcso.pos + 1)
            return tcso.pos
        tcso1 = self.data.getString(_hx_local_11(),4)
        if (tcso1.upper() != "TCSO"):
            haxe_Log.trace("Not a valid .sol/AMF0 file!",_hx_AnonObject({'fileName': "src/hxlr/file/AMF0Reader.hx", 'lineNumber': 39, 'className': "hxlr.file.AMF0Reader", 'methodName': "new", 'customParams': [tcso1]}))
            return
        _hx_local_12 = self
        _hx_local_13 = _hx_local_12.pos
        _hx_local_12.pos = (_hx_local_13 + 11)
        _hx_local_12.pos
        saveNameSize = self.data.b[self.pos]
        saveNameField = self
        def _hx_local_15():
            saveNameField.pos = (saveNameField.pos + 1)
            return saveNameField.pos
        saveNameField1 = self.data.getString(_hx_local_15(),saveNameSize)
        if (saveNameField1 != "savedLines"):
            haxe_Log.trace(saveNameSize,_hx_AnonObject({'fileName': "src/hxlr/file/AMF0Reader.hx", 'lineNumber': 47, 'className': "hxlr.file.AMF0Reader", 'methodName': "new", 'customParams': [saveNameField1]}))
            haxe_Log.trace("Unable to locate savedLines!",_hx_AnonObject({'fileName': "src/hxlr/file/AMF0Reader.hx", 'lineNumber': 48, 'className': "hxlr.file.AMF0Reader", 'methodName': "new"}))
            return
        _hx_local_16 = self
        _hx_local_17 = _hx_local_16.pos
        _hx_local_16.pos = (_hx_local_17 + ((saveNameSize + 4)))
        _hx_local_16.pos
        pos = self
        def _hx_local_19():
            pos.pos = (pos.pos + 1)
            return pos.pos
        trackListNameSize = ((self.data.b[self.pos] << 8) | self.data.b[_hx_local_19()])
        trackListField = self
        def _hx_local_21():
            trackListField.pos = (trackListField.pos + 1)
            return trackListField.pos
        trackListField1 = self.data.getString(_hx_local_21(),trackListNameSize)
        if (trackListField1 != "trackList"):
            haxe_Log.trace(trackListNameSize,_hx_AnonObject({'fileName': "src/hxlr/file/AMF0Reader.hx", 'lineNumber': 57, 'className': "hxlr.file.AMF0Reader", 'methodName': "new", 'customParams': [trackListField1]}))
            haxe_Log.trace("Unable to locate trackList!",_hx_AnonObject({'fileName': "src/hxlr/file/AMF0Reader.hx", 'lineNumber': 58, 'className': "hxlr.file.AMF0Reader", 'methodName': "new"}))
            return
        self.loadedSOL = _hx_AnonObject({'trackList': []})
        pos = self
        def _hx_local_23():
            pos.pos = (pos.pos + trackListNameSize)
            return pos.pos
        self.recursiveRead(self.data.b[_hx_local_23()])

    def recursiveRead(self,_code):
        tmp = (_code == 8)

    def loadSOLTrack(self,_index):
        return _hx_AnonObject({})

hxlr_file_AMF0Reader._hx_class = hxlr_file_AMF0Reader


class hxlr_lines_LineBase:
    _hx_class_name = "hxlr.lines.LineBase"
    __slots__ = ("id", "start", "end", "type", "tangible", "keyList", "gfxEnd", "shifted", "dx", "dy", "C", "distance", "invSqrDistance", "invDistance", "nx", "ny", "zone", "limType", "limStart", "limEnd", "limValue", "prevLine", "nextLine")
    _hx_fields = ["id", "start", "end", "type", "tangible", "keyList", "gfxEnd", "shifted", "dx", "dy", "C", "distance", "invSqrDistance", "invDistance", "nx", "ny", "zone", "limType", "limStart", "limEnd", "limValue", "prevLine", "nextLine"]
    _hx_methods = ["calculateConstants", "setLim", "collide", "toSaveObject"]

    def __init__(self,_start,_end,_shift,_lim = None):
        if (_lim is None):
            _lim = 0
        self.nextLine = None
        self.prevLine = None
        self.ny = None
        self.nx = None
        self.invDistance = None
        self.invSqrDistance = None
        self.distance = None
        self.C = None
        self.dy = None
        self.dx = None
        self.shifted = None
        self.gfxEnd = None
        self.keyList = None
        self.type = None
        self.id = None
        self.limValue = 0
        self.limEnd = 0
        self.limStart = 0
        self.limType = 0
        self.zone = 10
        self.tangible = False
        self.start = _start
        self.end = _end
        self.gfxEnd = hxlr_math_geom_Point((self.end.x - self.start.x),(self.end.y - self.start.y))
        self.shifted = _shift
        self.keyList = list()
        self.calculateConstants()
        self.setLim(_lim)

    def calculateConstants(self):
        self.dx = (self.end.x - self.start.x)
        self.dy = (self.end.y - self.start.y)
        self.C = ((self.dy * self.start.x) - ((self.dx * self.start.y)))
        _loc2 = (Math.pow(self.dx,2) + Math.pow(self.dy,2))
        self.invSqrDistance = (1 / _loc2)
        self.distance = (Math.NaN if ((_loc2 < 0)) else python_lib_Math.sqrt(_loc2))
        self.invDistance = (1 / self.distance)
        self.nx = ((self.dy * self.invDistance) * ((1 if (self.shifted) else -1)))
        self.ny = ((self.dx * self.invDistance) * ((-1 if (self.shifted) else 1)))
        b = (self.zone / self.distance)
        self.limValue = (0.25 if (python_lib_Math.isnan(0.25)) else (b if (python_lib_Math.isnan(b)) else min(0.25,b)))

    def setLim(self,_limMode):
        _limMode1 = _limMode
        if (_limMode1 == 0):
            self.limStart = 0
            self.limEnd = 1
        elif (_limMode1 == 1):
            self.limStart = -self.limValue
            self.limEnd = 1
        elif (_limMode1 == 2):
            self.limStart = 0
            self.limEnd = (1 + self.limValue)
        elif (_limMode1 == 3):
            self.limStart = -self.limValue
            self.limEnd = (1 + self.limValue)
        else:
            pass
        self.limType = _limMode

    def collide(self,_point):
        pass

    def toSaveObject(self):
        save = None
        _g = self.limType
        if ((_g == 3) or ((_g == 1))):
            save = True
        elif ((_g == 2) or ((_g == 0))):
            save = False
        else:
            save = False
        save1 = None
        _g = self.limType
        if ((_g == 1) or ((_g == 0))):
            save1 = False
        elif ((_g == 3) or ((_g == 2))):
            save1 = True
        else:
            save1 = False
        save2 = _hx_AnonObject({'id': self.id, 'type': self.type, 'x1': self.start.x, 'y1': self.start.y, 'x2': self.end.x, 'y2': self.end.y, 'flipped': self.shifted, 'leftExtended': save, 'rightExtended': save1})
        return save2

hxlr_lines_LineBase._hx_class = hxlr_lines_LineBase


class hxlr_lines_Accel(hxlr_lines_LineBase):
    _hx_class_name = "hxlr.lines.Accel"
    __slots__ = ("accConst", "accx", "accy")
    _hx_fields = ["accConst", "accx", "accy"]
    _hx_methods = ["calculateConstants", "collide"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = hxlr_lines_LineBase


    def __init__(self,_start,_end,_shift):
        self.accy = None
        self.accx = None
        self.accConst = 0.1
        super().__init__(_start,_end,_shift)
        self.type = 1
        self.tangible = True

    def calculateConstants(self):
        super().calculateConstants()
        self.accx = ((self.ny * self.accConst) * ((1 if (self.shifted) else -1)))
        self.accy = ((self.nx * self.accConst) * ((-1 if (self.shifted) else 1)))

    def collide(self,_point):
        _loc5 = (_point.pos.x - self.start.x)
        _loc6 = (_point.pos.y - self.start.y)
        _loc4 = ((self.nx * _loc5) + ((self.ny * _loc6)))
        _loc7 = ((((_loc5 * self.dx) + ((_loc6 * self.dy)))) * self.invSqrDistance)
        if (((_point.dir.x * self.nx) + ((_point.dir.y * self.ny))) > 0):
            if ((((_loc4 > 0) and ((_loc4 < self.zone))) and ((_loc7 >= self.limStart))) and ((_loc7 <= self.limEnd))):
                _hx_local_0 = _point.pos
                _hx_local_1 = _hx_local_0.x
                _hx_local_0.x = (_hx_local_1 - ((_loc4 * self.nx)))
                _hx_local_0.x
                _hx_local_2 = _point.pos
                _hx_local_3 = _hx_local_2.y
                _hx_local_2.y = (_hx_local_3 - ((_loc4 * self.ny)))
                _hx_local_2.y
                _point.vel.x = ((_point.vel.x + ((((self.ny * _point.friction) * _loc4) * ((1 if ((_point.vel.x < _point.pos.x)) else -1))))) + self.accx)
                _point.vel.y = ((_point.vel.y - ((((self.nx * _point.friction) * _loc4) * ((-1 if ((_point.vel.y < _point.pos.y)) else 1))))) + self.accy)

hxlr_lines_Accel._hx_class = hxlr_lines_Accel


class hxlr_lines_Floor(hxlr_lines_LineBase):
    _hx_class_name = "hxlr.lines.Floor"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["collide"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = hxlr_lines_LineBase


    def __init__(self,_start,_end,_shift):
        super().__init__(_start,_end,_shift)
        self.type = 0
        self.tangible = True

    def collide(self,_point):
        _loc5 = (_point.pos.x - self.start.x)
        _loc6 = (_point.pos.y - self.start.y)
        _loc4 = ((self.nx * _loc5) + ((self.ny * _loc6)))
        _loc7 = ((((_loc5 * self.dx) + ((_loc6 * self.dy)))) * self.invSqrDistance)
        if (((_point.dir.x * self.nx) + ((_point.dir.y * self.ny))) > 0):
            if ((((_loc4 > 0) and ((_loc4 < self.zone))) and ((_loc7 >= self.limStart))) and ((_loc7 <= self.limEnd))):
                _hx_local_0 = _point.pos
                _hx_local_1 = _hx_local_0.x
                _hx_local_0.x = (_hx_local_1 - ((_loc4 * self.nx)))
                _hx_local_0.x
                _hx_local_2 = _point.pos
                _hx_local_3 = _hx_local_2.y
                _hx_local_2.y = (_hx_local_3 - ((_loc4 * self.ny)))
                _hx_local_2.y
                _hx_local_4 = _point.vel
                _hx_local_5 = _hx_local_4.x
                _hx_local_4.x = (_hx_local_5 + ((((self.ny * _point.friction) * _loc4) * ((1 if ((_point.vel.x < _point.pos.x)) else -1)))))
                _hx_local_4.x
                _hx_local_6 = _point.vel
                _hx_local_7 = _hx_local_6.y
                _hx_local_6.y = (_hx_local_7 - ((((self.nx * _point.friction) * _loc4) * ((-1 if ((_point.vel.y < _point.pos.y)) else 1)))))
                _hx_local_6.y

hxlr_lines_Floor._hx_class = hxlr_lines_Floor


class hxlr_lines_Scenery(hxlr_lines_LineBase):
    _hx_class_name = "hxlr.lines.Scenery"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = hxlr_lines_LineBase


    def __init__(self,_start,_end,_shift):
        super().__init__(_start,_end,_shift)
        self.type = 2
hxlr_lines_Scenery._hx_class = hxlr_lines_Scenery


class hxlr_lines_Undefined(hxlr_lines_LineBase):
    _hx_class_name = "hxlr.lines.Undefined"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = hxlr_lines_LineBase


    def __init__(self,_start,_end,_shift,_lim = None):
        if (_lim is None):
            _lim = 0
        super().__init__(_start,_end,_shift,_lim)
hxlr_lines_Undefined._hx_class = hxlr_lines_Undefined


class hxlr_math_geom_Line:
    _hx_class_name = "hxlr.math.geom.Line"
    __slots__ = ("start",)
    _hx_fields = ["start"]

    def __init__(self,_start,_end):
        self.start = None

hxlr_math_geom_Line._hx_class = hxlr_math_geom_Line


class hxlr_math_geom_Point:
    _hx_class_name = "hxlr.math.geom.Point"
    __slots__ = ("x", "y")
    _hx_fields = ["x", "y"]
    _hx_methods = ["clone", "add", "sub"]

    def __init__(self,_x = None,_y = None):
        if (_x is None):
            _x = 0.0
        if (_y is None):
            _y = 0.0
        self.x = _x
        self.y = _y

    def clone(self):
        return hxlr_math_geom_Point(self.x,self.y)

    def add(self,_point):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.x
        _hx_local_0.x = (_hx_local_1 + _point.x)
        _hx_local_0.x
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.y
        _hx_local_2.y = (_hx_local_3 + _point.y)
        _hx_local_2.y
        return self

    def sub(self,_point):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.x
        _hx_local_0.x = (_hx_local_1 - _point.x)
        _hx_local_0.x
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.y
        _hx_local_2.y = (_hx_local_3 - _point.y)
        _hx_local_2.y
        return self

hxlr_math_geom_Point._hx_class = hxlr_math_geom_Point


class hxlr_rider_ContactPoint:
    _hx_class_name = "hxlr.rider.ContactPoint"
    __slots__ = ("pos", "vel", "dir", "gravity", "friction")
    _hx_fields = ["pos", "vel", "dir", "gravity", "friction"]
    _hx_methods = ["iterate", "serialize", "deserialize"]

    def __init__(self,_x = None,_y = None,_friction = None):
        if (_x is None):
            _x = 0.0
        if (_y is None):
            _y = 0.0
        if (_friction is None):
            _friction = 0.0
        self.gravity = None
        self.pos = hxlr_math_geom_Point(_x,_y)
        self.dir = hxlr_math_geom_Point()
        self.vel = hxlr_math_geom_Point()
        self.friction = _friction

    def iterate(self,_gravity = None):
        g = (self.gravity if ((_gravity is None)) else _gravity)
        self.dir.x = ((self.pos.x - self.vel.x) + g.x)
        self.dir.y = ((self.pos.y - self.vel.y) + g.y)
        self.vel = self.pos.clone()
        self.pos = self.pos.add(self.dir)

    def serialize(self):
        object = _hx_AnonObject({'position': self.pos, 'velocity': self.vel, 'friction': self.friction})
        return object

    def deserialize(self,_object):
        self.pos = _object.position
        self.vel = _object.velocity
        self.friction = _object.friction

hxlr_rider_ContactPoint._hx_class = hxlr_rider_ContactPoint


class hxlr_rider_AirPoint(hxlr_rider_ContactPoint):
    _hx_class_name = "hxlr.rider.AirPoint"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["iterate"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = hxlr_rider_ContactPoint


    def __init__(self,_x,_y,_af):
        super().__init__(_x,_y)
        self.friction = _af

    def iterate(self,_gravity = None):
        g = (self.gravity if ((_gravity is None)) else _gravity)
        self.dir.x = ((((self.pos.x - self.vel.x)) * self.friction) + g.x)
        self.dir.y = ((((self.pos.y - self.vel.y)) * self.friction) + g.y)
        self.vel = self.pos.clone()
        self.pos = self.pos.add(self.dir)

hxlr_rider_AirPoint._hx_class = hxlr_rider_AirPoint


class hxlr_rider_RiderBase:
    _hx_class_name = "hxlr.rider.RiderBase"
    __slots__ = ("struct", "startPos", "startVel", "gravity", "contactPoints", "airPoints", "constraints", "scarves", "limits", "crashed", "invincible", "enabledFrame", "disableFrame", "enabled", "focusPoint", "name")
    _hx_fields = ["struct", "startPos", "startVel", "gravity", "contactPoints", "airPoints", "constraints", "scarves", "limits", "crashed", "invincible", "enabledFrame", "disableFrame", "enabled", "focusPoint", "name"]
    _hx_methods = ["init", "reset", "step", "iterate", "checkLimits", "constrain", "constrainScarf", "collide", "renderRider", "set_crashed"]

    def __init__(self,_struct,_start,_name):
        self.name = None
        self.focusPoint = None
        self.disableFrame = None
        self.enabledFrame = None
        self.limits = None
        self.scarves = None
        self.constraints = None
        self.airPoints = None
        self.contactPoints = None
        self.gravity = None
        self.startVel = None
        self.enabled = True
        self.invincible = False
        self.crashed = False
        self.struct = _struct
        self.startPos = _start
        self.startVel = hxlr_math_geom_Point(self.struct.x_vel,self.struct.y_vel)
        self.gravity = hxlr_math_geom_Point(self.struct.x_grav,self.struct.y_grav)
        self.name = _name
        self.init()

    def init(self):
        self.contactPoints = list()
        _g = 0
        _g1 = self.struct.contactPoints
        while (_g < len(_g1)):
            dot = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            _this = self.contactPoints
            x = hxlr_rider_ContactPoint(dot.x,dot.y,dot.fr)
            _this.append(x)
        self.airPoints = list()
        _g = 0
        _g1 = self.struct.scarfPoints
        while (_g < len(_g1)):
            dot = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            _this = self.airPoints
            x = hxlr_rider_AirPoint(dot.x,dot.y,dot.fr)
            _this.append(x)
        _g = 0
        _g1 = self.contactPoints
        while (_g < len(_g1)):
            point = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            _hx_local_3 = point.pos
            _hx_local_4 = _hx_local_3.x
            _hx_local_3.x = (_hx_local_4 * self.struct.scale)
            _hx_local_3.x
            _hx_local_5 = point.pos
            _hx_local_6 = _hx_local_5.y
            _hx_local_5.y = (_hx_local_6 * self.struct.scale)
            _hx_local_5.y
            _hx_local_7 = point.pos
            _hx_local_8 = _hx_local_7.x
            _hx_local_7.x = (_hx_local_8 + self.startPos.x)
            _hx_local_7.x
            _hx_local_9 = point.pos
            _hx_local_10 = _hx_local_9.y
            _hx_local_9.y = (_hx_local_10 + self.startPos.y)
            _hx_local_9.y
            point.vel.x = (point.pos.x - self.startVel.x)
            point.vel.y = point.pos.y
        _g = 0
        _g1 = self.airPoints
        while (_g < len(_g1)):
            point = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            _hx_local_12 = point.pos
            _hx_local_13 = _hx_local_12.x
            _hx_local_12.x = (_hx_local_13 * self.struct.scale)
            _hx_local_12.x
            _hx_local_14 = point.pos
            _hx_local_15 = _hx_local_14.y
            _hx_local_14.y = (_hx_local_15 * self.struct.scale)
            _hx_local_14.y
            _hx_local_16 = point.pos
            _hx_local_17 = _hx_local_16.x
            _hx_local_16.x = (_hx_local_17 + self.startPos.x)
            _hx_local_16.x
            _hx_local_18 = point.pos
            _hx_local_19 = _hx_local_18.y
            _hx_local_18.y = (_hx_local_19 + self.startPos.y)
            _hx_local_18.y
            point.vel.x = (point.pos.x - self.startVel.x)
            point.vel.y = point.pos.y
        self.constraints = list()
        _g = 0
        _g1 = self.struct.bones
        while (_g < len(_g1)):
            edge = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            stick = hxlr_rider_Stick(python_internal_ArrayImpl._get(self.contactPoints, edge.a),python_internal_ArrayImpl._get(self.contactPoints, edge.b),edge.type,self)
            stick.crashable = edge.crashable
            _this = self.constraints
            _this.append(stick)
        self.scarves = list()
        _g = 0
        _g1 = len(self.airPoints)
        while (_g < _g1):
            point = _g
            _g = (_g + 1)
            if (python_internal_ArrayImpl._get(self.airPoints, (point + 1)) is None):
                break
            _this = self.scarves
            x = hxlr_rider_Stick((self.airPoints[point] if point >= 0 and point < len(self.airPoints) else None),python_internal_ArrayImpl._get(self.airPoints, (point + 1)),"SCARF",self)
            _this.append(x)
        _this = self.scarves
        x = hxlr_rider_Stick(python_internal_ArrayImpl._get(self.contactPoints, self.struct.scarfAnchor),(self.airPoints[0] if 0 < len(self.airPoints) else None),"SCARF",self)
        _this.insert(0, x)
        self.limits = self.struct.limits
        self.focusPoint = python_internal_ArrayImpl._get(self.contactPoints, self.struct.camera)
        self.set_crashed(False)

    def reset(self):
        pass

    def step(self):
        pass

    def iterate(self):
        pass

    def checkLimits(self):
        pass

    def constrain(self):
        pass

    def constrainScarf(self):
        pass

    def collide(self):
        _g = 0
        _g1 = self.contactPoints
        while (_g < len(_g1)):
            point = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            gridPos = hxlr_engine_Cell.getInfo(point.pos.x,point.pos.y)
            _g2 = -1
            while (_g2 < 2):
                _x = _g2
                _g2 = (_g2 + 1)
                _g3 = -1
                while (_g3 < 2):
                    _y = _g3
                    _g3 = (_g3 + 1)
                    key = ((("x" + Std.string(((gridPos.x + _x)))) + "y") + Std.string(((gridPos.y + _y))))
                    if (hxlr_engine_Grid.registry.h.get(key,None) is None):
                        continue
                    else:
                        register = hxlr_engine_Grid.registry.h.get(key,None)
                        _g4 = 0
                        _g5 = register.collidable
                        while (_g4 < len(_g5)):
                            line = (_g5[_g4] if _g4 >= 0 and _g4 < len(_g5) else None)
                            _g4 = (_g4 + 1)
                            if (line is None):
                                continue
                            line.collide(point)

    def renderRider(self):
        pass

    def set_crashed(self,_value):
        if self.invincible:
            def _hx_local_1():
                def _hx_local_0():
                    self.crashed = None
                    return self.crashed
                return _hx_local_0()
            return _hx_local_1()
        def _hx_local_3():
            def _hx_local_2():
                self.crashed = _value
                return self.crashed
            return _hx_local_2()
        return _hx_local_3()

hxlr_rider_RiderBase._hx_class = hxlr_rider_RiderBase


class hxlr_rider_Stick:
    _hx_class_name = "hxlr.rider.Stick"
    __slots__ = ("a", "b", "restLength", "enabled", "breakable", "broken", "crashable", "endurance", "constrain", "type", "rider")
    _hx_fields = ["a", "b", "restLength", "enabled", "breakable", "broken", "crashable", "endurance", "constrain", "type", "rider"]
    _hx_methods = ["satisfy", "noConstrain", "standard", "repell", "attract", "scarf", "set_type", "setRestLength"]

    def __init__(self,_a,_b,_type,_rider):
        self.rider = None
        self.type = None
        self.constrain = None
        self.endurance = None
        self.restLength = None
        self.crashable = False
        self.broken = False
        self.breakable = False
        self.enabled = True
        self.a = _a
        self.b = _b
        self.set_type(_type)
        self.rider = _rider
        self.endurance = ((0.057 * self.restLength) * 0.5)

    def satisfy(self,_crashed = None):
        if (not self.enabled):
            return
        result = self.constrain(_crashed)
        if self.breakable:
            self.broken = result
        if self.crashable:
            self.rider.set_crashed(result)

    def noConstrain(self,_crashed = None):
        return _crashed

    def standard(self,_crashed = None):
        xDist = (self.a.pos.x - self.b.pos.x)
        yDist = (self.a.pos.y - self.b.pos.y)
        v = ((xDist * xDist) + ((yDist * yDist)))
        dist = (Math.NaN if ((v < 0)) else python_lib_Math.sqrt(v))
        adjust = 0
        if (dist != 0):
            adjust = ((((dist - self.restLength)) / dist) * 0.5)
        if (self.crashable or self.breakable):
            if (not self.rider.invincible):
                if (((adjust > self.endurance) or _crashed) or self.broken):
                    return True
        xAdjust = (xDist * adjust)
        yAdjust = (yDist * adjust)
        _hx_local_0 = self.a.pos
        _hx_local_1 = _hx_local_0.x
        _hx_local_0.x = (_hx_local_1 - xAdjust)
        _hx_local_0.x
        _hx_local_2 = self.a.pos
        _hx_local_3 = _hx_local_2.y
        _hx_local_2.y = (_hx_local_3 - yAdjust)
        _hx_local_2.y
        _hx_local_4 = self.b.pos
        _hx_local_5 = _hx_local_4.x
        _hx_local_4.x = (_hx_local_5 + xAdjust)
        _hx_local_4.x
        _hx_local_6 = self.b.pos
        _hx_local_7 = _hx_local_6.y
        _hx_local_6.y = (_hx_local_7 + yAdjust)
        _hx_local_6.y
        return _crashed

    def repell(self,_crashed = None):
        xDist = (self.a.pos.x - self.b.pos.x)
        yDist = (self.a.pos.y - self.b.pos.y)
        v = ((xDist * xDist) + ((yDist * yDist)))
        dist = (Math.NaN if ((v < 0)) else python_lib_Math.sqrt(v))
        if (dist < self.restLength):
            adjust = 0
            if (dist != 0):
                adjust = ((((dist - self.restLength)) / dist) * 0.5)
            if (self.crashable or self.breakable):
                if (not self.rider.invincible):
                    if (((adjust > self.endurance) or _crashed) or self.broken):
                        return True
            xAdjust = (xDist * adjust)
            yAdjust = (yDist * adjust)
            _hx_local_0 = self.a.pos
            _hx_local_1 = _hx_local_0.x
            _hx_local_0.x = (_hx_local_1 - xAdjust)
            _hx_local_0.x
            _hx_local_2 = self.a.pos
            _hx_local_3 = _hx_local_2.y
            _hx_local_2.y = (_hx_local_3 - yAdjust)
            _hx_local_2.y
            _hx_local_4 = self.b.pos
            _hx_local_5 = _hx_local_4.x
            _hx_local_4.x = (_hx_local_5 + xAdjust)
            _hx_local_4.x
            _hx_local_6 = self.b.pos
            _hx_local_7 = _hx_local_6.y
            _hx_local_6.y = (_hx_local_7 + yAdjust)
            _hx_local_6.y
        return _crashed

    def attract(self,_crashed = None):
        xDist = (self.a.pos.x - self.b.pos.x)
        yDist = (self.a.pos.y - self.b.pos.y)
        v = ((xDist * xDist) + ((yDist * yDist)))
        dist = (Math.NaN if ((v < 0)) else python_lib_Math.sqrt(v))
        if (dist > self.restLength):
            adjust = 0
            if (dist != 0):
                adjust = ((((dist - self.restLength)) / dist) * 0.5)
            if (self.crashable or self.breakable):
                if (not self.rider.invincible):
                    if (((adjust > self.endurance) or _crashed) or self.broken):
                        return True
            xAdjust = (xDist * adjust)
            yAdjust = (yDist * adjust)
            _hx_local_0 = self.a.pos
            _hx_local_1 = _hx_local_0.x
            _hx_local_0.x = (_hx_local_1 - xAdjust)
            _hx_local_0.x
            _hx_local_2 = self.a.pos
            _hx_local_3 = _hx_local_2.y
            _hx_local_2.y = (_hx_local_3 - yAdjust)
            _hx_local_2.y
            _hx_local_4 = self.b.pos
            _hx_local_5 = _hx_local_4.x
            _hx_local_4.x = (_hx_local_5 + xAdjust)
            _hx_local_4.x
            _hx_local_6 = self.b.pos
            _hx_local_7 = _hx_local_6.y
            _hx_local_6.y = (_hx_local_7 + yAdjust)
            _hx_local_6.y
        return _crashed

    def scarf(self,_crashed = None):
        xDist = (self.a.pos.x - self.b.pos.x)
        yDist = (self.a.pos.y - self.b.pos.y)
        v = ((xDist * xDist) + ((yDist * yDist)))
        dist = (Math.NaN if ((v < 0)) else python_lib_Math.sqrt(v))
        adjust = None
        if (dist == 0):
            adjust = 0
        else:
            adjust = ((((dist - self.restLength)) / dist) * 0.5)
        xAdjust = (xDist * adjust)
        yAdjust = (yDist * adjust)
        _hx_local_0 = self.b.pos
        _hx_local_1 = _hx_local_0.x
        _hx_local_0.x = (_hx_local_1 + xAdjust)
        _hx_local_0.x
        _hx_local_2 = self.b.pos
        _hx_local_3 = _hx_local_2.y
        _hx_local_2.y = (_hx_local_3 + yAdjust)
        _hx_local_2.y
        return _crashed

    def set_type(self,value):
        self.setRestLength()
        if ((value == "REPELL") or ((value == "ATTRACT"))):
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.restLength
            _hx_local_0.restLength = (_hx_local_1 * 0.5)
            _hx_local_0.restLength
        value1 = value
        if (value1 == "REPELL"):
            self.constrain = self.repell
        elif (value1 == "SCARF"):
            self.constrain = self.scarf
        elif (value1 == "STANDARD"):
            self.constrain = self.standard
        else:
            self.constrain = self.noConstrain
        def _hx_local_3():
            def _hx_local_2():
                self.type = value
                return self.type
            return _hx_local_2()
        return _hx_local_3()

    def setRestLength(self):
        x = (self.a.pos.x - self.b.pos.x)
        y = (self.a.pos.y - self.b.pos.y)
        v = ((x * x) + ((y * y)))
        self.restLength = (Math.NaN if ((v < 0)) else python_lib_Math.sqrt(v))

hxlr_rider_Stick._hx_class = hxlr_rider_Stick


class python_Boot:
    _hx_class_name = "python.Boot"
    __slots__ = ()
    _hx_statics = ["keywords", "toString1", "fields", "simpleField", "hasField", "field", "getInstanceFields", "getSuperClass", "getClassFields", "prefixLength", "unhandleKeywords"]

    @staticmethod
    def toString1(o,s):
        if (o is None):
            return "null"
        if isinstance(o,str):
            return o
        if (s is None):
            s = ""
        if (len(s) >= 5):
            return "<...>"
        if isinstance(o,bool):
            if o:
                return "true"
            else:
                return "false"
        if (isinstance(o,int) and (not isinstance(o,bool))):
            return str(o)
        if isinstance(o,float):
            try:
                if (o == int(o)):
                    return str(Math.floor((o + 0.5)))
                else:
                    return str(o)
            except BaseException as _g:
                None
                return str(o)
        if isinstance(o,list):
            o1 = o
            l = len(o1)
            st = "["
            s = (("null" if s is None else s) + "\t")
            _g = 0
            _g1 = l
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                prefix = ""
                if (i > 0):
                    prefix = ","
                st = (("null" if st is None else st) + HxOverrides.stringOrNull(((("null" if prefix is None else prefix) + HxOverrides.stringOrNull(python_Boot.toString1((o1[i] if i >= 0 and i < len(o1) else None),s))))))
            st = (("null" if st is None else st) + "]")
            return st
        try:
            if hasattr(o,"toString"):
                return o.toString()
        except BaseException as _g:
            None
        if hasattr(o,"__class__"):
            if isinstance(o,_hx_AnonObject):
                toStr = None
                try:
                    fields = python_Boot.fields(o)
                    _g = []
                    _g1 = 0
                    while (_g1 < len(fields)):
                        f = (fields[_g1] if _g1 >= 0 and _g1 < len(fields) else None)
                        _g1 = (_g1 + 1)
                        x = ((("" + ("null" if f is None else f)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f),(("null" if s is None else s) + "\t"))))
                        _g.append(x)
                    fieldsStr = _g
                    toStr = (("{ " + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr]))) + " }")
                except BaseException as _g:
                    None
                    return "{ ... }"
                if (toStr is None):
                    return "{ ... }"
                else:
                    return toStr
            if isinstance(o,Enum):
                o1 = o
                l = len(o1.params)
                hasParams = (l > 0)
                if hasParams:
                    paramsStr = ""
                    _g = 0
                    _g1 = l
                    while (_g < _g1):
                        i = _g
                        _g = (_g + 1)
                        prefix = ""
                        if (i > 0):
                            prefix = ","
                        paramsStr = (("null" if paramsStr is None else paramsStr) + HxOverrides.stringOrNull(((("null" if prefix is None else prefix) + HxOverrides.stringOrNull(python_Boot.toString1(o1.params[i],s))))))
                    return (((HxOverrides.stringOrNull(o1.tag) + "(") + ("null" if paramsStr is None else paramsStr)) + ")")
                else:
                    return o1.tag
            if hasattr(o,"_hx_class_name"):
                if (o.__class__.__name__ != "type"):
                    fields = python_Boot.getInstanceFields(o)
                    _g = []
                    _g1 = 0
                    while (_g1 < len(fields)):
                        f = (fields[_g1] if _g1 >= 0 and _g1 < len(fields) else None)
                        _g1 = (_g1 + 1)
                        x = ((("" + ("null" if f is None else f)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f),(("null" if s is None else s) + "\t"))))
                        _g.append(x)
                    fieldsStr = _g
                    toStr = (((HxOverrides.stringOrNull(o._hx_class_name) + "( ") + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr]))) + " )")
                    return toStr
                else:
                    fields = python_Boot.getClassFields(o)
                    _g = []
                    _g1 = 0
                    while (_g1 < len(fields)):
                        f = (fields[_g1] if _g1 >= 0 and _g1 < len(fields) else None)
                        _g1 = (_g1 + 1)
                        x = ((("" + ("null" if f is None else f)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f),(("null" if s is None else s) + "\t"))))
                        _g.append(x)
                    fieldsStr = _g
                    toStr = (((("#" + HxOverrides.stringOrNull(o._hx_class_name)) + "( ") + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr]))) + " )")
                    return toStr
            if (o == str):
                return "#String"
            if (o == list):
                return "#Array"
            if callable(o):
                return "function"
            try:
                if hasattr(o,"__repr__"):
                    return o.__repr__()
            except BaseException as _g:
                None
            if hasattr(o,"__str__"):
                return o.__str__([])
            if hasattr(o,"__name__"):
                return o.__name__
            return "???"
        else:
            return str(o)

    @staticmethod
    def fields(o):
        a = []
        if (o is not None):
            if hasattr(o,"_hx_fields"):
                fields = o._hx_fields
                if (fields is not None):
                    return list(fields)
            if isinstance(o,_hx_AnonObject):
                d = o.__dict__
                keys = d.keys()
                handler = python_Boot.unhandleKeywords
                for k in keys:
                    if (k != '_hx_disable_getattr'):
                        a.append(handler(k))
            elif hasattr(o,"__dict__"):
                d = o.__dict__
                keys1 = d.keys()
                for k in keys1:
                    a.append(k)
        return a

    @staticmethod
    def simpleField(o,field):
        if (field is None):
            return None
        field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
        if hasattr(o,field1):
            return getattr(o,field1)
        else:
            return None

    @staticmethod
    def hasField(o,field):
        if isinstance(o,_hx_AnonObject):
            return o._hx_hasattr(field)
        return hasattr(o,(("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field)))

    @staticmethod
    def field(o,field):
        if (field is None):
            return None
        if isinstance(o,str):
            field1 = field
            _hx_local_0 = len(field1)
            if (_hx_local_0 == 10):
                if (field1 == "charCodeAt"):
                    return python_internal_MethodClosure(o,HxString.charCodeAt)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_0 == 11):
                if (field1 == "lastIndexOf"):
                    return python_internal_MethodClosure(o,HxString.lastIndexOf)
                elif (field1 == "toLowerCase"):
                    return python_internal_MethodClosure(o,HxString.toLowerCase)
                elif (field1 == "toUpperCase"):
                    return python_internal_MethodClosure(o,HxString.toUpperCase)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_0 == 9):
                if (field1 == "substring"):
                    return python_internal_MethodClosure(o,HxString.substring)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_0 == 5):
                if (field1 == "split"):
                    return python_internal_MethodClosure(o,HxString.split)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_0 == 7):
                if (field1 == "indexOf"):
                    return python_internal_MethodClosure(o,HxString.indexOf)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_0 == 8):
                if (field1 == "toString"):
                    return python_internal_MethodClosure(o,HxString.toString)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_0 == 6):
                if (field1 == "charAt"):
                    return python_internal_MethodClosure(o,HxString.charAt)
                elif (field1 == "length"):
                    return len(o)
                elif (field1 == "substr"):
                    return python_internal_MethodClosure(o,HxString.substr)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            else:
                field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                if hasattr(o,field1):
                    return getattr(o,field1)
                else:
                    return None
        elif isinstance(o,list):
            field1 = field
            _hx_local_1 = len(field1)
            if (_hx_local_1 == 11):
                if (field1 == "lastIndexOf"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.lastIndexOf)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_1 == 4):
                if (field1 == "copy"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.copy)
                elif (field1 == "join"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.join)
                elif (field1 == "push"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.push)
                elif (field1 == "sort"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.sort)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_1 == 5):
                if (field1 == "shift"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.shift)
                elif (field1 == "slice"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.slice)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_1 == 7):
                if (field1 == "indexOf"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.indexOf)
                elif (field1 == "reverse"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.reverse)
                elif (field1 == "unshift"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.unshift)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_1 == 3):
                if (field1 == "map"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.map)
                elif (field1 == "pop"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.pop)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_1 == 8):
                if (field1 == "contains"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.contains)
                elif (field1 == "iterator"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.iterator)
                elif (field1 == "toString"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.toString)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_1 == 16):
                if (field1 == "keyValueIterator"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.keyValueIterator)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_1 == 6):
                if (field1 == "concat"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.concat)
                elif (field1 == "filter"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.filter)
                elif (field1 == "insert"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.insert)
                elif (field1 == "length"):
                    return len(o)
                elif (field1 == "remove"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.remove)
                elif (field1 == "splice"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.splice)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            else:
                field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                if hasattr(o,field1):
                    return getattr(o,field1)
                else:
                    return None
        else:
            field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
            if hasattr(o,field1):
                return getattr(o,field1)
            else:
                return None

    @staticmethod
    def getInstanceFields(c):
        f = (list(c._hx_fields) if (hasattr(c,"_hx_fields")) else [])
        if hasattr(c,"_hx_methods"):
            f = (f + c._hx_methods)
        sc = python_Boot.getSuperClass(c)
        if (sc is None):
            return f
        else:
            scArr = python_Boot.getInstanceFields(sc)
            scMap = set(scArr)
            _g = 0
            while (_g < len(f)):
                f1 = (f[_g] if _g >= 0 and _g < len(f) else None)
                _g = (_g + 1)
                if (not (f1 in scMap)):
                    scArr.append(f1)
            return scArr

    @staticmethod
    def getSuperClass(c):
        if (c is None):
            return None
        try:
            if hasattr(c,"_hx_super"):
                return c._hx_super
            return None
        except BaseException as _g:
            None
        return None

    @staticmethod
    def getClassFields(c):
        if hasattr(c,"_hx_statics"):
            x = c._hx_statics
            return list(x)
        else:
            return []

    @staticmethod
    def unhandleKeywords(name):
        if (HxString.substr(name,0,python_Boot.prefixLength) == "_hx_"):
            real = HxString.substr(name,python_Boot.prefixLength,None)
            if (real in python_Boot.keywords):
                return real
        return name
python_Boot._hx_class = python_Boot


class python__KwArgs_KwArgs_Impl_:
    _hx_class_name = "python._KwArgs.KwArgs_Impl_"
    __slots__ = ()
    _hx_statics = ["fromT"]

    @staticmethod
    def fromT(d):
        this1 = python_Lib.anonAsDict(d)
        return this1
python__KwArgs_KwArgs_Impl_._hx_class = python__KwArgs_KwArgs_Impl_


class python_Lib:
    _hx_class_name = "python.Lib"
    __slots__ = ()
    _hx_statics = ["lineEnd", "printString", "anonToDict", "anonAsDict"]

    @staticmethod
    def printString(_hx_str):
        encoding = "utf-8"
        if (encoding is None):
            encoding = "utf-8"
        python_lib_Sys.stdout.buffer.write(_hx_str.encode(encoding, "strict"))
        python_lib_Sys.stdout.flush()

    @staticmethod
    def anonToDict(o):
        if isinstance(o,_hx_AnonObject):
            return o.__dict__.copy()
        else:
            return None

    @staticmethod
    def anonAsDict(o):
        if isinstance(o,_hx_AnonObject):
            return o.__dict__
        else:
            return None
python_Lib._hx_class = python_Lib


class python_internal_ArrayImpl:
    _hx_class_name = "python.internal.ArrayImpl"
    __slots__ = ()
    _hx_statics = ["concat", "copy", "iterator", "keyValueIterator", "indexOf", "lastIndexOf", "join", "toString", "pop", "push", "unshift", "remove", "contains", "shift", "slice", "sort", "splice", "map", "filter", "insert", "reverse", "_get", "_set"]

    @staticmethod
    def concat(a1,a2):
        return (a1 + a2)

    @staticmethod
    def copy(x):
        return list(x)

    @staticmethod
    def iterator(x):
        return python_HaxeIterator(x.__iter__())

    @staticmethod
    def keyValueIterator(x):
        return haxe_iterators_ArrayKeyValueIterator(x)

    @staticmethod
    def indexOf(a,x,fromIndex = None):
        _hx_len = len(a)
        l = (0 if ((fromIndex is None)) else ((_hx_len + fromIndex) if ((fromIndex < 0)) else fromIndex))
        if (l < 0):
            l = 0
        _g = l
        _g1 = _hx_len
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            if HxOverrides.eq(a[i],x):
                return i
        return -1

    @staticmethod
    def lastIndexOf(a,x,fromIndex = None):
        _hx_len = len(a)
        l = (_hx_len if ((fromIndex is None)) else (((_hx_len + fromIndex) + 1) if ((fromIndex < 0)) else (fromIndex + 1)))
        if (l > _hx_len):
            l = _hx_len
        while True:
            l = (l - 1)
            tmp = l
            if (not ((tmp > -1))):
                break
            if HxOverrides.eq(a[l],x):
                return l
        return -1

    @staticmethod
    def join(x,sep):
        return sep.join([python_Boot.toString1(x1,'') for x1 in x])

    @staticmethod
    def toString(x):
        return (("[" + HxOverrides.stringOrNull(",".join([python_Boot.toString1(x1,'') for x1 in x]))) + "]")

    @staticmethod
    def pop(x):
        if (len(x) == 0):
            return None
        else:
            return x.pop()

    @staticmethod
    def push(x,e):
        x.append(e)
        return len(x)

    @staticmethod
    def unshift(x,e):
        x.insert(0, e)

    @staticmethod
    def remove(x,e):
        try:
            x.remove(e)
            return True
        except BaseException as _g:
            None
            return False

    @staticmethod
    def contains(x,e):
        return (e in x)

    @staticmethod
    def shift(x):
        if (len(x) == 0):
            return None
        return x.pop(0)

    @staticmethod
    def slice(x,pos,end = None):
        return x[pos:end]

    @staticmethod
    def sort(x,f):
        x.sort(key= python_lib_Functools.cmp_to_key(f))

    @staticmethod
    def splice(x,pos,_hx_len):
        if (pos < 0):
            pos = (len(x) + pos)
        if (pos < 0):
            pos = 0
        res = x[pos:(pos + _hx_len)]
        del x[pos:(pos + _hx_len)]
        return res

    @staticmethod
    def map(x,f):
        return list(map(f,x))

    @staticmethod
    def filter(x,f):
        return list(filter(f,x))

    @staticmethod
    def insert(a,pos,x):
        a.insert(pos, x)

    @staticmethod
    def reverse(a):
        a.reverse()

    @staticmethod
    def _get(x,idx):
        if ((idx > -1) and ((idx < len(x)))):
            return x[idx]
        else:
            return None

    @staticmethod
    def _set(x,idx,v):
        l = len(x)
        while (l < idx):
            x.append(None)
            l = (l + 1)
        if (l == idx):
            x.append(v)
        else:
            x[idx] = v
        return v
python_internal_ArrayImpl._hx_class = python_internal_ArrayImpl


class HxOverrides:
    _hx_class_name = "HxOverrides"
    __slots__ = ()
    _hx_statics = ["eq", "stringOrNull", "mapKwArgs"]

    @staticmethod
    def eq(a,b):
        if (isinstance(a,list) or isinstance(b,list)):
            return a is b
        return (a == b)

    @staticmethod
    def stringOrNull(s):
        if (s is None):
            return "null"
        else:
            return s

    @staticmethod
    def mapKwArgs(a,v):
        a1 = _hx_AnonObject(python_Lib.anonToDict(a))
        k = python_HaxeIterator(iter(v.keys()))
        while k.hasNext():
            k1 = k.next()
            val = v.get(k1)
            if a1._hx_hasattr(k1):
                x = getattr(a1,k1)
                setattr(a1,val,x)
                delattr(a1,k1)
        return a1
HxOverrides._hx_class = HxOverrides


class python_internal_MethodClosure:
    _hx_class_name = "python.internal.MethodClosure"
    __slots__ = ("obj", "func")
    _hx_fields = ["obj", "func"]
    _hx_methods = ["__call__"]

    def __init__(self,obj,func):
        self.obj = obj
        self.func = func

    def __call__(self,*args):
        return self.func(self.obj,*args)

python_internal_MethodClosure._hx_class = python_internal_MethodClosure


class HxString:
    _hx_class_name = "HxString"
    __slots__ = ()
    _hx_statics = ["split", "charCodeAt", "charAt", "lastIndexOf", "toUpperCase", "toLowerCase", "indexOf", "indexOfImpl", "toString", "substring", "substr"]

    @staticmethod
    def split(s,d):
        if (d == ""):
            return list(s)
        else:
            return s.split(d)

    @staticmethod
    def charCodeAt(s,index):
        if ((((s is None) or ((len(s) == 0))) or ((index < 0))) or ((index >= len(s)))):
            return None
        else:
            return ord(s[index])

    @staticmethod
    def charAt(s,index):
        if ((index < 0) or ((index >= len(s)))):
            return ""
        else:
            return s[index]

    @staticmethod
    def lastIndexOf(s,_hx_str,startIndex = None):
        if (startIndex is None):
            return s.rfind(_hx_str, 0, len(s))
        elif (_hx_str == ""):
            length = len(s)
            if (startIndex < 0):
                startIndex = (length + startIndex)
                if (startIndex < 0):
                    startIndex = 0
            if (startIndex > length):
                return length
            else:
                return startIndex
        else:
            i = s.rfind(_hx_str, 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len(_hx_str))) if ((i == -1)) else (i + 1))
            check = s.find(_hx_str, startLeft, len(s))
            if ((check > i) and ((check <= startIndex))):
                return check
            else:
                return i

    @staticmethod
    def toUpperCase(s):
        return s.upper()

    @staticmethod
    def toLowerCase(s):
        return s.lower()

    @staticmethod
    def indexOf(s,_hx_str,startIndex = None):
        if (startIndex is None):
            return s.find(_hx_str)
        else:
            return HxString.indexOfImpl(s,_hx_str,startIndex)

    @staticmethod
    def indexOfImpl(s,_hx_str,startIndex):
        if (_hx_str == ""):
            length = len(s)
            if (startIndex < 0):
                startIndex = (length + startIndex)
                if (startIndex < 0):
                    startIndex = 0
            if (startIndex > length):
                return length
            else:
                return startIndex
        return s.find(_hx_str, startIndex)

    @staticmethod
    def toString(s):
        return s

    @staticmethod
    def substring(s,startIndex,endIndex = None):
        if (startIndex < 0):
            startIndex = 0
        if (endIndex is None):
            return s[startIndex:]
        else:
            if (endIndex < 0):
                endIndex = 0
            if (endIndex < startIndex):
                return s[endIndex:startIndex]
            else:
                return s[startIndex:endIndex]

    @staticmethod
    def substr(s,startIndex,_hx_len = None):
        if (_hx_len is None):
            return s[startIndex:]
        else:
            if (_hx_len == 0):
                return ""
            if (startIndex < 0):
                startIndex = (len(s) + startIndex)
                if (startIndex < 0):
                    startIndex = 0
            return s[startIndex:(startIndex + _hx_len)]
HxString._hx_class = HxString

Math.NEGATIVE_INFINITY = float("-inf")
Math.POSITIVE_INFINITY = float("inf")
Math.NaN = float("nan")
Math.PI = python_lib_Math.pi

hxlr_Constants.minLineSize = 10
hxlr_Constants.minSnapDistance = 10
hxlr_Constants.x_gravity = 0
hxlr_Constants.y_gravity = 0.175
hxlr_Constants.x_velocity = 0.4
hxlr_Constants.y_velocity = 0
hxlr_engine_Cell.size = 14
hxlr_engine_Cell.cellList = list()
python_Boot.keywords = set(["and", "del", "from", "not", "with", "as", "elif", "global", "or", "yield", "assert", "else", "if", "pass", "None", "break", "except", "import", "raise", "True", "class", "exec", "in", "return", "False", "continue", "finally", "is", "try", "def", "for", "lambda", "while"])
python_Boot.prefixLength = len("_hx_")
python_Lib.lineEnd = ("\r\n" if ((Sys.systemName() == "Windows")) else "\n")