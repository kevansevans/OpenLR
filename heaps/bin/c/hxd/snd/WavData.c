// Generated by HLC 4.1.5 (HL v5)
#define HLC_BOOT
#include <hlc.h>
#include <hxd/snd/WavData.h>
#include <hl/types/ArrayObj.h>
#include <format/wav/WAVEFormat.h>
#include <format/wav/Reader.h>
#include <haxe/io/BytesInput.h>
extern hl_type t$format_wav_Reader;
extern hl_type t$haxe_io_BytesInput;
void haxe_io_BytesInput_new(haxe__io__BytesInput,haxe__io__Bytes,vdynamic*,vdynamic*);
#include <haxe/io/Input.h>
void format_wav_Reader_new(format__wav__Reader,haxe__io__Input);
vvirtual* format_wav_Reader_read(format__wav__Reader);
void hxd_snd_WavData_init(hxd__snd__WavData,vvirtual*);
extern hl_type t$vrt_c2cbdf6;
extern hl_type t$_i32;
extern String s$Unsupported_WAV_;
#include <hl/natives.h>
String String___alloc__(vbyte*,int);
String String___add__(String,String);
extern String s$_bits;
vdynamic* haxe_Exception_thrown(vdynamic*);
extern venum* g$hxd_snd_SampleFormat_UI8;
extern venum* g$hxd_snd_SampleFormat_I16;
extern hl_type t$haxe_io_Bytes;
int hxd_snd_Data_getBytesPerSample(hxd__snd__Data);
void haxe_io_Bytes_blit(haxe__io__Bytes,int,haxe__io__Bytes,int,int);

void hxd_snd_WavData_new(hxd__snd__WavData r0,haxe__io__Bytes r1) {
	haxe__io__BytesInput r5;
	vvirtual *r3;
	format__wav__Reader r4;
	vdynamic *r6, *r7;
	if( !r1 ) goto label$26f1bee_1_9;
	r4 = (format__wav__Reader)hl_alloc_obj(&t$format_wav_Reader);
	r5 = (haxe__io__BytesInput)hl_alloc_obj(&t$haxe_io_BytesInput);
	r6 = NULL;
	r7 = NULL;
	haxe_io_BytesInput_new(r5,r1,r6,r7);
	format_wav_Reader_new(r4,((haxe__io__Input)r5));
	r3 = format_wav_Reader_read(r4);
	hxd_snd_WavData_init(r0,r3);
	label$26f1bee_1_9:
	return;
}

void hxd_snd_WavData_init(hxd__snd__WavData r0,vvirtual* r1) {
	String r6, r9;
	vvirtual *r2;
	venum *r10;
	haxe__io__Bytes r11;
	double r12, r13;
	int *r7;
	vdynamic *r5;
	vbyte *r8;
	int r4;
	if( r1 == NULL ) hl_null_access();
	r2 = hl_vfields(r1)[2] ? (*(vvirtual**)(hl_vfields(r1)[2])) : (vvirtual*)hl_dyn_getp(r1->value,-50329203/*header*/,&t$vrt_c2cbdf6);
	if( r2 == NULL ) hl_null_access();
	r4 = hl_vfields(r2)[5] ? (*(int*)(hl_vfields(r2)[5])) : (int)hl_dyn_geti(r2->value,372418284/*samplingRate*/,&t$_i32);
	r0->samplingRate = r4;
	r4 = hl_vfields(r2)[3] ? (*(int*)(hl_vfields(r2)[3])) : (int)hl_dyn_geti(r2->value,183413727/*channels*/,&t$_i32);
	r0->channels = r4;
	r4 = hl_vfields(r2)[0] ? (*(int*)(hl_vfields(r2)[0])) : (int)hl_dyn_geti(r2->value,-466222980/*bitsPerSample*/,&t$_i32);
	switch(r4) {
		default:
		case 0:
		case 1:
		case 2:
		case 3:
		case 4:
		case 5:
		case 6:
		case 7:
		case 9:
		case 10:
		case 11:
		case 12:
		case 13:
		case 14:
		case 15:
			r6 = (String)s$Unsupported_WAV_;
			r4 = hl_vfields(r2)[0] ? (*(int*)(hl_vfields(r2)[0])) : (int)hl_dyn_geti(r2->value,-466222980/*bitsPerSample*/,&t$_i32);
			r7 = &r4;
			r8 = hl_itos(r4,r7);
			r9 = String___alloc__(r8,r4);
			r6 = String___add__(r6,r9);
			r9 = (String)s$_bits;
			r6 = String___add__(r6,r9);
			r5 = haxe_Exception_thrown(((vdynamic*)r6));
			hl_throw((vdynamic*)r5);
		case 8:
			r10 = (venum*)g$hxd_snd_SampleFormat_UI8;
			goto label$26f1bee_2_22;
		case 16:
			r10 = (venum*)g$hxd_snd_SampleFormat_I16;
	}
	label$26f1bee_2_22:
	r0->sampleFormat = r10;
	r11 = hl_vfields(r1)[1] ? (*(haxe__io__Bytes*)(hl_vfields(r1)[1])) : (haxe__io__Bytes)hl_dyn_getp(r1->value,40064820/*data*/,&t$haxe_io_Bytes);
	r0->rawData = r11;
	r11 = r0->rawData;
	if( r11 == NULL ) hl_null_access();
	r4 = r11->length;
	r12 = (double)r4;
	r4 = hxd_snd_Data_getBytesPerSample(((hxd__snd__Data)r0));
	r13 = (double)r4;
	r12 = r12 / r13;
	r4 = (int)r12;
	r0->samples = r4;
	return;
}

void hxd_snd_WavData_decodeBuffer(hxd__snd__WavData r0,haxe__io__Bytes r1,int r2,int r3,int r4) {
	haxe__io__Bytes r7;
	int r5, r8, r9;
	r5 = hxd_snd_Data_getBytesPerSample(((hxd__snd__Data)r0));
	if( r1 == NULL ) hl_null_access();
	r7 = r0->rawData;
	r8 = r3 * r5;
	r9 = r4 * r5;
	haxe_io_Bytes_blit(r1,r2,r7,r8,r9);
	return;
}

