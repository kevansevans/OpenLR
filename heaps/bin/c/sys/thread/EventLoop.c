// Generated by HLC 4.2.0 (HL v5)
#define HLC_BOOT
#include <hlc.h>
#include <sys/thread/EventLoop.h>
#include <hl/natives.h>
extern hl_type t$sys_thread__EventLoop_RegularEvent;
void sys_thread__EventLoop_RegularEvent_new(sys__thread___EventLoop__RegularEvent,vclosure*,double,double);
void sys_thread_Lock_release(sys__thread__Lock);
#include <haxe/iterators/ArrayKeyValueIterator.h>
#include <hl/types/ArrayDyn.h>
extern hl_type t$fun_7b48b4f;
hl__types__ArrayObj hl_types_ArrayObj_alloc(varray*);
extern hl_type t$_f64;
bool sys_thread_Lock_wait(sys__thread__Lock,vdynamic*);
void hl_types_ArrayObj___expand(hl__types__ArrayObj,int);
extern hl_type t$haxe_iterators_ArrayKeyValueIterator;
extern hl_type t$hl_types_ArrayDyn;
extern hl_type t$hl_types_ArrayObj;
void haxe_iterators_ArrayKeyValueIterator_new(haxe__iterators__ArrayKeyValueIterator,hl__types__ArrayDyn);
extern hl_type t$vrt_7338a8d;
extern hl_type t$_i32;
double Math_max(double,double);
extern hl_type t$sys_thread_Lock;
void sys_thread_Lock_new(sys__thread__Lock);
void hl_types_ArrayObj_new(hl__types__ArrayObj);
hl_mutex* sys_thread__Mutex_Mutex_Impl___new(void);

sys__thread___EventLoop__RegularEvent sys_thread_EventLoop_repeat(sys__thread__EventLoop r0,vclosure* r1,int r2) {
	sys__thread___EventLoop__RegularEvent r7, r8;
	sys__thread__Lock r9;
	hl_mutex *r4;
	double r5, r6;
	r4 = r0->mutex;
	hl_mutex_acquire(r4);
	r5 = 0.001;
	r6 = (double)r2;
	r5 = r5 * r6;
	r7 = (sys__thread___EventLoop__RegularEvent)hl_alloc_obj(&t$sys_thread__EventLoop_RegularEvent);
	r6 = hl_sys_time();
	r6 = r6 + r5;
	sys_thread__EventLoop_RegularEvent_new(r7,r1,r6,r5);
	r8 = r0->regularEvents;
	if( !r8 ) goto label$93e7ec3_1_14;
	r7->next = r8;
	if( r8 == NULL ) hl_null_access();
	r8->previous = r7;
	label$93e7ec3_1_14:
	r0->regularEvents = r7;
	r9 = r0->waitLock;
	if( r9 == NULL ) hl_null_access();
	sys_thread_Lock_release(r9);
	r4 = r0->mutex;
	hl_mutex_release(r4);
	return r7;
}

void sys_thread_EventLoop_cancel(sys__thread__EventLoop r0,sys__thread___EventLoop__RegularEvent r1) {
	sys__thread___EventLoop__RegularEvent r4, r5;
	hl_mutex *r3;
	r3 = r0->mutex;
	hl_mutex_acquire(r3);
	r4 = r0->regularEvents;
	if( r4 != r1 ) goto label$93e7ec3_2_7;
	if( r1 == NULL ) hl_null_access();
	r4 = r1->next;
	r0->regularEvents = r4;
	label$93e7ec3_2_7:
	if( r1 == NULL ) hl_null_access();
	r4 = r1->next;
	if( !r4 ) goto label$93e7ec3_2_13;
	if( r4 == NULL ) hl_null_access();
	r5 = r1->previous;
	r4->previous = r5;
	label$93e7ec3_2_13:
	r4 = r1->previous;
	if( !r4 ) goto label$93e7ec3_2_18;
	if( r4 == NULL ) hl_null_access();
	r5 = r1->next;
	r4->next = r5;
	label$93e7ec3_2_18:
	r3 = r0->mutex;
	hl_mutex_release(r3);
	return;
}

void sys_thread_EventLoop_loop(sys__thread__EventLoop r0) {
	vvirtual *r27, *r28;
	hl__types__ArrayObj r1, r8, r17;
	hl_type *r3;
	bool r6, r34;
	sys__thread___EventLoop__RegularEvent r14, r15;
	haxe__iterators__ArrayKeyValueIterator r25;
	sys__thread__Lock r11;
	hl_mutex *r10;
	hl__types__ArrayDyn r26;
	vclosure *r19, *r29;
	double r7, r9, r12, r16, r32, r33;
	vdynamic *r13, *r24;
	int r4, r18, r20, r21, r22, r23, r30, r31;
	varray *r2;
	r3 = &t$fun_7b48b4f;
	r4 = 0;
	r2 = hl_alloc_array(r3,r4);
	r1 = hl_types_ArrayObj_alloc(r2);
	label$93e7ec3_3_4:
	r6 = true;
	if( !r6 ) goto label$93e7ec3_3_172;
	r7 = hl_sys_time();
	r8 = r1;
	r4 = 0;
	r9 = -1.;
	r10 = r0->mutex;
	hl_mutex_acquire(r10);
	label$93e7ec3_3_13:
	r11 = r0->waitLock;
	if( r11 == NULL ) hl_null_access();
	r12 = 0.;
	r13 = hl_alloc_dynamic(&t$_f64);
	r13->v.d = r12;
	r6 = sys_thread_Lock_wait(r11,r13);
	if( !r6 ) goto label$93e7ec3_3_21;
	goto label$93e7ec3_3_13;
	label$93e7ec3_3_21:
	r14 = r0->regularEvents;
	label$93e7ec3_3_22:
	if( !r14 ) goto label$93e7ec3_3_52;
	if( r14 == NULL ) hl_null_access();
	r12 = r14->nextRunTime;
	if( !(r7 >= r12) ) goto label$93e7ec3_3_43;
	if( r8 == NULL ) hl_null_access();
	r18 = r4;
	++r4;
	r19 = r14->run;
	r20 = r8->length;
	if( ((unsigned)r18) < ((unsigned)r20) ) goto label$93e7ec3_3_34;
	hl_types_ArrayObj___expand(r8,r18);
	label$93e7ec3_3_34:
	r2 = r8->array;
	((vclosure**)(r2 + 1))[r18] = r19;
	r12 = r14->nextRunTime;
	r16 = r14->interval;
	r12 = r12 + r16;
	r14->nextRunTime = r12;
	r12 = -2.;
	r9 = r12;
	goto label$93e7ec3_3_49;
	label$93e7ec3_3_43:
	r16 = -1.;
	if( r9 == r16 ) goto label$93e7ec3_3_47;
	r12 = r14->nextRunTime;
	if( !(r12 < r9) ) goto label$93e7ec3_3_49;
	label$93e7ec3_3_47:
	r12 = r14->nextRunTime;
	r9 = r12;
	label$93e7ec3_3_49:
	r15 = r14->next;
	r14 = r15;
	goto label$93e7ec3_3_22;
	label$93e7ec3_3_52:
	r10 = r0->mutex;
	hl_mutex_release(r10);
	r18 = 0;
	r20 = r4;
	label$93e7ec3_3_56:
	if( r18 >= r20 ) goto label$93e7ec3_3_77;
	r21 = r18;
	++r18;
	if( r8 == NULL ) hl_null_access();
	r23 = r8->length;
	if( ((unsigned)r21) < ((unsigned)r23) ) goto label$93e7ec3_3_65;
	r19 = NULL;
	goto label$93e7ec3_3_68;
	label$93e7ec3_3_65:
	r2 = r8->array;
	r24 = ((vdynamic**)(r2 + 1))[r21];
	r19 = (vclosure*)r24;
	label$93e7ec3_3_68:
	if( r19 == NULL ) hl_null_access();
	r19->hasValue ? ((void (*)(vdynamic*))r19->fun)((vdynamic*)r19->value) : ((void (*)(void))r19->fun)();
	r19 = NULL;
	r23 = r8->length;
	if( ((unsigned)r21) < ((unsigned)r23) ) goto label$93e7ec3_3_74;
	hl_types_ArrayObj___expand(r8,r21);
	label$93e7ec3_3_74:
	r2 = r8->array;
	((vclosure**)(r2 + 1))[r21] = r19;
	goto label$93e7ec3_3_56;
	label$93e7ec3_3_77:
	r21 = 0;
	r4 = r21;
	r10 = r0->mutex;
	hl_mutex_acquire(r10);
	r25 = (haxe__iterators__ArrayKeyValueIterator)hl_alloc_obj(&t$haxe_iterators_ArrayKeyValueIterator);
	r17 = r0->oneTimeEvents;
	r26 = (hl__types__ArrayDyn)hl_dyn_castp(&r17,&t$hl_types_ArrayObj,&t$hl_types_ArrayDyn);
	haxe_iterators_ArrayKeyValueIterator_new(r25,r26);
	label$93e7ec3_3_85:
	if( r25 == NULL ) hl_null_access();
	r6 = ((bool (*)(haxe__iterators__ArrayKeyValueIterator))r25->$type->vobj_proto[0])(r25);
	if( !r6 ) goto label$93e7ec3_3_113;
	r27 = ((vvirtual* (*)(haxe__iterators__ArrayKeyValueIterator))r25->$type->vobj_proto[1])(r25);
	r28 = hl_to_virtual(&t$vrt_7338a8d,(vdynamic*)r27);
	if( r28 == NULL ) hl_null_access();
	r21 = hl_vfields(r28)[0] ? (*(int*)(hl_vfields(r28)[0])) : (int)hl_dyn_geti(r28->value,5343647/*key*/,&t$_i32);
	r19 = hl_vfields(r28)[1] ? (*(vclosure**)(hl_vfields(r28)[1])) : (vclosure*)hl_dyn_getp(r28->value,297304054/*value*/,&t$fun_7b48b4f);
	if( r19 ) goto label$93e7ec3_3_96;
	goto label$93e7ec3_3_113;
	label$93e7ec3_3_96:
	if( r8 == NULL ) hl_null_access();
	r22 = r4;
	++r4;
	r23 = r8->length;
	if( ((unsigned)r22) < ((unsigned)r23) ) goto label$93e7ec3_3_102;
	hl_types_ArrayObj___expand(r8,r22);
	label$93e7ec3_3_102:
	r2 = r8->array;
	((vclosure**)(r2 + 1))[r22] = r19;
	r17 = r0->oneTimeEvents;
	if( r17 == NULL ) hl_null_access();
	r29 = NULL;
	r23 = r17->length;
	if( ((unsigned)r21) < ((unsigned)r23) ) goto label$93e7ec3_3_110;
	hl_types_ArrayObj___expand(r17,r21);
	label$93e7ec3_3_110:
	r2 = r17->array;
	((vclosure**)(r2 + 1))[r21] = r29;
	goto label$93e7ec3_3_85;
	label$93e7ec3_3_113:
	r21 = 0;
	r0->oneTimeEventsIdx = r21;
	r21 = r0->promisedEventsCount;
	r22 = 0;
	if( r21 > r22 ) goto label$93e7ec3_3_120;
	r6 = false;
	goto label$93e7ec3_3_121;
	label$93e7ec3_3_120:
	r6 = true;
	label$93e7ec3_3_121:
	r10 = r0->mutex;
	hl_mutex_release(r10);
	r21 = 0;
	r22 = r4;
	label$93e7ec3_3_125:
	if( r21 >= r22 ) goto label$93e7ec3_3_146;
	r23 = r21;
	++r21;
	if( r8 == NULL ) hl_null_access();
	r31 = r8->length;
	if( ((unsigned)r23) < ((unsigned)r31) ) goto label$93e7ec3_3_134;
	r19 = NULL;
	goto label$93e7ec3_3_137;
	label$93e7ec3_3_134:
	r2 = r8->array;
	r24 = ((vdynamic**)(r2 + 1))[r23];
	r19 = (vclosure*)r24;
	label$93e7ec3_3_137:
	if( r19 == NULL ) hl_null_access();
	r19->hasValue ? ((void (*)(vdynamic*))r19->fun)((vdynamic*)r19->value) : ((void (*)(void))r19->fun)();
	r19 = NULL;
	r31 = r8->length;
	if( ((unsigned)r23) < ((unsigned)r31) ) goto label$93e7ec3_3_143;
	hl_types_ArrayObj___expand(r8,r23);
	label$93e7ec3_3_143:
	r2 = r8->array;
	((vclosure**)(r2 + 1))[r23] = r19;
	goto label$93e7ec3_3_125;
	label$93e7ec3_3_146:
	r30 = 0;
	if( r30 >= r4 ) goto label$93e7ec3_3_150;
	r12 = -2.;
	r9 = r12;
	label$93e7ec3_3_150:
	r32 = -2.;
	if( r32 == r9 ) goto label$93e7ec3_3_163;
	r32 = -1.;
	if( r32 == r9 ) goto label$93e7ec3_3_164;
	r33 = hl_sys_time();
	r32 = r9 - r33;
	r11 = r0->waitLock;
	if( r11 == NULL ) hl_null_access();
	r33 = 0.;
	r33 = Math_max(r33,r32);
	r13 = hl_alloc_dynamic(&t$_f64);
	r13->v.d = r33;
	r34 = sys_thread_Lock_wait(r11,r13);
	goto label$93e7ec3_3_171;
	label$93e7ec3_3_163:
	goto label$93e7ec3_3_171;
	label$93e7ec3_3_164:
	if( !r6 ) goto label$93e7ec3_3_170;
	r11 = r0->waitLock;
	if( r11 == NULL ) hl_null_access();
	r13 = NULL;
	r34 = sys_thread_Lock_wait(r11,r13);
	goto label$93e7ec3_3_171;
	label$93e7ec3_3_170:
	goto label$93e7ec3_3_172;
	label$93e7ec3_3_171:
	goto label$93e7ec3_3_4;
	label$93e7ec3_3_172:
	return;
}

void sys_thread_EventLoop_new(sys__thread__EventLoop r0) {
	hl__types__ArrayObj r4;
	sys__thread__Lock r2;
	hl_mutex *r5;
	int r1;
	r1 = 0;
	r0->promisedEventsCount = r1;
	r2 = (sys__thread__Lock)hl_alloc_obj(&t$sys_thread_Lock);
	sys_thread_Lock_new(r2);
	r0->waitLock = r2;
	r1 = 0;
	r0->oneTimeEventsIdx = r1;
	r4 = (hl__types__ArrayObj)hl_alloc_obj(&t$hl_types_ArrayObj);
	hl_types_ArrayObj_new(r4);
	r0->oneTimeEvents = r4;
	r5 = sys_thread__Mutex_Mutex_Impl___new();
	r0->mutex = r5;
	return;
}

