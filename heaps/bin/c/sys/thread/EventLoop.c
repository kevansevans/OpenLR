// Generated by HLC 4.2.0 (HL v5)
#define HLC_BOOT
#include <hlc.h>
#include <sys/thread/EventLoop.h>
#include <hl/natives.h>
extern hl_type t$sys_thread__EventLoop_RegularEvent;
void sys_thread__EventLoop_RegularEvent_new(sys__thread___EventLoop__RegularEvent,vclosure*,double,double);
void sys_thread_Lock_release(sys__thread__Lock);
#include <haxe/iterators/ArrayKeyValueIterator.h>
#include <hl/types/ArrayDyn.h>
#include <sys/thread/NextEventTime.h>
extern hl_type t$fun_7b48b4f;
hl__types__ArrayObj hl_types_ArrayObj_alloc(varray*);
extern hl_type t$_f64;
bool sys_thread_Lock_wait(sys__thread__Lock,vdynamic*);
void hl_types_ArrayObj___expand(hl__types__ArrayObj,int);
extern hl_type t$haxe_iterators_ArrayKeyValueIterator;
extern hl_type t$hl_types_ArrayDyn;
extern hl_type t$hl_types_ArrayObj;
void haxe_iterators_ArrayKeyValueIterator_new(haxe__iterators__ArrayKeyValueIterator,hl__types__ArrayDyn);
extern hl_type t$vrt_7338a8d;
extern hl_type t$_i32;
extern hl_type t$sys_thread_NextEventTime;
extern venum* g$sys_thread_NextEventTime_Now;
extern venum* g$sys_thread_NextEventTime_Never;
double Math_max(double,double);
extern hl_type t$sys_thread_Lock;
void sys_thread_Lock_new(sys__thread__Lock);
void hl_types_ArrayObj_new(hl__types__ArrayObj);
hl_mutex* sys_thread__Mutex_Mutex_Impl___new(void);

sys__thread___EventLoop__RegularEvent sys_thread_EventLoop_repeat(sys__thread__EventLoop r0,vclosure* r1,int r2) {
	sys__thread___EventLoop__RegularEvent r7, r8;
	sys__thread__Lock r9;
	hl_mutex *r4;
	double r5, r6;
	r4 = r0->mutex;
	hl_mutex_acquire(r4);
	r5 = 0.001;
	r6 = (double)r2;
	r5 = r5 * r6;
	r7 = (sys__thread___EventLoop__RegularEvent)hl_alloc_obj(&t$sys_thread__EventLoop_RegularEvent);
	r6 = hl_sys_time();
	r6 = r6 + r5;
	sys_thread__EventLoop_RegularEvent_new(r7,r1,r6,r5);
	r8 = r0->regularEvents;
	if( !r8 ) goto label$93e7ec3_1_14;
	r7->next = r8;
	if( r8 == NULL ) hl_null_access();
	r8->previous = r7;
	label$93e7ec3_1_14:
	r0->regularEvents = r7;
	r9 = r0->waitLock;
	if( r9 == NULL ) hl_null_access();
	sys_thread_Lock_release(r9);
	r4 = r0->mutex;
	hl_mutex_release(r4);
	return r7;
}

void sys_thread_EventLoop_cancel(sys__thread__EventLoop r0,sys__thread___EventLoop__RegularEvent r1) {
	sys__thread___EventLoop__RegularEvent r4, r5;
	hl_mutex *r3;
	r3 = r0->mutex;
	hl_mutex_acquire(r3);
	r4 = r0->regularEvents;
	if( r4 != r1 ) goto label$93e7ec3_2_7;
	if( r1 == NULL ) hl_null_access();
	r4 = r1->next;
	r0->regularEvents = r4;
	label$93e7ec3_2_7:
	if( r1 == NULL ) hl_null_access();
	r4 = r1->next;
	if( !r4 ) goto label$93e7ec3_2_13;
	if( r4 == NULL ) hl_null_access();
	r5 = r1->previous;
	r4->previous = r5;
	label$93e7ec3_2_13:
	r4 = r1->previous;
	if( !r4 ) goto label$93e7ec3_2_18;
	if( r4 == NULL ) hl_null_access();
	r5 = r1->next;
	r4->next = r5;
	label$93e7ec3_2_18:
	r3 = r0->mutex;
	hl_mutex_release(r3);
	return;
}

venum* sys_thread_EventLoop_progress(sys__thread__EventLoop r0) {
	vvirtual *r26, *r27;
	hl__types__ArrayObj r3, r16;
	venum *r32;
	hl_type *r5;
	bool r9;
	sys__thread___EventLoop__RegularEvent r13, r14;
	haxe__iterators__ArrayKeyValueIterator r24;
	sys__thread__Lock r10;
	hl_mutex *r8;
	hl__types__ArrayDyn r25;
	vclosure *r18, *r28;
	double r1, r7, r11, r15, r31;
	vdynamic *r12, *r23;
	int r6, r17, r19, r20, r21, r22, r29, r30;
	varray *r4;
	r1 = hl_sys_time();
	r5 = &t$fun_7b48b4f;
	r6 = 0;
	r4 = hl_alloc_array(r5,r6);
	r3 = hl_types_ArrayObj_alloc(r4);
	r6 = 0;
	r7 = -1.;
	r8 = r0->mutex;
	hl_mutex_acquire(r8);
	label$93e7ec3_3_9:
	r10 = r0->waitLock;
	if( r10 == NULL ) hl_null_access();
	r11 = 0.;
	r12 = hl_alloc_dynamic(&t$_f64);
	r12->v.d = r11;
	r9 = sys_thread_Lock_wait(r10,r12);
	if( !r9 ) goto label$93e7ec3_3_17;
	goto label$93e7ec3_3_9;
	label$93e7ec3_3_17:
	r13 = r0->regularEvents;
	label$93e7ec3_3_18:
	if( !r13 ) goto label$93e7ec3_3_48;
	if( r13 == NULL ) hl_null_access();
	r11 = r13->nextRunTime;
	if( !(r1 >= r11) ) goto label$93e7ec3_3_39;
	if( r3 == NULL ) hl_null_access();
	r17 = r6;
	++r6;
	r18 = r13->run;
	r19 = r3->length;
	if( ((unsigned)r17) < ((unsigned)r19) ) goto label$93e7ec3_3_30;
	hl_types_ArrayObj___expand(r3,r17);
	label$93e7ec3_3_30:
	r4 = r3->array;
	((vclosure**)(r4 + 1))[r17] = r18;
	r11 = r13->nextRunTime;
	r15 = r13->interval;
	r11 = r11 + r15;
	r13->nextRunTime = r11;
	r11 = -2.;
	r7 = r11;
	goto label$93e7ec3_3_45;
	label$93e7ec3_3_39:
	r15 = -1.;
	if( r7 == r15 ) goto label$93e7ec3_3_43;
	r11 = r13->nextRunTime;
	if( !(r11 < r7) ) goto label$93e7ec3_3_45;
	label$93e7ec3_3_43:
	r11 = r13->nextRunTime;
	r7 = r11;
	label$93e7ec3_3_45:
	r14 = r13->next;
	r13 = r14;
	goto label$93e7ec3_3_18;
	label$93e7ec3_3_48:
	r8 = r0->mutex;
	hl_mutex_release(r8);
	r17 = 0;
	r19 = r6;
	label$93e7ec3_3_52:
	if( r17 >= r19 ) goto label$93e7ec3_3_73;
	r20 = r17;
	++r17;
	if( r3 == NULL ) hl_null_access();
	r22 = r3->length;
	if( ((unsigned)r20) < ((unsigned)r22) ) goto label$93e7ec3_3_61;
	r18 = NULL;
	goto label$93e7ec3_3_64;
	label$93e7ec3_3_61:
	r4 = r3->array;
	r23 = ((vdynamic**)(r4 + 1))[r20];
	r18 = (vclosure*)r23;
	label$93e7ec3_3_64:
	if( r18 == NULL ) hl_null_access();
	r18->hasValue ? ((void (*)(vdynamic*))r18->fun)((vdynamic*)r18->value) : ((void (*)(void))r18->fun)();
	r18 = NULL;
	r22 = r3->length;
	if( ((unsigned)r20) < ((unsigned)r22) ) goto label$93e7ec3_3_70;
	hl_types_ArrayObj___expand(r3,r20);
	label$93e7ec3_3_70:
	r4 = r3->array;
	((vclosure**)(r4 + 1))[r20] = r18;
	goto label$93e7ec3_3_52;
	label$93e7ec3_3_73:
	r20 = 0;
	r6 = r20;
	r8 = r0->mutex;
	hl_mutex_acquire(r8);
	r24 = (haxe__iterators__ArrayKeyValueIterator)hl_alloc_obj(&t$haxe_iterators_ArrayKeyValueIterator);
	r16 = r0->oneTimeEvents;
	r25 = (hl__types__ArrayDyn)hl_dyn_castp(&r16,&t$hl_types_ArrayObj,&t$hl_types_ArrayDyn);
	haxe_iterators_ArrayKeyValueIterator_new(r24,r25);
	label$93e7ec3_3_81:
	if( r24 == NULL ) hl_null_access();
	r9 = ((bool (*)(haxe__iterators__ArrayKeyValueIterator))r24->$type->vobj_proto[0])(r24);
	if( !r9 ) goto label$93e7ec3_3_109;
	r26 = ((vvirtual* (*)(haxe__iterators__ArrayKeyValueIterator))r24->$type->vobj_proto[1])(r24);
	r27 = hl_to_virtual(&t$vrt_7338a8d,(vdynamic*)r26);
	if( r27 == NULL ) hl_null_access();
	r20 = hl_vfields(r27)[0] ? (*(int*)(hl_vfields(r27)[0])) : (int)hl_dyn_geti(r27->value,5343647/*key*/,&t$_i32);
	r18 = hl_vfields(r27)[1] ? (*(vclosure**)(hl_vfields(r27)[1])) : (vclosure*)hl_dyn_getp(r27->value,297304054/*value*/,&t$fun_7b48b4f);
	if( r18 ) goto label$93e7ec3_3_92;
	goto label$93e7ec3_3_109;
	label$93e7ec3_3_92:
	if( r3 == NULL ) hl_null_access();
	r21 = r6;
	++r6;
	r22 = r3->length;
	if( ((unsigned)r21) < ((unsigned)r22) ) goto label$93e7ec3_3_98;
	hl_types_ArrayObj___expand(r3,r21);
	label$93e7ec3_3_98:
	r4 = r3->array;
	((vclosure**)(r4 + 1))[r21] = r18;
	r16 = r0->oneTimeEvents;
	if( r16 == NULL ) hl_null_access();
	r28 = NULL;
	r22 = r16->length;
	if( ((unsigned)r20) < ((unsigned)r22) ) goto label$93e7ec3_3_106;
	hl_types_ArrayObj___expand(r16,r20);
	label$93e7ec3_3_106:
	r4 = r16->array;
	((vclosure**)(r4 + 1))[r20] = r28;
	goto label$93e7ec3_3_81;
	label$93e7ec3_3_109:
	r20 = 0;
	r0->oneTimeEventsIdx = r20;
	r20 = r0->promisedEventsCount;
	r21 = 0;
	if( r20 > r21 ) goto label$93e7ec3_3_116;
	r9 = false;
	goto label$93e7ec3_3_117;
	label$93e7ec3_3_116:
	r9 = true;
	label$93e7ec3_3_117:
	r8 = r0->mutex;
	hl_mutex_release(r8);
	r20 = 0;
	r21 = r6;
	label$93e7ec3_3_121:
	if( r20 >= r21 ) goto label$93e7ec3_3_142;
	r22 = r20;
	++r20;
	if( r3 == NULL ) hl_null_access();
	r30 = r3->length;
	if( ((unsigned)r22) < ((unsigned)r30) ) goto label$93e7ec3_3_130;
	r18 = NULL;
	goto label$93e7ec3_3_133;
	label$93e7ec3_3_130:
	r4 = r3->array;
	r23 = ((vdynamic**)(r4 + 1))[r22];
	r18 = (vclosure*)r23;
	label$93e7ec3_3_133:
	if( r18 == NULL ) hl_null_access();
	r18->hasValue ? ((void (*)(vdynamic*))r18->fun)((vdynamic*)r18->value) : ((void (*)(void))r18->fun)();
	r18 = NULL;
	r30 = r3->length;
	if( ((unsigned)r22) < ((unsigned)r30) ) goto label$93e7ec3_3_139;
	hl_types_ArrayObj___expand(r3,r22);
	label$93e7ec3_3_139:
	r4 = r3->array;
	((vclosure**)(r4 + 1))[r22] = r18;
	goto label$93e7ec3_3_121;
	label$93e7ec3_3_142:
	r29 = 0;
	if( r29 >= r6 ) goto label$93e7ec3_3_146;
	r11 = -2.;
	r7 = r11;
	label$93e7ec3_3_146:
	r31 = -2.;
	if( r31 == r7 ) goto label$93e7ec3_3_156;
	r31 = -1.;
	if( r31 == r7 ) goto label$93e7ec3_3_158;
	if( !r9 ) goto label$93e7ec3_3_154;
	r12 = hl_alloc_dynamic(&t$_f64);
	r12->v.d = r7;
	r32 = hl_alloc_enum(&t$sys_thread_NextEventTime,2);
	((sys_thread_NextEventTime_AnyTime*)r32)->p0 = r12;
	return r32;
	label$93e7ec3_3_154:
	r32 = hl_alloc_enum(&t$sys_thread_NextEventTime,3);
	((sys_thread_NextEventTime_At*)r32)->p0 = r7;
	return r32;
	label$93e7ec3_3_156:
	r32 = (venum*)g$sys_thread_NextEventTime_Now;
	return r32;
	label$93e7ec3_3_158:
	if( !r9 ) goto label$93e7ec3_3_162;
	r12 = NULL;
	r32 = hl_alloc_enum(&t$sys_thread_NextEventTime,2);
	((sys_thread_NextEventTime_AnyTime*)r32)->p0 = r12;
	return r32;
	label$93e7ec3_3_162:
	r32 = (venum*)g$sys_thread_NextEventTime_Never;
	return r32;
}

void sys_thread_EventLoop_loop(sys__thread__EventLoop r0) {
	vvirtual *r27, *r28;
	hl__types__ArrayObj r1, r8, r17;
	hl_type *r3;
	bool r6, r34;
	sys__thread___EventLoop__RegularEvent r14, r15;
	haxe__iterators__ArrayKeyValueIterator r25;
	sys__thread__Lock r11;
	hl_mutex *r10;
	hl__types__ArrayDyn r26;
	vclosure *r19, *r29;
	double r7, r9, r12, r16, r32, r33;
	vdynamic *r13, *r24;
	int r4, r18, r20, r21, r22, r23, r30, r31;
	varray *r2;
	r3 = &t$fun_7b48b4f;
	r4 = 0;
	r2 = hl_alloc_array(r3,r4);
	r1 = hl_types_ArrayObj_alloc(r2);
	label$93e7ec3_4_4:
	r6 = true;
	if( !r6 ) goto label$93e7ec3_4_172;
	r7 = hl_sys_time();
	r8 = r1;
	r4 = 0;
	r9 = -1.;
	r10 = r0->mutex;
	hl_mutex_acquire(r10);
	label$93e7ec3_4_13:
	r11 = r0->waitLock;
	if( r11 == NULL ) hl_null_access();
	r12 = 0.;
	r13 = hl_alloc_dynamic(&t$_f64);
	r13->v.d = r12;
	r6 = sys_thread_Lock_wait(r11,r13);
	if( !r6 ) goto label$93e7ec3_4_21;
	goto label$93e7ec3_4_13;
	label$93e7ec3_4_21:
	r14 = r0->regularEvents;
	label$93e7ec3_4_22:
	if( !r14 ) goto label$93e7ec3_4_52;
	if( r14 == NULL ) hl_null_access();
	r12 = r14->nextRunTime;
	if( !(r7 >= r12) ) goto label$93e7ec3_4_43;
	if( r8 == NULL ) hl_null_access();
	r18 = r4;
	++r4;
	r19 = r14->run;
	r20 = r8->length;
	if( ((unsigned)r18) < ((unsigned)r20) ) goto label$93e7ec3_4_34;
	hl_types_ArrayObj___expand(r8,r18);
	label$93e7ec3_4_34:
	r2 = r8->array;
	((vclosure**)(r2 + 1))[r18] = r19;
	r12 = r14->nextRunTime;
	r16 = r14->interval;
	r12 = r12 + r16;
	r14->nextRunTime = r12;
	r12 = -2.;
	r9 = r12;
	goto label$93e7ec3_4_49;
	label$93e7ec3_4_43:
	r16 = -1.;
	if( r9 == r16 ) goto label$93e7ec3_4_47;
	r12 = r14->nextRunTime;
	if( !(r12 < r9) ) goto label$93e7ec3_4_49;
	label$93e7ec3_4_47:
	r12 = r14->nextRunTime;
	r9 = r12;
	label$93e7ec3_4_49:
	r15 = r14->next;
	r14 = r15;
	goto label$93e7ec3_4_22;
	label$93e7ec3_4_52:
	r10 = r0->mutex;
	hl_mutex_release(r10);
	r18 = 0;
	r20 = r4;
	label$93e7ec3_4_56:
	if( r18 >= r20 ) goto label$93e7ec3_4_77;
	r21 = r18;
	++r18;
	if( r8 == NULL ) hl_null_access();
	r23 = r8->length;
	if( ((unsigned)r21) < ((unsigned)r23) ) goto label$93e7ec3_4_65;
	r19 = NULL;
	goto label$93e7ec3_4_68;
	label$93e7ec3_4_65:
	r2 = r8->array;
	r24 = ((vdynamic**)(r2 + 1))[r21];
	r19 = (vclosure*)r24;
	label$93e7ec3_4_68:
	if( r19 == NULL ) hl_null_access();
	r19->hasValue ? ((void (*)(vdynamic*))r19->fun)((vdynamic*)r19->value) : ((void (*)(void))r19->fun)();
	r19 = NULL;
	r23 = r8->length;
	if( ((unsigned)r21) < ((unsigned)r23) ) goto label$93e7ec3_4_74;
	hl_types_ArrayObj___expand(r8,r21);
	label$93e7ec3_4_74:
	r2 = r8->array;
	((vclosure**)(r2 + 1))[r21] = r19;
	goto label$93e7ec3_4_56;
	label$93e7ec3_4_77:
	r21 = 0;
	r4 = r21;
	r10 = r0->mutex;
	hl_mutex_acquire(r10);
	r25 = (haxe__iterators__ArrayKeyValueIterator)hl_alloc_obj(&t$haxe_iterators_ArrayKeyValueIterator);
	r17 = r0->oneTimeEvents;
	r26 = (hl__types__ArrayDyn)hl_dyn_castp(&r17,&t$hl_types_ArrayObj,&t$hl_types_ArrayDyn);
	haxe_iterators_ArrayKeyValueIterator_new(r25,r26);
	label$93e7ec3_4_85:
	if( r25 == NULL ) hl_null_access();
	r6 = ((bool (*)(haxe__iterators__ArrayKeyValueIterator))r25->$type->vobj_proto[0])(r25);
	if( !r6 ) goto label$93e7ec3_4_113;
	r27 = ((vvirtual* (*)(haxe__iterators__ArrayKeyValueIterator))r25->$type->vobj_proto[1])(r25);
	r28 = hl_to_virtual(&t$vrt_7338a8d,(vdynamic*)r27);
	if( r28 == NULL ) hl_null_access();
	r21 = hl_vfields(r28)[0] ? (*(int*)(hl_vfields(r28)[0])) : (int)hl_dyn_geti(r28->value,5343647/*key*/,&t$_i32);
	r19 = hl_vfields(r28)[1] ? (*(vclosure**)(hl_vfields(r28)[1])) : (vclosure*)hl_dyn_getp(r28->value,297304054/*value*/,&t$fun_7b48b4f);
	if( r19 ) goto label$93e7ec3_4_96;
	goto label$93e7ec3_4_113;
	label$93e7ec3_4_96:
	if( r8 == NULL ) hl_null_access();
	r22 = r4;
	++r4;
	r23 = r8->length;
	if( ((unsigned)r22) < ((unsigned)r23) ) goto label$93e7ec3_4_102;
	hl_types_ArrayObj___expand(r8,r22);
	label$93e7ec3_4_102:
	r2 = r8->array;
	((vclosure**)(r2 + 1))[r22] = r19;
	r17 = r0->oneTimeEvents;
	if( r17 == NULL ) hl_null_access();
	r29 = NULL;
	r23 = r17->length;
	if( ((unsigned)r21) < ((unsigned)r23) ) goto label$93e7ec3_4_110;
	hl_types_ArrayObj___expand(r17,r21);
	label$93e7ec3_4_110:
	r2 = r17->array;
	((vclosure**)(r2 + 1))[r21] = r29;
	goto label$93e7ec3_4_85;
	label$93e7ec3_4_113:
	r21 = 0;
	r0->oneTimeEventsIdx = r21;
	r21 = r0->promisedEventsCount;
	r22 = 0;
	if( r21 > r22 ) goto label$93e7ec3_4_120;
	r6 = false;
	goto label$93e7ec3_4_121;
	label$93e7ec3_4_120:
	r6 = true;
	label$93e7ec3_4_121:
	r10 = r0->mutex;
	hl_mutex_release(r10);
	r21 = 0;
	r22 = r4;
	label$93e7ec3_4_125:
	if( r21 >= r22 ) goto label$93e7ec3_4_146;
	r23 = r21;
	++r21;
	if( r8 == NULL ) hl_null_access();
	r31 = r8->length;
	if( ((unsigned)r23) < ((unsigned)r31) ) goto label$93e7ec3_4_134;
	r19 = NULL;
	goto label$93e7ec3_4_137;
	label$93e7ec3_4_134:
	r2 = r8->array;
	r24 = ((vdynamic**)(r2 + 1))[r23];
	r19 = (vclosure*)r24;
	label$93e7ec3_4_137:
	if( r19 == NULL ) hl_null_access();
	r19->hasValue ? ((void (*)(vdynamic*))r19->fun)((vdynamic*)r19->value) : ((void (*)(void))r19->fun)();
	r19 = NULL;
	r31 = r8->length;
	if( ((unsigned)r23) < ((unsigned)r31) ) goto label$93e7ec3_4_143;
	hl_types_ArrayObj___expand(r8,r23);
	label$93e7ec3_4_143:
	r2 = r8->array;
	((vclosure**)(r2 + 1))[r23] = r19;
	goto label$93e7ec3_4_125;
	label$93e7ec3_4_146:
	r30 = 0;
	if( r30 >= r4 ) goto label$93e7ec3_4_150;
	r12 = -2.;
	r9 = r12;
	label$93e7ec3_4_150:
	r32 = -2.;
	if( r32 == r9 ) goto label$93e7ec3_4_163;
	r32 = -1.;
	if( r32 == r9 ) goto label$93e7ec3_4_164;
	r33 = hl_sys_time();
	r32 = r9 - r33;
	r11 = r0->waitLock;
	if( r11 == NULL ) hl_null_access();
	r33 = 0.;
	r33 = Math_max(r33,r32);
	r13 = hl_alloc_dynamic(&t$_f64);
	r13->v.d = r33;
	r34 = sys_thread_Lock_wait(r11,r13);
	goto label$93e7ec3_4_171;
	label$93e7ec3_4_163:
	goto label$93e7ec3_4_171;
	label$93e7ec3_4_164:
	if( !r6 ) goto label$93e7ec3_4_170;
	r11 = r0->waitLock;
	if( r11 == NULL ) hl_null_access();
	r13 = NULL;
	r34 = sys_thread_Lock_wait(r11,r13);
	goto label$93e7ec3_4_171;
	label$93e7ec3_4_170:
	goto label$93e7ec3_4_172;
	label$93e7ec3_4_171:
	goto label$93e7ec3_4_4;
	label$93e7ec3_4_172:
	return;
}

void sys_thread_EventLoop_new(sys__thread__EventLoop r0) {
	hl__types__ArrayObj r4;
	sys__thread__Lock r2;
	hl_mutex *r5;
	int r1;
	r1 = 0;
	r0->promisedEventsCount = r1;
	r2 = (sys__thread__Lock)hl_alloc_obj(&t$sys_thread_Lock);
	sys_thread_Lock_new(r2);
	r0->waitLock = r2;
	r1 = 0;
	r0->oneTimeEventsIdx = r1;
	r4 = (hl__types__ArrayObj)hl_alloc_obj(&t$hl_types_ArrayObj);
	hl_types_ArrayObj_new(r4);
	r0->oneTimeEvents = r4;
	r5 = sys_thread__Mutex_Mutex_Impl___new();
	r0->mutex = r5;
	return;
}

